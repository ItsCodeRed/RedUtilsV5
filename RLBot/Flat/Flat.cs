// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace RLBot.Flat
{

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

public enum CollisionShape : byte
{
  NONE = 0,
  BoxShape = 1,
  SphereShape = 2,
  CylinderShape = 3,
};

public class CollisionShapeUnion {
  public CollisionShape Type { get; set; }
  public object Value { get; set; }

  public CollisionShapeUnion() {
    this.Type = CollisionShape.NONE;
    this.Value = null;
  }

  public T As<T>() where T : class { return this.Value as T; }
  public RLBot.Flat.BoxShapeT AsBoxShape() { return this.As<RLBot.Flat.BoxShapeT>(); }
  public static CollisionShapeUnion FromBoxShape(RLBot.Flat.BoxShapeT _boxshape) { return new CollisionShapeUnion{ Type = CollisionShape.BoxShape, Value = _boxshape }; }
  public RLBot.Flat.SphereShapeT AsSphereShape() { return this.As<RLBot.Flat.SphereShapeT>(); }
  public static CollisionShapeUnion FromSphereShape(RLBot.Flat.SphereShapeT _sphereshape) { return new CollisionShapeUnion{ Type = CollisionShape.SphereShape, Value = _sphereshape }; }
  public RLBot.Flat.CylinderShapeT AsCylinderShape() { return this.As<RLBot.Flat.CylinderShapeT>(); }
  public static CollisionShapeUnion FromCylinderShape(RLBot.Flat.CylinderShapeT _cylindershape) { return new CollisionShapeUnion{ Type = CollisionShape.CylinderShape, Value = _cylindershape }; }

  public static int Pack(Google.FlatBuffers.FlatBufferBuilder builder, CollisionShapeUnion _o) {
    switch (_o.Type) {
      default: return 0;
      case CollisionShape.BoxShape: return RLBot.Flat.BoxShape.Pack(builder, _o.AsBoxShape()).Value;
      case CollisionShape.SphereShape: return RLBot.Flat.SphereShape.Pack(builder, _o.AsSphereShape()).Value;
      case CollisionShape.CylinderShape: return RLBot.Flat.CylinderShape.Pack(builder, _o.AsCylinderShape()).Value;
    }
  }
}



static public class CollisionShapeVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, byte typeId, uint tablePos)
  {
    bool result = true;
    switch((CollisionShape)typeId)
    {
      case CollisionShape.BoxShape:
        result = RLBot.Flat.BoxShapeVerify.Verify(verifier, tablePos);
        break;
      case CollisionShape.SphereShape:
        result = RLBot.Flat.SphereShapeVerify.Verify(verifier, tablePos);
        break;
      case CollisionShape.CylinderShape:
        result = RLBot.Flat.CylinderShapeVerify.Verify(verifier, tablePos);
        break;
      default: result = true;
        break;
    }
    return result;
  }
}

/// Possible states of a car in regards to ground contact and jump/dodging forces.
/// See more about jumping physics at https://wiki.rlbot.org/botmaking/jumping-physics/
public enum AirState : byte
{
  /// All wheels are on the ground and the car is affected by wall-stickiness forces.
  OnGround = 0,
  /// The car is currently affected by jumping forces of an initial jump.
  /// Lasts until the player lets go of jump button but at most for 0.2 seconds (240 ticks).
  /// The following AirState is typically InAir.
  Jumping = 1,
  /// The car is currently affected by jumping forces of a secondary jump (just an impulse in practice).
  /// Lasts for 13 ticks.
  /// The following AirState is typically InAir.
  DoubleJumping = 2,
  /// The car is currently affected by forces and torque of a dodges.
  /// This lasts for 79 ticks.
  /// The following AirState is typically InAir.
  Dodging = 3,
  /// The car is free falling.
  InAir = 4,
};

/// Possible phases of the match.
public enum MatchPhase : byte
{
  /// Match has not been created yet.
  Inactive = 0,
  /// 3-2-1 countdown of a kickoff.
  Countdown = 1,
  /// After kickoff countdown, but before ball has been hit.
  /// The match automatically proceeds to Active after 2 seconds.
  Kickoff = 2,
  /// The ball is in play and time is ticking.
  Active = 3,
  /// A goal was just scored. Waiting for replay to start.
  GoalScored = 4,
  /// Goal replay is being shown.
  Replay = 5,
  /// The match is paused.
  Paused = 6,
  /// The match has ended.
  Ended = 7,
};

/// Various skill levels of Psyonix bots.
public enum PsyonixSkill : byte
{
  Beginner = 0,
  Rookie = 1,
  Pro = 2,
  AllStar = 3,
};

/// Possible player types.
public enum PlayerClass : byte
{
  NONE = 0,
  Human = 1,
  CustomBot = 2,
  PsyonixBot = 3,
};

public class PlayerClassUnion {
  public PlayerClass Type { get; set; }
  public object Value { get; set; }

  public PlayerClassUnion() {
    this.Type = PlayerClass.NONE;
    this.Value = null;
  }

  public T As<T>() where T : class { return this.Value as T; }
  public RLBot.Flat.HumanT AsHuman() { return this.As<RLBot.Flat.HumanT>(); }
  public static PlayerClassUnion FromHuman(RLBot.Flat.HumanT _human) { return new PlayerClassUnion{ Type = PlayerClass.Human, Value = _human }; }
  public RLBot.Flat.CustomBotT AsCustomBot() { return this.As<RLBot.Flat.CustomBotT>(); }
  public static PlayerClassUnion FromCustomBot(RLBot.Flat.CustomBotT _custombot) { return new PlayerClassUnion{ Type = PlayerClass.CustomBot, Value = _custombot }; }
  public RLBot.Flat.PsyonixBotT AsPsyonixBot() { return this.As<RLBot.Flat.PsyonixBotT>(); }
  public static PlayerClassUnion FromPsyonixBot(RLBot.Flat.PsyonixBotT _psyonixbot) { return new PlayerClassUnion{ Type = PlayerClass.PsyonixBot, Value = _psyonixbot }; }

  public static int Pack(Google.FlatBuffers.FlatBufferBuilder builder, PlayerClassUnion _o) {
    switch (_o.Type) {
      default: return 0;
      case PlayerClass.Human: return RLBot.Flat.Human.Pack(builder, _o.AsHuman()).Value;
      case PlayerClass.CustomBot: return RLBot.Flat.CustomBot.Pack(builder, _o.AsCustomBot()).Value;
      case PlayerClass.PsyonixBot: return RLBot.Flat.PsyonixBot.Pack(builder, _o.AsPsyonixBot()).Value;
    }
  }
}



static public class PlayerClassVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, byte typeId, uint tablePos)
  {
    bool result = true;
    switch((PlayerClass)typeId)
    {
      case PlayerClass.Human:
        result = RLBot.Flat.HumanVerify.Verify(verifier, tablePos);
        break;
      case PlayerClass.CustomBot:
        result = RLBot.Flat.CustomBotVerify.Verify(verifier, tablePos);
        break;
      case PlayerClass.PsyonixBot:
        result = RLBot.Flat.PsyonixBotVerify.Verify(verifier, tablePos);
        break;
      default: result = true;
        break;
    }
    return result;
  }
}

/// Various game modes.
public enum GameMode : byte
{
  Soccar = 0,
  Hoops = 1,
  Dropshot = 2,
  Snowday = 3,
  Rumble = 4,
  Heatseeker = 5,
  Gridiron = 6,
  Knockout = 7,
};

/// Match length mutator options.
public enum MatchLengthMutator : byte
{
  FiveMinutes = 0,
  TenMinutes = 1,
  TwentyMinutes = 2,
  Unlimited = 3,
};

/// Max score mutator options.
public enum MaxScoreMutator : byte
{
  Unlimited = 0,
  OneGoal = 1,
  ThreeGoals = 2,
  FiveGoals = 3,
  SevenGoals = 4,
  TenGoals = 5,
  TwentyGoals = 6,
  ThirtyGoals = 7,
  FortyGoals = 8,
  FiftyGoals = 9,
  SixtyGoals = 10,
  SeventyGoals = 11,
  EightyGoals = 12,
  NinetyGoals = 13,
  HundredGoals = 14,
};

/// Multi ball mutator options.
public enum MultiBallMutator : byte
{
  One = 0,
  Two = 1,
  Four = 2,
  Six = 3,
};

/// Overtime mutator options.
public enum OvertimeMutator : byte
{
  Unlimited = 0,
  FiveMaxFirstScore = 1,
  FiveMaxRandomTeam = 2,
};

/// Series length mutator options.
public enum SeriesLengthMutator : byte
{
  Unlimited = 0,
  ThreeGames = 1,
  FiveGames = 2,
  SevenGames = 3,
};

/// Game speed mutator options.
public enum GameSpeedMutator : byte
{
  Default = 0,
  SloMo = 1,
  TimeWarp = 2,
};

/// Ball max speed mutator options.
public enum BallMaxSpeedMutator : byte
{
  Default = 0,
  Slow = 1,
  Fast = 2,
  SuperFast = 3,
};

/// Ball type mutator options.
public enum BallTypeMutator : byte
{
  Default = 0,
  Cube = 1,
  Puck = 2,
  Basketball = 3,
  Beachball = 4,
  Anniversary = 5,
  Haunted = 6,
  Ekin = 7,
  SpookyCube = 8,
  Egg = 9,
  PlayerSeeking = 10,
  Dropshot = 11,
  ScoreAbsorb = 12,
  Shoe = 13,
  PizzaPuck = 14,
};

/// Ball weight mutator options.
public enum BallWeightMutator : byte
{
  Default = 0,
  Light = 1,
  Heavy = 2,
  SuperLight = 3,
  CurveBall = 4,
  BeachBallCurve = 5,
  MagnusFutBall = 6,
  MagnusFutballLess = 7,
};

/// Ball size mutator options.
public enum BallSizeMutator : byte
{
  Default = 0,
  Small = 1,
  Medium = 2,
  Large = 3,
  Gigantic = 4,
};

/// Ball bounciness mutator options.
public enum BallBouncinessMutator : byte
{
  Default = 0,
  Low = 1,
  High = 2,
  SuperHigh = 3,
  Lowish = 4,
};

/// Ball gravity mutator options.
public enum BallGravityMutator : byte
{
  Default = 0,
  Low = 1,
  High = 2,
  SuperHigh = 3,
};

/// Boost amount mutator options.
public enum BoostAmountMutator : byte
{
  NormalBoost = 0,
  UnlimitedBoost = 1,
  SlowRecharge = 2,
  RapidRecharge = 3,
  NoBoost = 4,
};

/// Rumble mutator options.
public enum RumbleMutator : byte
{
  Off = 0,
  DefaultRumble = 1,
  Slow = 2,
  Civilized = 3,
  DestructionDerby = 4,
  SpringLoaded = 5,
  SpikesOnly = 6,
  SpikeRush = 7,
  HauntedBallBeam = 8,
  Tactical = 9,
  BatmanRumble = 10,
  GrapplingOnly = 11,
  HaymakerOnly = 12,
  SpikeRushForce = 13,
  RPS = 14,
};

/// Boost strength mutator options.
public enum BoostStrengthMutator : byte
{
  One = 0,
  OneAndAHalf = 1,
  Two = 2,
  Five = 3,
  Ten = 4,
};

/// Gravity mutator options.
public enum GravityMutator : byte
{
  Default = 0,
  Low = 1,
  High = 2,
  SuperHigh = 3,
  Reverse = 4,
};

/// Demolition mutator options.
public enum DemolishMutator : byte
{
  Default = 0,
  Disabled = 1,
  FriendlyFire = 2,
  OnContact = 3,
  OnContactFF = 4,
  OnBallContact = 5,
  OnBallContactFF = 6,
  OnBallContactSilent = 7,
  OnBallContactFFSilent = 8,
};

/// Respawn time mutator options.
public enum RespawnTimeMutator : byte
{
  ThreeSeconds = 0,
  TwoSeconds = 1,
  OneSecond = 2,
  DisableGoalReset = 3,
};

/// Max time mutator options.
public enum MaxTimeMutator : byte
{
  Unlimited = 0,
  ElevenMinutes = 1,
};

/// Game event mutator options.
public enum GameEventMutator : byte
{
  Default = 0,
  Haunted = 1,
  Rugby = 2,
};

/// Audio mutator options.
public enum AudioMutator : byte
{
  Default = 0,
  Haunted = 1,
};

public enum TerritoryMutator : byte
{
  Off = 0,
  Territory = 1,
};

public enum StaleBallMutator : byte
{
  Unlimited = 0,
  ThirtySeconds = 1,
};

public enum JumpMutator : byte
{
  Default = 0,
  Grounded = 1,
  Two = 2,
  Three = 3,
  Four = 4,
  Unlimited = 5,
  NoJumps = 6,
};

public enum DodgeTimerMutator : byte
{
  OnePointTwentyFiveSeconds = 0,
  TwoSeconds = 1,
  ThreeSeconds = 2,
  Unlimited = 3,
};

public enum PossessionScoreMutator : byte
{
  Off = 0,
  OneSecond = 1,
  TwoSeconds = 2,
  ThreeSeconds = 3,
};

public enum DemolishScoreMutator : byte
{
  Zero = 0,
  One = 1,
  Two = 2,
  Three = 3,
};

public enum NormalGoalScoreMutator : byte
{
  One = 0,
  Zero = 1,
  Two = 2,
  Three = 3,
  Five = 4,
  Ten = 5,
};

public enum AerialGoalScoreMutator : byte
{
  One = 0,
  Zero = 1,
  Two = 2,
  Three = 3,
  Five = 4,
  Ten = 5,
};

public enum AssistGoalScoreMutator : byte
{
  Zero = 0,
  One = 1,
  Two = 2,
  Three = 3,
};

public enum InputRestrictionMutator : byte
{
  Default = 0,
  Backwards = 1,
};

public enum ScoringRule : byte
{
  Default = 0,
  DisableGoalScoring = 1,
};

public enum DebugRendering : byte
{
  /// Renders are ignored unless explicitly enabled per-agent
  OffByDefault = 0,
  /// Rendering is enabled for everyone by default
  OnByDefault = 1,
  /// Ignore all render attempts at all times
  AlwaysOff = 2,
};

/// Possible behaviours when a match is started while another match is in progress.
public enum ExistingMatchBehavior : byte
{
  /// Always restart the match, even if config is identical.
  Restart = 0,
  /// Never restart an existing match if possible, just try to remove or spawn cars to match the configuration.
  /// If we are not in the middle of a match, a match will be started. Handy for LAN matches.
  ContinueAndSpawn = 1,
  /// Restart the match if any match settings differ.
  /// No other otherwise.
  RestartIfDifferent = 2,
};

/// Possible to launch Rocket League.
public enum Launcher : byte
{
  Steam = 0,
  Epic = 1,
  /// E.g. if you use Legendary.
  /// The game path is specified in the MatchConfiguration.
  Custom = 2,
  NoLaunch = 3,
};

/// Horizontal text alignment.
public enum TextHAlign : byte
{
  Left = 0,
  Center = 1,
  Right = 2,
};

/// Vertical text alignment.
public enum TextVAlign : byte
{
  Top = 0,
  Center = 1,
  Bottom = 2,
};

/// Anchors attached to objects.
public enum RelativeAnchor : byte
{
  NONE = 0,
  BallAnchor = 1,
  CarAnchor = 2,
};

public class RelativeAnchorUnion {
  public RelativeAnchor Type { get; set; }
  public object Value { get; set; }

  public RelativeAnchorUnion() {
    this.Type = RelativeAnchor.NONE;
    this.Value = null;
  }

  public T As<T>() where T : class { return this.Value as T; }
  public RLBot.Flat.BallAnchorT AsBallAnchor() { return this.As<RLBot.Flat.BallAnchorT>(); }
  public static RelativeAnchorUnion FromBallAnchor(RLBot.Flat.BallAnchorT _ballanchor) { return new RelativeAnchorUnion{ Type = RelativeAnchor.BallAnchor, Value = _ballanchor }; }
  public RLBot.Flat.CarAnchorT AsCarAnchor() { return this.As<RLBot.Flat.CarAnchorT>(); }
  public static RelativeAnchorUnion FromCarAnchor(RLBot.Flat.CarAnchorT _caranchor) { return new RelativeAnchorUnion{ Type = RelativeAnchor.CarAnchor, Value = _caranchor }; }

  public static int Pack(Google.FlatBuffers.FlatBufferBuilder builder, RelativeAnchorUnion _o) {
    switch (_o.Type) {
      default: return 0;
      case RelativeAnchor.BallAnchor: return RLBot.Flat.BallAnchor.Pack(builder, _o.AsBallAnchor()).Value;
      case RelativeAnchor.CarAnchor: return RLBot.Flat.CarAnchor.Pack(builder, _o.AsCarAnchor()).Value;
    }
  }
}



static public class RelativeAnchorVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, byte typeId, uint tablePos)
  {
    bool result = true;
    switch((RelativeAnchor)typeId)
    {
      case RelativeAnchor.BallAnchor:
        result = RLBot.Flat.BallAnchorVerify.Verify(verifier, tablePos);
        break;
      case RelativeAnchor.CarAnchor:
        result = RLBot.Flat.CarAnchorVerify.Verify(verifier, tablePos);
        break;
      default: result = true;
        break;
    }
    return result;
  }
}

/// The different types of RenderMessages.
public enum RenderType : byte
{
  NONE = 0,
  Line3D = 1,
  PolyLine3D = 2,
  String2D = 3,
  String3D = 4,
  Rect2D = 5,
  Rect3D = 6,
};

public class RenderTypeUnion {
  public RenderType Type { get; set; }
  public object Value { get; set; }

  public RenderTypeUnion() {
    this.Type = RenderType.NONE;
    this.Value = null;
  }

  public T As<T>() where T : class { return this.Value as T; }
  public RLBot.Flat.Line3DT AsLine3D() { return this.As<RLBot.Flat.Line3DT>(); }
  public static RenderTypeUnion FromLine3D(RLBot.Flat.Line3DT _line3d) { return new RenderTypeUnion{ Type = RenderType.Line3D, Value = _line3d }; }
  public RLBot.Flat.PolyLine3DT AsPolyLine3D() { return this.As<RLBot.Flat.PolyLine3DT>(); }
  public static RenderTypeUnion FromPolyLine3D(RLBot.Flat.PolyLine3DT _polyline3d) { return new RenderTypeUnion{ Type = RenderType.PolyLine3D, Value = _polyline3d }; }
  public RLBot.Flat.String2DT AsString2D() { return this.As<RLBot.Flat.String2DT>(); }
  public static RenderTypeUnion FromString2D(RLBot.Flat.String2DT _string2d) { return new RenderTypeUnion{ Type = RenderType.String2D, Value = _string2d }; }
  public RLBot.Flat.String3DT AsString3D() { return this.As<RLBot.Flat.String3DT>(); }
  public static RenderTypeUnion FromString3D(RLBot.Flat.String3DT _string3d) { return new RenderTypeUnion{ Type = RenderType.String3D, Value = _string3d }; }
  public RLBot.Flat.Rect2DT AsRect2D() { return this.As<RLBot.Flat.Rect2DT>(); }
  public static RenderTypeUnion FromRect2D(RLBot.Flat.Rect2DT _rect2d) { return new RenderTypeUnion{ Type = RenderType.Rect2D, Value = _rect2d }; }
  public RLBot.Flat.Rect3DT AsRect3D() { return this.As<RLBot.Flat.Rect3DT>(); }
  public static RenderTypeUnion FromRect3D(RLBot.Flat.Rect3DT _rect3d) { return new RenderTypeUnion{ Type = RenderType.Rect3D, Value = _rect3d }; }

  public static int Pack(Google.FlatBuffers.FlatBufferBuilder builder, RenderTypeUnion _o) {
    switch (_o.Type) {
      default: return 0;
      case RenderType.Line3D: return RLBot.Flat.Line3D.Pack(builder, _o.AsLine3D()).Value;
      case RenderType.PolyLine3D: return RLBot.Flat.PolyLine3D.Pack(builder, _o.AsPolyLine3D()).Value;
      case RenderType.String2D: return RLBot.Flat.String2D.Pack(builder, _o.AsString2D()).Value;
      case RenderType.String3D: return RLBot.Flat.String3D.Pack(builder, _o.AsString3D()).Value;
      case RenderType.Rect2D: return RLBot.Flat.Rect2D.Pack(builder, _o.AsRect2D()).Value;
      case RenderType.Rect3D: return RLBot.Flat.Rect3D.Pack(builder, _o.AsRect3D()).Value;
    }
  }
}



static public class RenderTypeVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, byte typeId, uint tablePos)
  {
    bool result = true;
    switch((RenderType)typeId)
    {
      case RenderType.Line3D:
        result = RLBot.Flat.Line3DVerify.Verify(verifier, tablePos);
        break;
      case RenderType.PolyLine3D:
        result = RLBot.Flat.PolyLine3DVerify.Verify(verifier, tablePos);
        break;
      case RenderType.String2D:
        result = RLBot.Flat.String2DVerify.Verify(verifier, tablePos);
        break;
      case RenderType.String3D:
        result = RLBot.Flat.String3DVerify.Verify(verifier, tablePos);
        break;
      case RenderType.Rect2D:
        result = RLBot.Flat.Rect2DVerify.Verify(verifier, tablePos);
        break;
      case RenderType.Rect3D:
        result = RLBot.Flat.Rect3DVerify.Verify(verifier, tablePos);
        break;
      default: result = true;
        break;
    }
    return result;
  }
}

/// Messages sent from core to interfaces
public enum CoreMessage : byte
{
  NONE = 0,
  /// Interface should exit when this packet is received.
  DisconnectSignal = 1,
  /// Main game packet containing all relevant data.
  /// Sent every tick once core has received InitComplete
  GamePacket = 2,
  /// Sent once core receives a valid ConnectionSettings from the interface
  FieldInfo = 3,
  /// Sent once core receives a valid MatchConfiguration from the interface
  MatchConfiguration = 4,
  /// Core relays matchcomms to bot agents in the same team if team_only is true
  MatchComm = 5,
  /// Prediction of ball trajectory
  BallPrediction = 6,
  /// Sent once core receives a valid ConnectionSettings from the interface
  ControllableTeamInfo = 7,
  /// An agent had its ability to render changed
  RenderingStatus = 8,
};

public class CoreMessageUnion {
  public CoreMessage Type { get; set; }
  public object Value { get; set; }

  public CoreMessageUnion() {
    this.Type = CoreMessage.NONE;
    this.Value = null;
  }

  public T As<T>() where T : class { return this.Value as T; }
  public RLBot.Flat.DisconnectSignalT AsDisconnectSignal() { return this.As<RLBot.Flat.DisconnectSignalT>(); }
  public static CoreMessageUnion FromDisconnectSignal(RLBot.Flat.DisconnectSignalT _disconnectsignal) { return new CoreMessageUnion{ Type = CoreMessage.DisconnectSignal, Value = _disconnectsignal }; }
  public RLBot.Flat.GamePacketT AsGamePacket() { return this.As<RLBot.Flat.GamePacketT>(); }
  public static CoreMessageUnion FromGamePacket(RLBot.Flat.GamePacketT _gamepacket) { return new CoreMessageUnion{ Type = CoreMessage.GamePacket, Value = _gamepacket }; }
  public RLBot.Flat.FieldInfoT AsFieldInfo() { return this.As<RLBot.Flat.FieldInfoT>(); }
  public static CoreMessageUnion FromFieldInfo(RLBot.Flat.FieldInfoT _fieldinfo) { return new CoreMessageUnion{ Type = CoreMessage.FieldInfo, Value = _fieldinfo }; }
  public RLBot.Flat.MatchConfigurationT AsMatchConfiguration() { return this.As<RLBot.Flat.MatchConfigurationT>(); }
  public static CoreMessageUnion FromMatchConfiguration(RLBot.Flat.MatchConfigurationT _matchconfiguration) { return new CoreMessageUnion{ Type = CoreMessage.MatchConfiguration, Value = _matchconfiguration }; }
  public RLBot.Flat.MatchCommT AsMatchComm() { return this.As<RLBot.Flat.MatchCommT>(); }
  public static CoreMessageUnion FromMatchComm(RLBot.Flat.MatchCommT _matchcomm) { return new CoreMessageUnion{ Type = CoreMessage.MatchComm, Value = _matchcomm }; }
  public RLBot.Flat.BallPredictionT AsBallPrediction() { return this.As<RLBot.Flat.BallPredictionT>(); }
  public static CoreMessageUnion FromBallPrediction(RLBot.Flat.BallPredictionT _ballprediction) { return new CoreMessageUnion{ Type = CoreMessage.BallPrediction, Value = _ballprediction }; }
  public RLBot.Flat.ControllableTeamInfoT AsControllableTeamInfo() { return this.As<RLBot.Flat.ControllableTeamInfoT>(); }
  public static CoreMessageUnion FromControllableTeamInfo(RLBot.Flat.ControllableTeamInfoT _controllableteaminfo) { return new CoreMessageUnion{ Type = CoreMessage.ControllableTeamInfo, Value = _controllableteaminfo }; }
  public RLBot.Flat.RenderingStatusT AsRenderingStatus() { return this.As<RLBot.Flat.RenderingStatusT>(); }
  public static CoreMessageUnion FromRenderingStatus(RLBot.Flat.RenderingStatusT _renderingstatus) { return new CoreMessageUnion{ Type = CoreMessage.RenderingStatus, Value = _renderingstatus }; }

  public static int Pack(Google.FlatBuffers.FlatBufferBuilder builder, CoreMessageUnion _o) {
    switch (_o.Type) {
      default: return 0;
      case CoreMessage.DisconnectSignal: return RLBot.Flat.DisconnectSignal.Pack(builder, _o.AsDisconnectSignal()).Value;
      case CoreMessage.GamePacket: return RLBot.Flat.GamePacket.Pack(builder, _o.AsGamePacket()).Value;
      case CoreMessage.FieldInfo: return RLBot.Flat.FieldInfo.Pack(builder, _o.AsFieldInfo()).Value;
      case CoreMessage.MatchConfiguration: return RLBot.Flat.MatchConfiguration.Pack(builder, _o.AsMatchConfiguration()).Value;
      case CoreMessage.MatchComm: return RLBot.Flat.MatchComm.Pack(builder, _o.AsMatchComm()).Value;
      case CoreMessage.BallPrediction: return RLBot.Flat.BallPrediction.Pack(builder, _o.AsBallPrediction()).Value;
      case CoreMessage.ControllableTeamInfo: return RLBot.Flat.ControllableTeamInfo.Pack(builder, _o.AsControllableTeamInfo()).Value;
      case CoreMessage.RenderingStatus: return RLBot.Flat.RenderingStatus.Pack(builder, _o.AsRenderingStatus()).Value;
    }
  }
}



static public class CoreMessageVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, byte typeId, uint tablePos)
  {
    bool result = true;
    switch((CoreMessage)typeId)
    {
      case CoreMessage.DisconnectSignal:
        result = RLBot.Flat.DisconnectSignalVerify.Verify(verifier, tablePos);
        break;
      case CoreMessage.GamePacket:
        result = RLBot.Flat.GamePacketVerify.Verify(verifier, tablePos);
        break;
      case CoreMessage.FieldInfo:
        result = RLBot.Flat.FieldInfoVerify.Verify(verifier, tablePos);
        break;
      case CoreMessage.MatchConfiguration:
        result = RLBot.Flat.MatchConfigurationVerify.Verify(verifier, tablePos);
        break;
      case CoreMessage.MatchComm:
        result = RLBot.Flat.MatchCommVerify.Verify(verifier, tablePos);
        break;
      case CoreMessage.BallPrediction:
        result = RLBot.Flat.BallPredictionVerify.Verify(verifier, tablePos);
        break;
      case CoreMessage.ControllableTeamInfo:
        result = RLBot.Flat.ControllableTeamInfoVerify.Verify(verifier, tablePos);
        break;
      case CoreMessage.RenderingStatus:
        result = RLBot.Flat.RenderingStatusVerify.Verify(verifier, tablePos);
        break;
      default: result = true;
        break;
    }
    return result;
  }
}

/// Messages sent from interfaces to core
public enum InterfaceMessage : byte
{
  NONE = 0,
  /// Sent to core to indicate that you want to disconnect.
  DisconnectSignal = 1,
  /// Starts a new match with a rlbot.toml file
  StartCommand = 2,
  /// Starts a new match from a MatchConfiguration
  MatchConfiguration = 3,
  /// Sent by bot agents to control their car(s)
  PlayerInput = 4,
  /// Sent by agents to state-set the game state.
  /// `enable_state_setting` must be true in the MatchConfiguration.
  DesiredGameState = 5,
  /// Sent by agents to render lines & text in the game.
  RenderGroup = 6,
  /// Sent by agents to remove a render group.
  RemoveRenderGroup = 7,
  /// Agents may send a MatchComm packet to communicate with other agents,
  /// core relays this to other agents. May be `team_only` if set.
  MatchComm = 8,
  /// Should be sent by agents immediately after connecting.
  /// Tells core about who the connection represents and what data they want to receive.
  ConnectionSettings = 9,
  /// Ends the match and optionally the RLBotServer too.
  StopCommand = 10,
  /// Sent by sessions to change the loadout of their cars. Will always work if a loadout was not
  /// specified in match settings and when sent before `InitComplete`. Ignored if state setting
  /// was disabled in the match settings, and a loadout was set in match settings.
  SetLoadout = 11,
  /// Indicates that the session has finished all initialization and is ready to start receiving
  /// game messages without delay. The match will not start until all sessions have sent this
  /// message.
  InitComplete = 12,
  /// Requests for a specificed agent to have its ability to render changed.
  /// This changed will then be broadcasted to all current connections.
  /// Does nothing if rendering has been completely disabled.
  RenderingStatus = 13,
};

public class InterfaceMessageUnion {
  public InterfaceMessage Type { get; set; }
  public object Value { get; set; }

  public InterfaceMessageUnion() {
    this.Type = InterfaceMessage.NONE;
    this.Value = null;
  }

  public T As<T>() where T : class { return this.Value as T; }
  public RLBot.Flat.DisconnectSignalT AsDisconnectSignal() { return this.As<RLBot.Flat.DisconnectSignalT>(); }
  public static InterfaceMessageUnion FromDisconnectSignal(RLBot.Flat.DisconnectSignalT _disconnectsignal) { return new InterfaceMessageUnion{ Type = InterfaceMessage.DisconnectSignal, Value = _disconnectsignal }; }
  public RLBot.Flat.StartCommandT AsStartCommand() { return this.As<RLBot.Flat.StartCommandT>(); }
  public static InterfaceMessageUnion FromStartCommand(RLBot.Flat.StartCommandT _startcommand) { return new InterfaceMessageUnion{ Type = InterfaceMessage.StartCommand, Value = _startcommand }; }
  public RLBot.Flat.MatchConfigurationT AsMatchConfiguration() { return this.As<RLBot.Flat.MatchConfigurationT>(); }
  public static InterfaceMessageUnion FromMatchConfiguration(RLBot.Flat.MatchConfigurationT _matchconfiguration) { return new InterfaceMessageUnion{ Type = InterfaceMessage.MatchConfiguration, Value = _matchconfiguration }; }
  public RLBot.Flat.PlayerInputT AsPlayerInput() { return this.As<RLBot.Flat.PlayerInputT>(); }
  public static InterfaceMessageUnion FromPlayerInput(RLBot.Flat.PlayerInputT _playerinput) { return new InterfaceMessageUnion{ Type = InterfaceMessage.PlayerInput, Value = _playerinput }; }
  public RLBot.Flat.DesiredGameStateT AsDesiredGameState() { return this.As<RLBot.Flat.DesiredGameStateT>(); }
  public static InterfaceMessageUnion FromDesiredGameState(RLBot.Flat.DesiredGameStateT _desiredgamestate) { return new InterfaceMessageUnion{ Type = InterfaceMessage.DesiredGameState, Value = _desiredgamestate }; }
  public RLBot.Flat.RenderGroupT AsRenderGroup() { return this.As<RLBot.Flat.RenderGroupT>(); }
  public static InterfaceMessageUnion FromRenderGroup(RLBot.Flat.RenderGroupT _rendergroup) { return new InterfaceMessageUnion{ Type = InterfaceMessage.RenderGroup, Value = _rendergroup }; }
  public RLBot.Flat.RemoveRenderGroupT AsRemoveRenderGroup() { return this.As<RLBot.Flat.RemoveRenderGroupT>(); }
  public static InterfaceMessageUnion FromRemoveRenderGroup(RLBot.Flat.RemoveRenderGroupT _removerendergroup) { return new InterfaceMessageUnion{ Type = InterfaceMessage.RemoveRenderGroup, Value = _removerendergroup }; }
  public RLBot.Flat.MatchCommT AsMatchComm() { return this.As<RLBot.Flat.MatchCommT>(); }
  public static InterfaceMessageUnion FromMatchComm(RLBot.Flat.MatchCommT _matchcomm) { return new InterfaceMessageUnion{ Type = InterfaceMessage.MatchComm, Value = _matchcomm }; }
  public RLBot.Flat.ConnectionSettingsT AsConnectionSettings() { return this.As<RLBot.Flat.ConnectionSettingsT>(); }
  public static InterfaceMessageUnion FromConnectionSettings(RLBot.Flat.ConnectionSettingsT _connectionsettings) { return new InterfaceMessageUnion{ Type = InterfaceMessage.ConnectionSettings, Value = _connectionsettings }; }
  public RLBot.Flat.StopCommandT AsStopCommand() { return this.As<RLBot.Flat.StopCommandT>(); }
  public static InterfaceMessageUnion FromStopCommand(RLBot.Flat.StopCommandT _stopcommand) { return new InterfaceMessageUnion{ Type = InterfaceMessage.StopCommand, Value = _stopcommand }; }
  public RLBot.Flat.SetLoadoutT AsSetLoadout() { return this.As<RLBot.Flat.SetLoadoutT>(); }
  public static InterfaceMessageUnion FromSetLoadout(RLBot.Flat.SetLoadoutT _setloadout) { return new InterfaceMessageUnion{ Type = InterfaceMessage.SetLoadout, Value = _setloadout }; }
  public RLBot.Flat.InitCompleteT AsInitComplete() { return this.As<RLBot.Flat.InitCompleteT>(); }
  public static InterfaceMessageUnion FromInitComplete(RLBot.Flat.InitCompleteT _initcomplete) { return new InterfaceMessageUnion{ Type = InterfaceMessage.InitComplete, Value = _initcomplete }; }
  public RLBot.Flat.RenderingStatusT AsRenderingStatus() { return this.As<RLBot.Flat.RenderingStatusT>(); }
  public static InterfaceMessageUnion FromRenderingStatus(RLBot.Flat.RenderingStatusT _renderingstatus) { return new InterfaceMessageUnion{ Type = InterfaceMessage.RenderingStatus, Value = _renderingstatus }; }

  public static int Pack(Google.FlatBuffers.FlatBufferBuilder builder, InterfaceMessageUnion _o) {
    switch (_o.Type) {
      default: return 0;
      case InterfaceMessage.DisconnectSignal: return RLBot.Flat.DisconnectSignal.Pack(builder, _o.AsDisconnectSignal()).Value;
      case InterfaceMessage.StartCommand: return RLBot.Flat.StartCommand.Pack(builder, _o.AsStartCommand()).Value;
      case InterfaceMessage.MatchConfiguration: return RLBot.Flat.MatchConfiguration.Pack(builder, _o.AsMatchConfiguration()).Value;
      case InterfaceMessage.PlayerInput: return RLBot.Flat.PlayerInput.Pack(builder, _o.AsPlayerInput()).Value;
      case InterfaceMessage.DesiredGameState: return RLBot.Flat.DesiredGameState.Pack(builder, _o.AsDesiredGameState()).Value;
      case InterfaceMessage.RenderGroup: return RLBot.Flat.RenderGroup.Pack(builder, _o.AsRenderGroup()).Value;
      case InterfaceMessage.RemoveRenderGroup: return RLBot.Flat.RemoveRenderGroup.Pack(builder, _o.AsRemoveRenderGroup()).Value;
      case InterfaceMessage.MatchComm: return RLBot.Flat.MatchComm.Pack(builder, _o.AsMatchComm()).Value;
      case InterfaceMessage.ConnectionSettings: return RLBot.Flat.ConnectionSettings.Pack(builder, _o.AsConnectionSettings()).Value;
      case InterfaceMessage.StopCommand: return RLBot.Flat.StopCommand.Pack(builder, _o.AsStopCommand()).Value;
      case InterfaceMessage.SetLoadout: return RLBot.Flat.SetLoadout.Pack(builder, _o.AsSetLoadout()).Value;
      case InterfaceMessage.InitComplete: return RLBot.Flat.InitComplete.Pack(builder, _o.AsInitComplete()).Value;
      case InterfaceMessage.RenderingStatus: return RLBot.Flat.RenderingStatus.Pack(builder, _o.AsRenderingStatus()).Value;
    }
  }
}



static public class InterfaceMessageVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, byte typeId, uint tablePos)
  {
    bool result = true;
    switch((InterfaceMessage)typeId)
    {
      case InterfaceMessage.DisconnectSignal:
        result = RLBot.Flat.DisconnectSignalVerify.Verify(verifier, tablePos);
        break;
      case InterfaceMessage.StartCommand:
        result = RLBot.Flat.StartCommandVerify.Verify(verifier, tablePos);
        break;
      case InterfaceMessage.MatchConfiguration:
        result = RLBot.Flat.MatchConfigurationVerify.Verify(verifier, tablePos);
        break;
      case InterfaceMessage.PlayerInput:
        result = RLBot.Flat.PlayerInputVerify.Verify(verifier, tablePos);
        break;
      case InterfaceMessage.DesiredGameState:
        result = RLBot.Flat.DesiredGameStateVerify.Verify(verifier, tablePos);
        break;
      case InterfaceMessage.RenderGroup:
        result = RLBot.Flat.RenderGroupVerify.Verify(verifier, tablePos);
        break;
      case InterfaceMessage.RemoveRenderGroup:
        result = RLBot.Flat.RemoveRenderGroupVerify.Verify(verifier, tablePos);
        break;
      case InterfaceMessage.MatchComm:
        result = RLBot.Flat.MatchCommVerify.Verify(verifier, tablePos);
        break;
      case InterfaceMessage.ConnectionSettings:
        result = RLBot.Flat.ConnectionSettingsVerify.Verify(verifier, tablePos);
        break;
      case InterfaceMessage.StopCommand:
        result = RLBot.Flat.StopCommandVerify.Verify(verifier, tablePos);
        break;
      case InterfaceMessage.SetLoadout:
        result = RLBot.Flat.SetLoadoutVerify.Verify(verifier, tablePos);
        break;
      case InterfaceMessage.InitComplete:
        result = RLBot.Flat.InitCompleteVerify.Verify(verifier, tablePos);
        break;
      case InterfaceMessage.RenderingStatus:
        result = RLBot.Flat.RenderingStatusVerify.Verify(verifier, tablePos);
        break;
      default: result = true;
        break;
    }
    return result;
  }
}

/// A message sent to other bots and scripts through RLBot.
/// Use the team_only field if the message should only be received by team mates.
/// The message can also have a human-readable summary displayed in quick chat through the display field.
public struct MatchComm : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static MatchComm GetRootAsMatchComm(ByteBuffer _bb) { return GetRootAsMatchComm(_bb, new MatchComm()); }
  public static MatchComm GetRootAsMatchComm(ByteBuffer _bb, MatchComm obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public MatchComm __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The index of the player that sent this message.
  /// For scripts, this value is the index in the match configuration instead.
  public uint Index { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  /// The team of the player that sent this message.
  /// For scripts, this value is 2.
  public uint Team { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  /// True if this message is team-only, false if everyone can see it
  public bool TeamOnly { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// The message that will be displayed on the screen in quick chat.
  /// This is intended for communication with humans.
  /// Use the content field for communication with bots and scripts.
  public string Display { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDisplayBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetDisplayBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetDisplayArray() { return __p.__vector_as_array<byte>(10); }
  /// The contents of the message.
  /// Use the display field for messages in quick chat.
  public byte Content(int j) { int o = __p.__offset(12); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int ContentLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetContentBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetContentBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetContentArray() { return __p.__vector_as_array<byte>(12); }

  public static Offset<RLBot.Flat.MatchComm> CreateMatchComm(FlatBufferBuilder builder,
      uint index = 0,
      uint team = 0,
      bool team_only = false,
      StringOffset displayOffset = default(StringOffset),
      VectorOffset contentOffset = default(VectorOffset)) {
    builder.StartTable(5);
    MatchComm.AddContent(builder, contentOffset);
    MatchComm.AddDisplay(builder, displayOffset);
    MatchComm.AddTeam(builder, team);
    MatchComm.AddIndex(builder, index);
    MatchComm.AddTeamOnly(builder, team_only);
    return MatchComm.EndMatchComm(builder);
  }

  public static void StartMatchComm(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddIndex(FlatBufferBuilder builder, uint index) { builder.AddUint(0, index, 0); }
  public static void AddTeam(FlatBufferBuilder builder, uint team) { builder.AddUint(1, team, 0); }
  public static void AddTeamOnly(FlatBufferBuilder builder, bool teamOnly) { builder.AddBool(2, teamOnly, false); }
  public static void AddDisplay(FlatBufferBuilder builder, StringOffset displayOffset) { builder.AddOffset(3, displayOffset.Value, 0); }
  public static void AddContent(FlatBufferBuilder builder, VectorOffset contentOffset) { builder.AddOffset(4, contentOffset.Value, 0); }
  public static VectorOffset CreateContentVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateContentVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateContentVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateContentVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartContentVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static Offset<RLBot.Flat.MatchComm> EndMatchComm(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 12);  // content
    return new Offset<RLBot.Flat.MatchComm>(o);
  }
  public MatchCommT UnPack() {
    var _o = new MatchCommT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(MatchCommT _o) {
    _o.Index = this.Index;
    _o.Team = this.Team;
    _o.TeamOnly = this.TeamOnly;
    _o.Display = this.Display;
    _o.Content = new List<byte>();
    for (var _j = 0; _j < this.ContentLength; ++_j) {_o.Content.Add(this.Content(_j));}
  }
  public static Offset<RLBot.Flat.MatchComm> Pack(FlatBufferBuilder builder, MatchCommT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.MatchComm>);
    var _display = _o.Display == null ? default(StringOffset) : builder.CreateString(_o.Display);
    var _content = default(VectorOffset);
    if (_o.Content != null) {
      var __content = _o.Content.ToArray();
      _content = CreateContentVector(builder, __content);
    }
    return CreateMatchComm(
      builder,
      _o.Index,
      _o.Team,
      _o.TeamOnly,
      _display,
      _content);
  }
}

public class MatchCommT
{
  public uint Index { get; set; }
  public uint Team { get; set; }
  public bool TeamOnly { get; set; }
  public string Display { get; set; }
  public List<byte> Content { get; set; }

  public MatchCommT() {
    this.Index = 0;
    this.Team = 0;
    this.TeamOnly = false;
    this.Display = null;
    this.Content = null;
  }
}


static public class MatchCommVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Index*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Team*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*TeamOnly*/, 1 /*bool*/, 1, false)
      && verifier.VerifyString(tablePos, 10 /*Display*/, false)
      && verifier.VerifyVectorOfData(tablePos, 12 /*Content*/, 1 /*byte*/, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A vector with an x and y component.
public struct Vector2 : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public Vector2 __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float X { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }
  public float Y { get { return __p.bb.GetFloat(__p.bb_pos + 4); } }

  public static Offset<RLBot.Flat.Vector2> CreateVector2(FlatBufferBuilder builder, float X, float Y) {
    builder.Prep(4, 8);
    builder.PutFloat(Y);
    builder.PutFloat(X);
    return new Offset<RLBot.Flat.Vector2>(builder.Offset);
  }
  public Vector2T UnPack() {
    var _o = new Vector2T();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(Vector2T _o) {
    _o.X = this.X;
    _o.Y = this.Y;
  }
  public static Offset<RLBot.Flat.Vector2> Pack(FlatBufferBuilder builder, Vector2T _o) {
    if (_o == null) return default(Offset<RLBot.Flat.Vector2>);
    return CreateVector2(
      builder,
      _o.X,
      _o.Y);
  }
}

public class Vector2T
{
  public float X { get; set; }
  public float Y { get; set; }

  public Vector2T() {
    this.X = 0.0f;
    this.Y = 0.0f;
  }
}

/// A vector with an x, y, z component.
/// Note that Rocket League uses a left-handed coordinate system.
public struct Vector3 : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public Vector3 __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float X { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }
  public float Y { get { return __p.bb.GetFloat(__p.bb_pos + 4); } }
  public float Z { get { return __p.bb.GetFloat(__p.bb_pos + 8); } }

  public static Offset<RLBot.Flat.Vector3> CreateVector3(FlatBufferBuilder builder, float X, float Y, float Z) {
    builder.Prep(4, 12);
    builder.PutFloat(Z);
    builder.PutFloat(Y);
    builder.PutFloat(X);
    return new Offset<RLBot.Flat.Vector3>(builder.Offset);
  }
  public Vector3T UnPack() {
    var _o = new Vector3T();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(Vector3T _o) {
    _o.X = this.X;
    _o.Y = this.Y;
    _o.Z = this.Z;
  }
  public static Offset<RLBot.Flat.Vector3> Pack(FlatBufferBuilder builder, Vector3T _o) {
    if (_o == null) return default(Offset<RLBot.Flat.Vector3>);
    return CreateVector3(
      builder,
      _o.X,
      _o.Y,
      _o.Z);
  }
}

public class Vector3T
{
  public float X { get; set; }
  public float Y { get; set; }
  public float Z { get; set; }

  public Vector3T() {
    this.X = 0.0f;
    this.Y = 0.0f;
    this.Z = 0.0f;
  }
}

/// A combination of button presses and analog steering values like those produced by a physical controller or keyboard.
/// This is sent by bots each tick to RLBot to indicate what they want to do that tick.
/// For example, if you want to hold the jump button for 20 ticks, then you must send 20 controller states where jump is true.
/// Remember to send controller states with jump set to false to let go of the jump button afterwards.
public struct ControllerState : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public ControllerState __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// -1 for full reverse, 1 for full forward.
  public float Throttle { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }
  /// -1 for full left, 1 for full right.
  public float Steer { get { return __p.bb.GetFloat(__p.bb_pos + 4); } }
  /// -1 for nose down, 1 for nose up.
  public float Pitch { get { return __p.bb.GetFloat(__p.bb_pos + 8); } }
  /// -1 for full left, 1 for full right.
  public float Yaw { get { return __p.bb.GetFloat(__p.bb_pos + 12); } }
  /// -1 for roll left, 1 for roll right.
  public float Roll { get { return __p.bb.GetFloat(__p.bb_pos + 16); } }
  /// True if you want to press the jump button.
  public bool Jump { get { return 0!=__p.bb.Get(__p.bb_pos + 20); } }
  /// True if you want to press the boost button.
  public bool Boost { get { return 0!=__p.bb.Get(__p.bb_pos + 21); } }
  /// True if you want to press the handbrake button.
  public bool Handbrake { get { return 0!=__p.bb.Get(__p.bb_pos + 22); } }
  /// True if you want to press the 'use item' button. Used in Rumble and other game modes.
  public bool UseItem { get { return 0!=__p.bb.Get(__p.bb_pos + 23); } }

  public static Offset<RLBot.Flat.ControllerState> CreateControllerState(FlatBufferBuilder builder, float Throttle, float Steer, float Pitch, float Yaw, float Roll, bool Jump, bool Boost, bool Handbrake, bool UseItem) {
    builder.Prep(4, 24);
    builder.PutBool(UseItem);
    builder.PutBool(Handbrake);
    builder.PutBool(Boost);
    builder.PutBool(Jump);
    builder.PutFloat(Roll);
    builder.PutFloat(Yaw);
    builder.PutFloat(Pitch);
    builder.PutFloat(Steer);
    builder.PutFloat(Throttle);
    return new Offset<RLBot.Flat.ControllerState>(builder.Offset);
  }
  public ControllerStateT UnPack() {
    var _o = new ControllerStateT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(ControllerStateT _o) {
    _o.Throttle = this.Throttle;
    _o.Steer = this.Steer;
    _o.Pitch = this.Pitch;
    _o.Yaw = this.Yaw;
    _o.Roll = this.Roll;
    _o.Jump = this.Jump;
    _o.Boost = this.Boost;
    _o.Handbrake = this.Handbrake;
    _o.UseItem = this.UseItem;
  }
  public static Offset<RLBot.Flat.ControllerState> Pack(FlatBufferBuilder builder, ControllerStateT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.ControllerState>);
    return CreateControllerState(
      builder,
      _o.Throttle,
      _o.Steer,
      _o.Pitch,
      _o.Yaw,
      _o.Roll,
      _o.Jump,
      _o.Boost,
      _o.Handbrake,
      _o.UseItem);
  }
}

public class ControllerStateT
{
  public float Throttle { get; set; }
  public float Steer { get; set; }
  public float Pitch { get; set; }
  public float Yaw { get; set; }
  public float Roll { get; set; }
  public bool Jump { get; set; }
  public bool Boost { get; set; }
  public bool Handbrake { get; set; }
  public bool UseItem { get; set; }

  public ControllerStateT() {
    this.Throttle = 0.0f;
    this.Steer = 0.0f;
    this.Pitch = 0.0f;
    this.Yaw = 0.0f;
    this.Roll = 0.0f;
    this.Jump = false;
    this.Boost = false;
    this.Handbrake = false;
    this.UseItem = false;
  }
}

/// A player index and the controller state of that player.
/// Used to indicate what the player is doing this tick.
public struct PlayerInput : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static PlayerInput GetRootAsPlayerInput(ByteBuffer _bb) { return GetRootAsPlayerInput(_bb, new PlayerInput()); }
  public static PlayerInput GetRootAsPlayerInput(ByteBuffer _bb, PlayerInput obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PlayerInput __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public uint PlayerIndex { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public RLBot.Flat.ControllerState? ControllerState { get { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.ControllerState?)(new RLBot.Flat.ControllerState()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static Offset<RLBot.Flat.PlayerInput> CreatePlayerInput(FlatBufferBuilder builder,
      uint player_index = 0,
      RLBot.Flat.ControllerStateT controller_state = null) {
    builder.StartTable(2);
    PlayerInput.AddControllerState(builder, RLBot.Flat.ControllerState.Pack(builder, controller_state));
    PlayerInput.AddPlayerIndex(builder, player_index);
    return PlayerInput.EndPlayerInput(builder);
  }

  public static void StartPlayerInput(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddPlayerIndex(FlatBufferBuilder builder, uint playerIndex) { builder.AddUint(0, playerIndex, 0); }
  public static void AddControllerState(FlatBufferBuilder builder, Offset<RLBot.Flat.ControllerState> controllerStateOffset) { builder.AddStruct(1, controllerStateOffset.Value, 0); }
  public static Offset<RLBot.Flat.PlayerInput> EndPlayerInput(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 6);  // controller_state
    return new Offset<RLBot.Flat.PlayerInput>(o);
  }
  public PlayerInputT UnPack() {
    var _o = new PlayerInputT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(PlayerInputT _o) {
    _o.PlayerIndex = this.PlayerIndex;
    _o.ControllerState = this.ControllerState.HasValue ? this.ControllerState.Value.UnPack() : null;
  }
  public static Offset<RLBot.Flat.PlayerInput> Pack(FlatBufferBuilder builder, PlayerInputT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.PlayerInput>);
    return CreatePlayerInput(
      builder,
      _o.PlayerIndex,
      _o.ControllerState);
  }
}

public class PlayerInputT
{
  public uint PlayerIndex { get; set; }
  public RLBot.Flat.ControllerStateT ControllerState { get; set; }

  public PlayerInputT() {
    this.PlayerIndex = 0;
    this.ControllerState = new RLBot.Flat.ControllerStateT();
  }
}


static public class PlayerInputVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*PlayerIndex*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*ControllerState*/, 24 /*RLBot.Flat.ControllerState*/, 4, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Expresses the rotation state of an object in Euler angles. Values are in radians.
public struct Rotator : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public Rotator __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// In radians with range (-pi/2,+pi/2) where 0 is flat, +pi/2 is nose straight up, -pi/2 is nose straight down.
  public float Pitch { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }
  /// In radians with range [-pi,+pi) where 0 is towards positive x, rotating clockwise as increased (when seen from above).
  public float Yaw { get { return __p.bb.GetFloat(__p.bb_pos + 4); } }
  /// In radians with range (-pi,+pi) where 0 is upright, positive is tilted right, negative is tilted left.
  public float Roll { get { return __p.bb.GetFloat(__p.bb_pos + 8); } }

  public static Offset<RLBot.Flat.Rotator> CreateRotator(FlatBufferBuilder builder, float Pitch, float Yaw, float Roll) {
    builder.Prep(4, 12);
    builder.PutFloat(Roll);
    builder.PutFloat(Yaw);
    builder.PutFloat(Pitch);
    return new Offset<RLBot.Flat.Rotator>(builder.Offset);
  }
  public RotatorT UnPack() {
    var _o = new RotatorT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(RotatorT _o) {
    _o.Pitch = this.Pitch;
    _o.Yaw = this.Yaw;
    _o.Roll = this.Roll;
  }
  public static Offset<RLBot.Flat.Rotator> Pack(FlatBufferBuilder builder, RotatorT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.Rotator>);
    return CreateRotator(
      builder,
      _o.Pitch,
      _o.Yaw,
      _o.Roll);
  }
}

public class RotatorT
{
  public float Pitch { get; set; }
  public float Yaw { get; set; }
  public float Roll { get; set; }

  public RotatorT() {
    this.Pitch = 0.0f;
    this.Yaw = 0.0f;
    this.Roll = 0.0f;
  }
}

/// A box with dimensions.
/// Used for cars and balls with a box shapes.
public struct BoxShape : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static BoxShape GetRootAsBoxShape(ByteBuffer _bb) { return GetRootAsBoxShape(_bb, new BoxShape()); }
  public static BoxShape GetRootAsBoxShape(ByteBuffer _bb, BoxShape obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BoxShape __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float Length { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float Width { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float Height { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<RLBot.Flat.BoxShape> CreateBoxShape(FlatBufferBuilder builder,
      float length = 0.0f,
      float width = 0.0f,
      float height = 0.0f) {
    builder.StartTable(3);
    BoxShape.AddHeight(builder, height);
    BoxShape.AddWidth(builder, width);
    BoxShape.AddLength(builder, length);
    return BoxShape.EndBoxShape(builder);
  }

  public static void StartBoxShape(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddLength(FlatBufferBuilder builder, float length) { builder.AddFloat(0, length, 0.0f); }
  public static void AddWidth(FlatBufferBuilder builder, float width) { builder.AddFloat(1, width, 0.0f); }
  public static void AddHeight(FlatBufferBuilder builder, float height) { builder.AddFloat(2, height, 0.0f); }
  public static Offset<RLBot.Flat.BoxShape> EndBoxShape(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RLBot.Flat.BoxShape>(o);
  }
  public BoxShapeT UnPack() {
    var _o = new BoxShapeT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(BoxShapeT _o) {
    _o.Length = this.Length;
    _o.Width = this.Width;
    _o.Height = this.Height;
  }
  public static Offset<RLBot.Flat.BoxShape> Pack(FlatBufferBuilder builder, BoxShapeT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.BoxShape>);
    return CreateBoxShape(
      builder,
      _o.Length,
      _o.Width,
      _o.Height);
  }
}

public class BoxShapeT
{
  public float Length { get; set; }
  public float Width { get; set; }
  public float Height { get; set; }

  public BoxShapeT() {
    this.Length = 0.0f;
    this.Width = 0.0f;
    this.Height = 0.0f;
  }
}


static public class BoxShapeVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Length*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Width*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Height*/, 4 /*float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A sphere with diameter.
/// Used for balls with a spherical shapes.
public struct SphereShape : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static SphereShape GetRootAsSphereShape(ByteBuffer _bb) { return GetRootAsSphereShape(_bb, new SphereShape()); }
  public static SphereShape GetRootAsSphereShape(ByteBuffer _bb, SphereShape obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SphereShape __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float Diameter { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<RLBot.Flat.SphereShape> CreateSphereShape(FlatBufferBuilder builder,
      float diameter = 0.0f) {
    builder.StartTable(1);
    SphereShape.AddDiameter(builder, diameter);
    return SphereShape.EndSphereShape(builder);
  }

  public static void StartSphereShape(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddDiameter(FlatBufferBuilder builder, float diameter) { builder.AddFloat(0, diameter, 0.0f); }
  public static Offset<RLBot.Flat.SphereShape> EndSphereShape(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RLBot.Flat.SphereShape>(o);
  }
  public SphereShapeT UnPack() {
    var _o = new SphereShapeT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(SphereShapeT _o) {
    _o.Diameter = this.Diameter;
  }
  public static Offset<RLBot.Flat.SphereShape> Pack(FlatBufferBuilder builder, SphereShapeT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.SphereShape>);
    return CreateSphereShape(
      builder,
      _o.Diameter);
  }
}

public class SphereShapeT
{
  public float Diameter { get; set; }

  public SphereShapeT() {
    this.Diameter = 0.0f;
  }
}


static public class SphereShapeVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Diameter*/, 4 /*float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A cylinder with diameter and height.
/// Used for balls with a cylindrical shape like the puck.
public struct CylinderShape : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static CylinderShape GetRootAsCylinderShape(ByteBuffer _bb) { return GetRootAsCylinderShape(_bb, new CylinderShape()); }
  public static CylinderShape GetRootAsCylinderShape(ByteBuffer _bb, CylinderShape obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public CylinderShape __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float Diameter { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float Height { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<RLBot.Flat.CylinderShape> CreateCylinderShape(FlatBufferBuilder builder,
      float diameter = 0.0f,
      float height = 0.0f) {
    builder.StartTable(2);
    CylinderShape.AddHeight(builder, height);
    CylinderShape.AddDiameter(builder, diameter);
    return CylinderShape.EndCylinderShape(builder);
  }

  public static void StartCylinderShape(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddDiameter(FlatBufferBuilder builder, float diameter) { builder.AddFloat(0, diameter, 0.0f); }
  public static void AddHeight(FlatBufferBuilder builder, float height) { builder.AddFloat(1, height, 0.0f); }
  public static Offset<RLBot.Flat.CylinderShape> EndCylinderShape(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RLBot.Flat.CylinderShape>(o);
  }
  public CylinderShapeT UnPack() {
    var _o = new CylinderShapeT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(CylinderShapeT _o) {
    _o.Diameter = this.Diameter;
    _o.Height = this.Height;
  }
  public static Offset<RLBot.Flat.CylinderShape> Pack(FlatBufferBuilder builder, CylinderShapeT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.CylinderShape>);
    return CreateCylinderShape(
      builder,
      _o.Diameter,
      _o.Height);
  }
}

public class CylinderShapeT
{
  public float Diameter { get; set; }
  public float Height { get; set; }

  public CylinderShapeT() {
    this.Diameter = 0.0f;
    this.Height = 0.0f;
  }
}


static public class CylinderShapeVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Diameter*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Height*/, 4 /*float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Information about a ball touch.
public struct Touch : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static Touch GetRootAsTouch(ByteBuffer _bb) { return GetRootAsTouch(_bb, new Touch()); }
  public static Touch GetRootAsTouch(ByteBuffer _bb, Touch obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Touch __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Seconds that had elapsed in the game when the touch occurred.
  public float GameSeconds { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// The point of contact for the touch.
  public RLBot.Flat.Vector3? Location { get { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.Vector3?)(new RLBot.Flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// The direction of the touch as a unit vector pointing from the point of contact towards the center of the ball.
  public RLBot.Flat.Vector3? Normal { get { int o = __p.__offset(8); return o != 0 ? (RLBot.Flat.Vector3?)(new RLBot.Flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// The index of the ball that was touched (in case there are multiple balls).
  public uint BallIndex { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }

  public static Offset<RLBot.Flat.Touch> CreateTouch(FlatBufferBuilder builder,
      float game_seconds = 0.0f,
      RLBot.Flat.Vector3T location = null,
      RLBot.Flat.Vector3T normal = null,
      uint ball_index = 0) {
    builder.StartTable(4);
    Touch.AddBallIndex(builder, ball_index);
    Touch.AddNormal(builder, RLBot.Flat.Vector3.Pack(builder, normal));
    Touch.AddLocation(builder, RLBot.Flat.Vector3.Pack(builder, location));
    Touch.AddGameSeconds(builder, game_seconds);
    return Touch.EndTouch(builder);
  }

  public static void StartTouch(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddGameSeconds(FlatBufferBuilder builder, float gameSeconds) { builder.AddFloat(0, gameSeconds, 0.0f); }
  public static void AddLocation(FlatBufferBuilder builder, Offset<RLBot.Flat.Vector3> locationOffset) { builder.AddStruct(1, locationOffset.Value, 0); }
  public static void AddNormal(FlatBufferBuilder builder, Offset<RLBot.Flat.Vector3> normalOffset) { builder.AddStruct(2, normalOffset.Value, 0); }
  public static void AddBallIndex(FlatBufferBuilder builder, uint ballIndex) { builder.AddUint(3, ballIndex, 0); }
  public static Offset<RLBot.Flat.Touch> EndTouch(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 6);  // location
    builder.Required(o, 8);  // normal
    return new Offset<RLBot.Flat.Touch>(o);
  }
  public TouchT UnPack() {
    var _o = new TouchT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(TouchT _o) {
    _o.GameSeconds = this.GameSeconds;
    _o.Location = this.Location.HasValue ? this.Location.Value.UnPack() : null;
    _o.Normal = this.Normal.HasValue ? this.Normal.Value.UnPack() : null;
    _o.BallIndex = this.BallIndex;
  }
  public static Offset<RLBot.Flat.Touch> Pack(FlatBufferBuilder builder, TouchT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.Touch>);
    return CreateTouch(
      builder,
      _o.GameSeconds,
      _o.Location,
      _o.Normal,
      _o.BallIndex);
  }
}

public class TouchT
{
  public float GameSeconds { get; set; }
  public RLBot.Flat.Vector3T Location { get; set; }
  public RLBot.Flat.Vector3T Normal { get; set; }
  public uint BallIndex { get; set; }

  public TouchT() {
    this.GameSeconds = 0.0f;
    this.Location = new RLBot.Flat.Vector3T();
    this.Normal = new RLBot.Flat.Vector3T();
    this.BallIndex = 0;
  }
}


static public class TouchVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*GameSeconds*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Location*/, 12 /*RLBot.Flat.Vector3*/, 4, true)
      && verifier.VerifyField(tablePos, 8 /*Normal*/, 12 /*RLBot.Flat.Vector3*/, 4, true)
      && verifier.VerifyField(tablePos, 10 /*BallIndex*/, 4 /*uint*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A collection of values shown on the scoreboard (and a few more).
public struct ScoreInfo : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public ScoreInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The accumulated score, roughly indicating how well a player performs.
  public uint Score { get { return __p.bb.GetUint(__p.bb_pos + 0); } }
  /// Number of goals scored.
  public uint Goals { get { return __p.bb.GetUint(__p.bb_pos + 4); } }
  /// Number of own-goals scored.
  public uint OwnGoals { get { return __p.bb.GetUint(__p.bb_pos + 8); } }
  /// Number of goals assisted.
  public uint Assists { get { return __p.bb.GetUint(__p.bb_pos + 12); } }
  /// Number of shots saved.
  public uint Saves { get { return __p.bb.GetUint(__p.bb_pos + 16); } }
  /// Number of shots on opponent goal.
  public uint Shots { get { return __p.bb.GetUint(__p.bb_pos + 20); } }
  /// Number of demolitions made.
  public uint Demolitions { get { return __p.bb.GetUint(__p.bb_pos + 24); } }

  public static Offset<RLBot.Flat.ScoreInfo> CreateScoreInfo(FlatBufferBuilder builder, uint Score, uint Goals, uint OwnGoals, uint Assists, uint Saves, uint Shots, uint Demolitions) {
    builder.Prep(4, 28);
    builder.PutUint(Demolitions);
    builder.PutUint(Shots);
    builder.PutUint(Saves);
    builder.PutUint(Assists);
    builder.PutUint(OwnGoals);
    builder.PutUint(Goals);
    builder.PutUint(Score);
    return new Offset<RLBot.Flat.ScoreInfo>(builder.Offset);
  }
  public ScoreInfoT UnPack() {
    var _o = new ScoreInfoT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(ScoreInfoT _o) {
    _o.Score = this.Score;
    _o.Goals = this.Goals;
    _o.OwnGoals = this.OwnGoals;
    _o.Assists = this.Assists;
    _o.Saves = this.Saves;
    _o.Shots = this.Shots;
    _o.Demolitions = this.Demolitions;
  }
  public static Offset<RLBot.Flat.ScoreInfo> Pack(FlatBufferBuilder builder, ScoreInfoT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.ScoreInfo>);
    return CreateScoreInfo(
      builder,
      _o.Score,
      _o.Goals,
      _o.OwnGoals,
      _o.Assists,
      _o.Saves,
      _o.Shots,
      _o.Demolitions);
  }
}

public class ScoreInfoT
{
  public uint Score { get; set; }
  public uint Goals { get; set; }
  public uint OwnGoals { get; set; }
  public uint Assists { get; set; }
  public uint Saves { get; set; }
  public uint Shots { get; set; }
  public uint Demolitions { get; set; }

  public ScoreInfoT() {
    this.Score = 0;
    this.Goals = 0;
    this.OwnGoals = 0;
    this.Assists = 0;
    this.Saves = 0;
    this.Shots = 0;
    this.Demolitions = 0;
  }
}

/// The physical state of an object.
public struct Physics : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public Physics __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public RLBot.Flat.Vector3 Location { get { return (new RLBot.Flat.Vector3()).__assign(__p.bb_pos + 0, __p.bb); } }
  public RLBot.Flat.Rotator Rotation { get { return (new RLBot.Flat.Rotator()).__assign(__p.bb_pos + 12, __p.bb); } }
  public RLBot.Flat.Vector3 Velocity { get { return (new RLBot.Flat.Vector3()).__assign(__p.bb_pos + 24, __p.bb); } }
  public RLBot.Flat.Vector3 AngularVelocity { get { return (new RLBot.Flat.Vector3()).__assign(__p.bb_pos + 36, __p.bb); } }

  public static Offset<RLBot.Flat.Physics> CreatePhysics(FlatBufferBuilder builder, float location_X, float location_Y, float location_Z, float rotation_Pitch, float rotation_Yaw, float rotation_Roll, float velocity_X, float velocity_Y, float velocity_Z, float angular_velocity_X, float angular_velocity_Y, float angular_velocity_Z) {
    builder.Prep(4, 48);
    builder.Prep(4, 12);
    builder.PutFloat(angular_velocity_Z);
    builder.PutFloat(angular_velocity_Y);
    builder.PutFloat(angular_velocity_X);
    builder.Prep(4, 12);
    builder.PutFloat(velocity_Z);
    builder.PutFloat(velocity_Y);
    builder.PutFloat(velocity_X);
    builder.Prep(4, 12);
    builder.PutFloat(rotation_Roll);
    builder.PutFloat(rotation_Yaw);
    builder.PutFloat(rotation_Pitch);
    builder.Prep(4, 12);
    builder.PutFloat(location_Z);
    builder.PutFloat(location_Y);
    builder.PutFloat(location_X);
    return new Offset<RLBot.Flat.Physics>(builder.Offset);
  }
  public PhysicsT UnPack() {
    var _o = new PhysicsT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(PhysicsT _o) {
    _o.Location = this.Location.UnPack();
    _o.Rotation = this.Rotation.UnPack();
    _o.Velocity = this.Velocity.UnPack();
    _o.AngularVelocity = this.AngularVelocity.UnPack();
  }
  public static Offset<RLBot.Flat.Physics> Pack(FlatBufferBuilder builder, PhysicsT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.Physics>);
    var _location_x = _o.Location.X;
    var _location_y = _o.Location.Y;
    var _location_z = _o.Location.Z;
    var _rotation_pitch = _o.Rotation.Pitch;
    var _rotation_yaw = _o.Rotation.Yaw;
    var _rotation_roll = _o.Rotation.Roll;
    var _velocity_x = _o.Velocity.X;
    var _velocity_y = _o.Velocity.Y;
    var _velocity_z = _o.Velocity.Z;
    var _angular_velocity_x = _o.AngularVelocity.X;
    var _angular_velocity_y = _o.AngularVelocity.Y;
    var _angular_velocity_z = _o.AngularVelocity.Z;
    return CreatePhysics(
      builder,
      _location_x,
      _location_y,
      _location_z,
      _rotation_pitch,
      _rotation_yaw,
      _rotation_roll,
      _velocity_x,
      _velocity_y,
      _velocity_z,
      _angular_velocity_x,
      _angular_velocity_y,
      _angular_velocity_z);
  }
}

public class PhysicsT
{
  public RLBot.Flat.Vector3T Location { get; set; }
  public RLBot.Flat.RotatorT Rotation { get; set; }
  public RLBot.Flat.Vector3T Velocity { get; set; }
  public RLBot.Flat.Vector3T AngularVelocity { get; set; }

  public PhysicsT() {
    this.Location = new RLBot.Flat.Vector3T();
    this.Rotation = new RLBot.Flat.RotatorT();
    this.Velocity = new RLBot.Flat.Vector3T();
    this.AngularVelocity = new RLBot.Flat.Vector3T();
  }
}

/// A collection of information about a player and their car.
public struct PlayerInfo : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static PlayerInfo GetRootAsPlayerInfo(ByteBuffer _bb) { return GetRootAsPlayerInfo(_bb, new PlayerInfo()); }
  public static PlayerInfo GetRootAsPlayerInfo(ByteBuffer _bb, PlayerInfo obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PlayerInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The physical state of the player's car.
  public RLBot.Flat.Physics? Physics { get { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.Physics?)(new RLBot.Flat.Physics()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// The various scores of this player, e.g. those on the leaderboard.
  public RLBot.Flat.ScoreInfo? ScoreInfo { get { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.ScoreInfo?)(new RLBot.Flat.ScoreInfo()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// The hitbox of the player's car.
  /// Note that the hitbox is not centered at the cars location.
  /// See the hitbox offset.
  public RLBot.Flat.BoxShape? Hitbox { get { int o = __p.__offset(8); return o != 0 ? (RLBot.Flat.BoxShape?)(new RLBot.Flat.BoxShape()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// The center of the hitbox in local coordinates.
  public RLBot.Flat.Vector3? HitboxOffset { get { int o = __p.__offset(10); return o != 0 ? (RLBot.Flat.Vector3?)(new RLBot.Flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// Information about the latest touch with a ball.
  /// Is null if the player has yet to touch the ball.
  public RLBot.Flat.Touch? LatestTouch { get { int o = __p.__offset(12); return o != 0 ? (RLBot.Flat.Touch?)(new RLBot.Flat.Touch()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// Whether the player's car is on the ground or in the air, and what jump/dodging forces currently affects the car.
  public RLBot.Flat.AirState AirState { get { int o = __p.__offset(14); return o != 0 ? (RLBot.Flat.AirState)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.AirState.OnGround; } }
  /// How long until the player cannot dodge/double jump anymore.
  /// The value is -1 while on ground or when airborne for too long after jumping.
  /// A dodge/double jump is possible for 1.25 seconds after the first jump plus
  /// up to an additional 0.2 seconds depending how long the jump button was pressed for the first jump.
  public float DodgeTimeout { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// How long until the player is not demolished anymore.
  /// The value is -1 if while not demolished.
  public float DemolishedTimeout { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// Whether the player's car is moving at supersonic speed and can demolish.
  public bool IsSupersonic { get { int o = __p.__offset(20); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Whether the player is a bot or a human.
  public bool IsBot { get { int o = __p.__offset(22); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// The name of the player as it appears in game, i.e. possibly appended with "(2)".
  /// The original name can be found in the match configuration.
  public string Name { get { int o = __p.__offset(24); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(24, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(24); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(24); }
  /// The team of the player.
  public uint Team { get { int o = __p.__offset(26); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  /// The current boost, from 0 to 100.
  public float Boost { get { int o = __p.__offset(28); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// The id of the player.
  /// This value is mostly used internally to keep track of participants in the match.
  /// The id can be used to find the corresponding PlayerConfiguration in the MatchConfiguration.
  public int PlayerId { get { int o = __p.__offset(30); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// Events from the latest tick involving this player. Possible values include:
  ///    Win, Loss, TimePlayed;
  ///    Shot, Assist, Center, Clear, PoolShot;
  ///    Goal, AerialGoal, BicycleGoal, BulletGoal, BackwardsGoal, LongGoal, OvertimeGoal, TurtleGoal;
  ///    AerialHit, BicycleHit, BulletHit, JuggleHit, FirstTouch, BallHit;
  ///    Save, EpicSave, FreezeSave;
  ///    HatTrick, Savior, Playmaker, MVP;
  ///    FastestGoal, SlowestGoal, FurthestGoal, OwnGoal;
  ///    MostBallTouches, FewestBallTouches, MostBoostPickups, FewestBoostPickups, BoostPickups;
  ///    CarTouches, Demolition, Demolish;
  ///    LowFive, HighFive;
  /// Note that the list clears every tick.
  public string Accolades(int j) { int o = __p.__offset(32); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int AccoladesLength { get { int o = __p.__offset(32); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The last controller input from this player.
  public RLBot.Flat.ControllerState? LastInput { get { int o = __p.__offset(34); return o != 0 ? (RLBot.Flat.ControllerState?)(new RLBot.Flat.ControllerState()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// True if the player has jumped. See dodge_timeout to know if a dodge/secondary jump is available.
  public bool HasJumped { get { int o = __p.__offset(36); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// True if the player has doubled jumped.
  public bool HasDoubleJumped { get { int o = __p.__offset(38); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// True if the player has dodged.
  public bool HasDodged { get { int o = __p.__offset(40); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// The time in seconds since the last dodge was initiated.
  /// Resets to 0 when the player lands on the ground.
  public float DodgeElapsed { get { int o = __p.__offset(42); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// The unit direction of the latest dodge.
  /// The value will be (0,0) if it was a stall.
  public RLBot.Flat.Vector2? DodgeDir { get { int o = __p.__offset(44); return o != 0 ? (RLBot.Flat.Vector2?)(new RLBot.Flat.Vector2()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static Offset<RLBot.Flat.PlayerInfo> CreatePlayerInfo(FlatBufferBuilder builder,
      RLBot.Flat.PhysicsT physics = null,
      RLBot.Flat.ScoreInfoT score_info = null,
      Offset<RLBot.Flat.BoxShape> hitboxOffset = default(Offset<RLBot.Flat.BoxShape>),
      RLBot.Flat.Vector3T hitbox_offset = null,
      Offset<RLBot.Flat.Touch> latest_touchOffset = default(Offset<RLBot.Flat.Touch>),
      RLBot.Flat.AirState air_state = RLBot.Flat.AirState.OnGround,
      float dodge_timeout = 0.0f,
      float demolished_timeout = 0.0f,
      bool is_supersonic = false,
      bool is_bot = false,
      StringOffset nameOffset = default(StringOffset),
      uint team = 0,
      float boost = 0.0f,
      int player_id = 0,
      VectorOffset accoladesOffset = default(VectorOffset),
      RLBot.Flat.ControllerStateT last_input = null,
      bool has_jumped = false,
      bool has_double_jumped = false,
      bool has_dodged = false,
      float dodge_elapsed = 0.0f,
      RLBot.Flat.Vector2T dodge_dir = null) {
    builder.StartTable(21);
    PlayerInfo.AddDodgeDir(builder, RLBot.Flat.Vector2.Pack(builder, dodge_dir));
    PlayerInfo.AddDodgeElapsed(builder, dodge_elapsed);
    PlayerInfo.AddLastInput(builder, RLBot.Flat.ControllerState.Pack(builder, last_input));
    PlayerInfo.AddAccolades(builder, accoladesOffset);
    PlayerInfo.AddPlayerId(builder, player_id);
    PlayerInfo.AddBoost(builder, boost);
    PlayerInfo.AddTeam(builder, team);
    PlayerInfo.AddName(builder, nameOffset);
    PlayerInfo.AddDemolishedTimeout(builder, demolished_timeout);
    PlayerInfo.AddDodgeTimeout(builder, dodge_timeout);
    PlayerInfo.AddLatestTouch(builder, latest_touchOffset);
    PlayerInfo.AddHitboxOffset(builder, RLBot.Flat.Vector3.Pack(builder, hitbox_offset));
    PlayerInfo.AddHitbox(builder, hitboxOffset);
    PlayerInfo.AddScoreInfo(builder, RLBot.Flat.ScoreInfo.Pack(builder, score_info));
    PlayerInfo.AddPhysics(builder, RLBot.Flat.Physics.Pack(builder, physics));
    PlayerInfo.AddHasDodged(builder, has_dodged);
    PlayerInfo.AddHasDoubleJumped(builder, has_double_jumped);
    PlayerInfo.AddHasJumped(builder, has_jumped);
    PlayerInfo.AddIsBot(builder, is_bot);
    PlayerInfo.AddIsSupersonic(builder, is_supersonic);
    PlayerInfo.AddAirState(builder, air_state);
    return PlayerInfo.EndPlayerInfo(builder);
  }

  public static void StartPlayerInfo(FlatBufferBuilder builder) { builder.StartTable(21); }
  public static void AddPhysics(FlatBufferBuilder builder, Offset<RLBot.Flat.Physics> physicsOffset) { builder.AddStruct(0, physicsOffset.Value, 0); }
  public static void AddScoreInfo(FlatBufferBuilder builder, Offset<RLBot.Flat.ScoreInfo> scoreInfoOffset) { builder.AddStruct(1, scoreInfoOffset.Value, 0); }
  public static void AddHitbox(FlatBufferBuilder builder, Offset<RLBot.Flat.BoxShape> hitboxOffset) { builder.AddOffset(2, hitboxOffset.Value, 0); }
  public static void AddHitboxOffset(FlatBufferBuilder builder, Offset<RLBot.Flat.Vector3> hitboxOffsetOffset) { builder.AddStruct(3, hitboxOffsetOffset.Value, 0); }
  public static void AddLatestTouch(FlatBufferBuilder builder, Offset<RLBot.Flat.Touch> latestTouchOffset) { builder.AddOffset(4, latestTouchOffset.Value, 0); }
  public static void AddAirState(FlatBufferBuilder builder, RLBot.Flat.AirState airState) { builder.AddByte(5, (byte)airState, 0); }
  public static void AddDodgeTimeout(FlatBufferBuilder builder, float dodgeTimeout) { builder.AddFloat(6, dodgeTimeout, 0.0f); }
  public static void AddDemolishedTimeout(FlatBufferBuilder builder, float demolishedTimeout) { builder.AddFloat(7, demolishedTimeout, 0.0f); }
  public static void AddIsSupersonic(FlatBufferBuilder builder, bool isSupersonic) { builder.AddBool(8, isSupersonic, false); }
  public static void AddIsBot(FlatBufferBuilder builder, bool isBot) { builder.AddBool(9, isBot, false); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(10, nameOffset.Value, 0); }
  public static void AddTeam(FlatBufferBuilder builder, uint team) { builder.AddUint(11, team, 0); }
  public static void AddBoost(FlatBufferBuilder builder, float boost) { builder.AddFloat(12, boost, 0.0f); }
  public static void AddPlayerId(FlatBufferBuilder builder, int playerId) { builder.AddInt(13, playerId, 0); }
  public static void AddAccolades(FlatBufferBuilder builder, VectorOffset accoladesOffset) { builder.AddOffset(14, accoladesOffset.Value, 0); }
  public static VectorOffset CreateAccoladesVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateAccoladesVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAccoladesVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAccoladesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartAccoladesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddLastInput(FlatBufferBuilder builder, Offset<RLBot.Flat.ControllerState> lastInputOffset) { builder.AddStruct(15, lastInputOffset.Value, 0); }
  public static void AddHasJumped(FlatBufferBuilder builder, bool hasJumped) { builder.AddBool(16, hasJumped, false); }
  public static void AddHasDoubleJumped(FlatBufferBuilder builder, bool hasDoubleJumped) { builder.AddBool(17, hasDoubleJumped, false); }
  public static void AddHasDodged(FlatBufferBuilder builder, bool hasDodged) { builder.AddBool(18, hasDodged, false); }
  public static void AddDodgeElapsed(FlatBufferBuilder builder, float dodgeElapsed) { builder.AddFloat(19, dodgeElapsed, 0.0f); }
  public static void AddDodgeDir(FlatBufferBuilder builder, Offset<RLBot.Flat.Vector2> dodgeDirOffset) { builder.AddStruct(20, dodgeDirOffset.Value, 0); }
  public static Offset<RLBot.Flat.PlayerInfo> EndPlayerInfo(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // physics
    builder.Required(o, 6);  // score_info
    builder.Required(o, 8);  // hitbox
    builder.Required(o, 10);  // hitbox_offset
    builder.Required(o, 24);  // name
    builder.Required(o, 32);  // accolades
    builder.Required(o, 34);  // last_input
    builder.Required(o, 44);  // dodge_dir
    return new Offset<RLBot.Flat.PlayerInfo>(o);
  }
  public PlayerInfoT UnPack() {
    var _o = new PlayerInfoT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(PlayerInfoT _o) {
    _o.Physics = this.Physics.HasValue ? this.Physics.Value.UnPack() : null;
    _o.ScoreInfo = this.ScoreInfo.HasValue ? this.ScoreInfo.Value.UnPack() : null;
    _o.Hitbox = this.Hitbox.HasValue ? this.Hitbox.Value.UnPack() : null;
    _o.HitboxOffset = this.HitboxOffset.HasValue ? this.HitboxOffset.Value.UnPack() : null;
    _o.LatestTouch = this.LatestTouch.HasValue ? this.LatestTouch.Value.UnPack() : null;
    _o.AirState = this.AirState;
    _o.DodgeTimeout = this.DodgeTimeout;
    _o.DemolishedTimeout = this.DemolishedTimeout;
    _o.IsSupersonic = this.IsSupersonic;
    _o.IsBot = this.IsBot;
    _o.Name = this.Name;
    _o.Team = this.Team;
    _o.Boost = this.Boost;
    _o.PlayerId = this.PlayerId;
    _o.Accolades = new List<string>();
    for (var _j = 0; _j < this.AccoladesLength; ++_j) {_o.Accolades.Add(this.Accolades(_j));}
    _o.LastInput = this.LastInput.HasValue ? this.LastInput.Value.UnPack() : null;
    _o.HasJumped = this.HasJumped;
    _o.HasDoubleJumped = this.HasDoubleJumped;
    _o.HasDodged = this.HasDodged;
    _o.DodgeElapsed = this.DodgeElapsed;
    _o.DodgeDir = this.DodgeDir.HasValue ? this.DodgeDir.Value.UnPack() : null;
  }
  public static Offset<RLBot.Flat.PlayerInfo> Pack(FlatBufferBuilder builder, PlayerInfoT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.PlayerInfo>);
    var _hitbox = _o.Hitbox == null ? default(Offset<RLBot.Flat.BoxShape>) : RLBot.Flat.BoxShape.Pack(builder, _o.Hitbox);
    var _latest_touch = _o.LatestTouch == null ? default(Offset<RLBot.Flat.Touch>) : RLBot.Flat.Touch.Pack(builder, _o.LatestTouch);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _accolades = default(VectorOffset);
    if (_o.Accolades != null) {
      var __accolades = new StringOffset[_o.Accolades.Count];
      for (var _j = 0; _j < __accolades.Length; ++_j) { __accolades[_j] = builder.CreateString(_o.Accolades[_j]); }
      _accolades = CreateAccoladesVector(builder, __accolades);
    }
    return CreatePlayerInfo(
      builder,
      _o.Physics,
      _o.ScoreInfo,
      _hitbox,
      _o.HitboxOffset,
      _latest_touch,
      _o.AirState,
      _o.DodgeTimeout,
      _o.DemolishedTimeout,
      _o.IsSupersonic,
      _o.IsBot,
      _name,
      _o.Team,
      _o.Boost,
      _o.PlayerId,
      _accolades,
      _o.LastInput,
      _o.HasJumped,
      _o.HasDoubleJumped,
      _o.HasDodged,
      _o.DodgeElapsed,
      _o.DodgeDir);
  }
}

public class PlayerInfoT
{
  public RLBot.Flat.PhysicsT Physics { get; set; }
  public RLBot.Flat.ScoreInfoT ScoreInfo { get; set; }
  public RLBot.Flat.BoxShapeT Hitbox { get; set; }
  public RLBot.Flat.Vector3T HitboxOffset { get; set; }
  public RLBot.Flat.TouchT LatestTouch { get; set; }
  public RLBot.Flat.AirState AirState { get; set; }
  public float DodgeTimeout { get; set; }
  public float DemolishedTimeout { get; set; }
  public bool IsSupersonic { get; set; }
  public bool IsBot { get; set; }
  public string Name { get; set; }
  public uint Team { get; set; }
  public float Boost { get; set; }
  public int PlayerId { get; set; }
  public List<string> Accolades { get; set; }
  public RLBot.Flat.ControllerStateT LastInput { get; set; }
  public bool HasJumped { get; set; }
  public bool HasDoubleJumped { get; set; }
  public bool HasDodged { get; set; }
  public float DodgeElapsed { get; set; }
  public RLBot.Flat.Vector2T DodgeDir { get; set; }

  public PlayerInfoT() {
    this.Physics = new RLBot.Flat.PhysicsT();
    this.ScoreInfo = new RLBot.Flat.ScoreInfoT();
    this.Hitbox = null;
    this.HitboxOffset = new RLBot.Flat.Vector3T();
    this.LatestTouch = null;
    this.AirState = RLBot.Flat.AirState.OnGround;
    this.DodgeTimeout = 0.0f;
    this.DemolishedTimeout = 0.0f;
    this.IsSupersonic = false;
    this.IsBot = false;
    this.Name = null;
    this.Team = 0;
    this.Boost = 0.0f;
    this.PlayerId = 0;
    this.Accolades = null;
    this.LastInput = new RLBot.Flat.ControllerStateT();
    this.HasJumped = false;
    this.HasDoubleJumped = false;
    this.HasDodged = false;
    this.DodgeElapsed = 0.0f;
    this.DodgeDir = new RLBot.Flat.Vector2T();
  }
}


static public class PlayerInfoVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Physics*/, 48 /*RLBot.Flat.Physics*/, 4, true)
      && verifier.VerifyField(tablePos, 6 /*ScoreInfo*/, 28 /*RLBot.Flat.ScoreInfo*/, 4, true)
      && verifier.VerifyTable(tablePos, 8 /*Hitbox*/, RLBot.Flat.BoxShapeVerify.Verify, true)
      && verifier.VerifyField(tablePos, 10 /*HitboxOffset*/, 12 /*RLBot.Flat.Vector3*/, 4, true)
      && verifier.VerifyTable(tablePos, 12 /*LatestTouch*/, RLBot.Flat.TouchVerify.Verify, false)
      && verifier.VerifyField(tablePos, 14 /*AirState*/, 1 /*RLBot.Flat.AirState*/, 1, false)
      && verifier.VerifyField(tablePos, 16 /*DodgeTimeout*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 18 /*DemolishedTimeout*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 20 /*IsSupersonic*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 22 /*IsBot*/, 1 /*bool*/, 1, false)
      && verifier.VerifyString(tablePos, 24 /*Name*/, true)
      && verifier.VerifyField(tablePos, 26 /*Team*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 28 /*Boost*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 30 /*PlayerId*/, 4 /*int*/, 4, false)
      && verifier.VerifyVectorOfStrings(tablePos, 32 /*Accolades*/, true)
      && verifier.VerifyField(tablePos, 34 /*LastInput*/, 24 /*RLBot.Flat.ControllerState*/, 4, true)
      && verifier.VerifyField(tablePos, 36 /*HasJumped*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 38 /*HasDoubleJumped*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 40 /*HasDodged*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 42 /*DodgeElapsed*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 44 /*DodgeDir*/, 8 /*RLBot.Flat.Vector2*/, 4, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Information about a ball.
public struct BallInfo : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static BallInfo GetRootAsBallInfo(ByteBuffer _bb) { return GetRootAsBallInfo(_bb, new BallInfo()); }
  public static BallInfo GetRootAsBallInfo(ByteBuffer _bb, BallInfo obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BallInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The physical state of the ball.
  public RLBot.Flat.Physics? Physics { get { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.Physics?)(new RLBot.Flat.Physics()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public RLBot.Flat.CollisionShape ShapeType { get { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.CollisionShape)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.CollisionShape.NONE; } }
  /// The collision shape of the ball.
  public TTable? Shape<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(8); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public RLBot.Flat.BoxShape ShapeAsBoxShape() { return Shape<RLBot.Flat.BoxShape>().Value; }
  public RLBot.Flat.SphereShape ShapeAsSphereShape() { return Shape<RLBot.Flat.SphereShape>().Value; }
  public RLBot.Flat.CylinderShape ShapeAsCylinderShape() { return Shape<RLBot.Flat.CylinderShape>().Value; }

  public static Offset<RLBot.Flat.BallInfo> CreateBallInfo(FlatBufferBuilder builder,
      RLBot.Flat.PhysicsT physics = null,
      RLBot.Flat.CollisionShape shape_type = RLBot.Flat.CollisionShape.NONE,
      int shapeOffset = 0) {
    builder.StartTable(3);
    BallInfo.AddShape(builder, shapeOffset);
    BallInfo.AddPhysics(builder, RLBot.Flat.Physics.Pack(builder, physics));
    BallInfo.AddShapeType(builder, shape_type);
    return BallInfo.EndBallInfo(builder);
  }

  public static void StartBallInfo(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddPhysics(FlatBufferBuilder builder, Offset<RLBot.Flat.Physics> physicsOffset) { builder.AddStruct(0, physicsOffset.Value, 0); }
  public static void AddShapeType(FlatBufferBuilder builder, RLBot.Flat.CollisionShape shapeType) { builder.AddByte(1, (byte)shapeType, 0); }
  public static void AddShape(FlatBufferBuilder builder, int shapeOffset) { builder.AddOffset(2, shapeOffset, 0); }
  public static Offset<RLBot.Flat.BallInfo> EndBallInfo(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // physics
    builder.Required(o, 8);  // shape
    return new Offset<RLBot.Flat.BallInfo>(o);
  }
  public BallInfoT UnPack() {
    var _o = new BallInfoT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(BallInfoT _o) {
    _o.Physics = this.Physics.HasValue ? this.Physics.Value.UnPack() : null;
    _o.Shape = new RLBot.Flat.CollisionShapeUnion();
    _o.Shape.Type = this.ShapeType;
    switch (this.ShapeType) {
      default: break;
      case RLBot.Flat.CollisionShape.BoxShape:
        _o.Shape.Value = this.Shape<RLBot.Flat.BoxShape>().HasValue ? this.Shape<RLBot.Flat.BoxShape>().Value.UnPack() : null;
        break;
      case RLBot.Flat.CollisionShape.SphereShape:
        _o.Shape.Value = this.Shape<RLBot.Flat.SphereShape>().HasValue ? this.Shape<RLBot.Flat.SphereShape>().Value.UnPack() : null;
        break;
      case RLBot.Flat.CollisionShape.CylinderShape:
        _o.Shape.Value = this.Shape<RLBot.Flat.CylinderShape>().HasValue ? this.Shape<RLBot.Flat.CylinderShape>().Value.UnPack() : null;
        break;
    }
  }
  public static Offset<RLBot.Flat.BallInfo> Pack(FlatBufferBuilder builder, BallInfoT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.BallInfo>);
    var _shape_type = _o.Shape == null ? RLBot.Flat.CollisionShape.NONE : _o.Shape.Type;
    var _shape = _o.Shape == null ? 0 : RLBot.Flat.CollisionShapeUnion.Pack(builder, _o.Shape);
    return CreateBallInfo(
      builder,
      _o.Physics,
      _shape_type,
      _shape);
  }
}

public class BallInfoT
{
  public RLBot.Flat.PhysicsT Physics { get; set; }
  public RLBot.Flat.CollisionShapeUnion Shape { get; set; }

  public BallInfoT() {
    this.Physics = new RLBot.Flat.PhysicsT();
    this.Shape = null;
  }
}


static public class BallInfoVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Physics*/, 48 /*RLBot.Flat.Physics*/, 4, true)
      && verifier.VerifyField(tablePos, 6 /*ShapeType*/, 1 /*RLBot.Flat.CollisionShape*/, 1, false)
      && verifier.VerifyUnion(tablePos, 6, 8 /*Shape*/, RLBot.Flat.CollisionShapeVerify.Verify, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// The state of a boost pad.
/// Note, static properties of boost pads, such as their location and size, are found in the field info.
public struct BoostPadState : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public BoostPadState __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// True if the boost can be picked up right now.
  public bool IsActive { get { return 0!=__p.bb.Get(__p.bb_pos + 0); } }
  /// The number of seconds since the boost has been picked up, or 0 if the boost is active.
  /// A big boost pad becomes active again after 10 seconds.
  /// A small boost pad becomes active again after 4 seconds.
  public float Timer { get { return __p.bb.GetFloat(__p.bb_pos + 4); } }

  public static Offset<RLBot.Flat.BoostPadState> CreateBoostPadState(FlatBufferBuilder builder, bool IsActive, float Timer) {
    builder.Prep(4, 8);
    builder.PutFloat(Timer);
    builder.Pad(3);
    builder.PutBool(IsActive);
    return new Offset<RLBot.Flat.BoostPadState>(builder.Offset);
  }
  public BoostPadStateT UnPack() {
    var _o = new BoostPadStateT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(BoostPadStateT _o) {
    _o.IsActive = this.IsActive;
    _o.Timer = this.Timer;
  }
  public static Offset<RLBot.Flat.BoostPadState> Pack(FlatBufferBuilder builder, BoostPadStateT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.BoostPadState>);
    return CreateBoostPadState(
      builder,
      _o.IsActive,
      _o.Timer);
  }
}

public class BoostPadStateT
{
  public bool IsActive { get; set; }
  public float Timer { get; set; }

  public BoostPadStateT() {
    this.IsActive = false;
    this.Timer = 0.0f;
  }
}

/// Information about the current match such as time and gravity.
public struct MatchInfo : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static MatchInfo GetRootAsMatchInfo(ByteBuffer _bb) { return GetRootAsMatchInfo(_bb, new MatchInfo()); }
  public static MatchInfo GetRootAsMatchInfo(ByteBuffer _bb, MatchInfo obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public MatchInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// How many seconds have elapsed since the first game packet of the match.
  /// This value ticks up even during kickoffs, replays, pause, etc.
  public float SecondsElapsed { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// Seconds remaining of the match.
  /// This value ticks up instead of down during overtime or when the game duration mutator is set to Unlimited.
  /// I.e. it matches the in-game timer at the top.
  public float GameTimeRemaining { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// True if the game is in overtime.
  public bool IsOvertime { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// True if the game duration is set to Unlimited.
  public bool IsUnlimitedTime { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// The current phase of the match, i.e. kickoff, replay, active, etc.
  public RLBot.Flat.MatchPhase MatchPhase { get { int o = __p.__offset(12); return o != 0 ? (RLBot.Flat.MatchPhase)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.MatchPhase.Inactive; } }
  /// The current strength of gravity. Default is -650.
  public float WorldGravityZ { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// Game speed multiplier. Regular game speed is 1.0.
  public float GameSpeed { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// Index of the player who was most recently a spectated by the host.
  public uint LastSpectated { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  /// Tracks the number of physics frames the game has computed.
  /// May increase by more than one across consecutive packets.
  /// Data type will roll over after 414 days at 120Hz.
  public uint FrameNum { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }

  public static Offset<RLBot.Flat.MatchInfo> CreateMatchInfo(FlatBufferBuilder builder,
      float seconds_elapsed = 0.0f,
      float game_time_remaining = 0.0f,
      bool is_overtime = false,
      bool is_unlimited_time = false,
      RLBot.Flat.MatchPhase match_phase = RLBot.Flat.MatchPhase.Inactive,
      float world_gravity_z = 0.0f,
      float game_speed = 0.0f,
      uint last_spectated = 0,
      uint frame_num = 0) {
    builder.StartTable(9);
    MatchInfo.AddFrameNum(builder, frame_num);
    MatchInfo.AddLastSpectated(builder, last_spectated);
    MatchInfo.AddGameSpeed(builder, game_speed);
    MatchInfo.AddWorldGravityZ(builder, world_gravity_z);
    MatchInfo.AddGameTimeRemaining(builder, game_time_remaining);
    MatchInfo.AddSecondsElapsed(builder, seconds_elapsed);
    MatchInfo.AddMatchPhase(builder, match_phase);
    MatchInfo.AddIsUnlimitedTime(builder, is_unlimited_time);
    MatchInfo.AddIsOvertime(builder, is_overtime);
    return MatchInfo.EndMatchInfo(builder);
  }

  public static void StartMatchInfo(FlatBufferBuilder builder) { builder.StartTable(9); }
  public static void AddSecondsElapsed(FlatBufferBuilder builder, float secondsElapsed) { builder.AddFloat(0, secondsElapsed, 0.0f); }
  public static void AddGameTimeRemaining(FlatBufferBuilder builder, float gameTimeRemaining) { builder.AddFloat(1, gameTimeRemaining, 0.0f); }
  public static void AddIsOvertime(FlatBufferBuilder builder, bool isOvertime) { builder.AddBool(2, isOvertime, false); }
  public static void AddIsUnlimitedTime(FlatBufferBuilder builder, bool isUnlimitedTime) { builder.AddBool(3, isUnlimitedTime, false); }
  public static void AddMatchPhase(FlatBufferBuilder builder, RLBot.Flat.MatchPhase matchPhase) { builder.AddByte(4, (byte)matchPhase, 0); }
  public static void AddWorldGravityZ(FlatBufferBuilder builder, float worldGravityZ) { builder.AddFloat(5, worldGravityZ, 0.0f); }
  public static void AddGameSpeed(FlatBufferBuilder builder, float gameSpeed) { builder.AddFloat(6, gameSpeed, 0.0f); }
  public static void AddLastSpectated(FlatBufferBuilder builder, uint lastSpectated) { builder.AddUint(7, lastSpectated, 0); }
  public static void AddFrameNum(FlatBufferBuilder builder, uint frameNum) { builder.AddUint(8, frameNum, 0); }
  public static Offset<RLBot.Flat.MatchInfo> EndMatchInfo(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RLBot.Flat.MatchInfo>(o);
  }
  public MatchInfoT UnPack() {
    var _o = new MatchInfoT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(MatchInfoT _o) {
    _o.SecondsElapsed = this.SecondsElapsed;
    _o.GameTimeRemaining = this.GameTimeRemaining;
    _o.IsOvertime = this.IsOvertime;
    _o.IsUnlimitedTime = this.IsUnlimitedTime;
    _o.MatchPhase = this.MatchPhase;
    _o.WorldGravityZ = this.WorldGravityZ;
    _o.GameSpeed = this.GameSpeed;
    _o.LastSpectated = this.LastSpectated;
    _o.FrameNum = this.FrameNum;
  }
  public static Offset<RLBot.Flat.MatchInfo> Pack(FlatBufferBuilder builder, MatchInfoT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.MatchInfo>);
    return CreateMatchInfo(
      builder,
      _o.SecondsElapsed,
      _o.GameTimeRemaining,
      _o.IsOvertime,
      _o.IsUnlimitedTime,
      _o.MatchPhase,
      _o.WorldGravityZ,
      _o.GameSpeed,
      _o.LastSpectated,
      _o.FrameNum);
  }
}

public class MatchInfoT
{
  public float SecondsElapsed { get; set; }
  public float GameTimeRemaining { get; set; }
  public bool IsOvertime { get; set; }
  public bool IsUnlimitedTime { get; set; }
  public RLBot.Flat.MatchPhase MatchPhase { get; set; }
  public float WorldGravityZ { get; set; }
  public float GameSpeed { get; set; }
  public uint LastSpectated { get; set; }
  public uint FrameNum { get; set; }

  public MatchInfoT() {
    this.SecondsElapsed = 0.0f;
    this.GameTimeRemaining = 0.0f;
    this.IsOvertime = false;
    this.IsUnlimitedTime = false;
    this.MatchPhase = RLBot.Flat.MatchPhase.Inactive;
    this.WorldGravityZ = 0.0f;
    this.GameSpeed = 0.0f;
    this.LastSpectated = 0;
    this.FrameNum = 0;
  }
}


static public class MatchInfoVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*SecondsElapsed*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*GameTimeRemaining*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*IsOvertime*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*IsUnlimitedTime*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 12 /*MatchPhase*/, 1 /*RLBot.Flat.MatchPhase*/, 1, false)
      && verifier.VerifyField(tablePos, 14 /*WorldGravityZ*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 16 /*GameSpeed*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 18 /*LastSpectated*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 20 /*FrameNum*/, 4 /*uint*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Information about teams. Currently only the number of goals scored.
public struct TeamInfo : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public TeamInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The index of the team. Blue is 0, orange is 1.
  public uint TeamIndex { get { return __p.bb.GetUint(__p.bb_pos + 0); } }
  /// Number of goals scored.
  /// Note, this value may be different than the sum of the goals scored by the current players on the team as player may join/leave the game or switch teams.
  /// This value is what is shown on the heads-up display.
  public uint Score { get { return __p.bb.GetUint(__p.bb_pos + 4); } }

  public static Offset<RLBot.Flat.TeamInfo> CreateTeamInfo(FlatBufferBuilder builder, uint TeamIndex, uint Score) {
    builder.Prep(4, 8);
    builder.PutUint(Score);
    builder.PutUint(TeamIndex);
    return new Offset<RLBot.Flat.TeamInfo>(builder.Offset);
  }
  public TeamInfoT UnPack() {
    var _o = new TeamInfoT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(TeamInfoT _o) {
    _o.TeamIndex = this.TeamIndex;
    _o.Score = this.Score;
  }
  public static Offset<RLBot.Flat.TeamInfo> Pack(FlatBufferBuilder builder, TeamInfoT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.TeamInfo>);
    return CreateTeamInfo(
      builder,
      _o.TeamIndex,
      _o.Score);
  }
}

public class TeamInfoT
{
  public uint TeamIndex { get; set; }
  public uint Score { get; set; }

  public TeamInfoT() {
    this.TeamIndex = 0;
    this.Score = 0;
  }
}

/// A packet of data from the game.
/// Is is sent every tick to bots, scripts, etc.
/// Static data is found in the FieldInfo.
public struct GamePacket : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static GamePacket GetRootAsGamePacket(ByteBuffer _bb) { return GetRootAsGamePacket(_bb, new GamePacket()); }
  public static GamePacket GetRootAsGamePacket(ByteBuffer _bb, GamePacket obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public GamePacket __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The current state of all players and their cars.
  public RLBot.Flat.PlayerInfo? Players(int j) { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.PlayerInfo?)(new RLBot.Flat.PlayerInfo()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int PlayersLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The current state of all boost pads.
  /// The static information about boost pads are found in the FieldInfo.
  /// The boost pads are ordered by y-coordinate and then x-coordinate.
  public RLBot.Flat.BoostPadState? BoostPads(int j) { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.BoostPadState?)(new RLBot.Flat.BoostPadState()).__assign(__p.__vector(o) + j * 8, __p.bb) : null; }
  public int BoostPadsLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The current state of all balls.
  public RLBot.Flat.BallInfo? Balls(int j) { int o = __p.__offset(8); return o != 0 ? (RLBot.Flat.BallInfo?)(new RLBot.Flat.BallInfo()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int BallsLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The current state of the match such as timers and gravity.
  public RLBot.Flat.MatchInfo? MatchInfo { get { int o = __p.__offset(10); return o != 0 ? (RLBot.Flat.MatchInfo?)(new RLBot.Flat.MatchInfo()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// The current state of teams, i.e. the team scores.
  public RLBot.Flat.TeamInfo? Teams(int j) { int o = __p.__offset(12); return o != 0 ? (RLBot.Flat.TeamInfo?)(new RLBot.Flat.TeamInfo()).__assign(__p.__vector(o) + j * 8, __p.bb) : null; }
  public int TeamsLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<RLBot.Flat.GamePacket> CreateGamePacket(FlatBufferBuilder builder,
      VectorOffset playersOffset = default(VectorOffset),
      VectorOffset boost_padsOffset = default(VectorOffset),
      VectorOffset ballsOffset = default(VectorOffset),
      Offset<RLBot.Flat.MatchInfo> match_infoOffset = default(Offset<RLBot.Flat.MatchInfo>),
      VectorOffset teamsOffset = default(VectorOffset)) {
    builder.StartTable(5);
    GamePacket.AddTeams(builder, teamsOffset);
    GamePacket.AddMatchInfo(builder, match_infoOffset);
    GamePacket.AddBalls(builder, ballsOffset);
    GamePacket.AddBoostPads(builder, boost_padsOffset);
    GamePacket.AddPlayers(builder, playersOffset);
    return GamePacket.EndGamePacket(builder);
  }

  public static void StartGamePacket(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddPlayers(FlatBufferBuilder builder, VectorOffset playersOffset) { builder.AddOffset(0, playersOffset.Value, 0); }
  public static VectorOffset CreatePlayersVector(FlatBufferBuilder builder, Offset<RLBot.Flat.PlayerInfo>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreatePlayersVectorBlock(FlatBufferBuilder builder, Offset<RLBot.Flat.PlayerInfo>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePlayersVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<RLBot.Flat.PlayerInfo>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePlayersVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<RLBot.Flat.PlayerInfo>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPlayersVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddBoostPads(FlatBufferBuilder builder, VectorOffset boostPadsOffset) { builder.AddOffset(1, boostPadsOffset.Value, 0); }
  public static void StartBoostPadsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 4); }
  public static void AddBalls(FlatBufferBuilder builder, VectorOffset ballsOffset) { builder.AddOffset(2, ballsOffset.Value, 0); }
  public static VectorOffset CreateBallsVector(FlatBufferBuilder builder, Offset<RLBot.Flat.BallInfo>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateBallsVectorBlock(FlatBufferBuilder builder, Offset<RLBot.Flat.BallInfo>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBallsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<RLBot.Flat.BallInfo>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBallsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<RLBot.Flat.BallInfo>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartBallsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddMatchInfo(FlatBufferBuilder builder, Offset<RLBot.Flat.MatchInfo> matchInfoOffset) { builder.AddOffset(3, matchInfoOffset.Value, 0); }
  public static void AddTeams(FlatBufferBuilder builder, VectorOffset teamsOffset) { builder.AddOffset(4, teamsOffset.Value, 0); }
  public static void StartTeamsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 4); }
  public static Offset<RLBot.Flat.GamePacket> EndGamePacket(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // players
    builder.Required(o, 6);  // boost_pads
    builder.Required(o, 8);  // balls
    builder.Required(o, 10);  // match_info
    builder.Required(o, 12);  // teams
    return new Offset<RLBot.Flat.GamePacket>(o);
  }
  public GamePacketT UnPack() {
    var _o = new GamePacketT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(GamePacketT _o) {
    _o.Players = new List<RLBot.Flat.PlayerInfoT>();
    for (var _j = 0; _j < this.PlayersLength; ++_j) {_o.Players.Add(this.Players(_j).HasValue ? this.Players(_j).Value.UnPack() : null);}
    _o.BoostPads = new List<RLBot.Flat.BoostPadStateT>();
    for (var _j = 0; _j < this.BoostPadsLength; ++_j) {_o.BoostPads.Add(this.BoostPads(_j).HasValue ? this.BoostPads(_j).Value.UnPack() : null);}
    _o.Balls = new List<RLBot.Flat.BallInfoT>();
    for (var _j = 0; _j < this.BallsLength; ++_j) {_o.Balls.Add(this.Balls(_j).HasValue ? this.Balls(_j).Value.UnPack() : null);}
    _o.MatchInfo = this.MatchInfo.HasValue ? this.MatchInfo.Value.UnPack() : null;
    _o.Teams = new List<RLBot.Flat.TeamInfoT>();
    for (var _j = 0; _j < this.TeamsLength; ++_j) {_o.Teams.Add(this.Teams(_j).HasValue ? this.Teams(_j).Value.UnPack() : null);}
  }
  public static Offset<RLBot.Flat.GamePacket> Pack(FlatBufferBuilder builder, GamePacketT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.GamePacket>);
    var _players = default(VectorOffset);
    if (_o.Players != null) {
      var __players = new Offset<RLBot.Flat.PlayerInfo>[_o.Players.Count];
      for (var _j = 0; _j < __players.Length; ++_j) { __players[_j] = RLBot.Flat.PlayerInfo.Pack(builder, _o.Players[_j]); }
      _players = CreatePlayersVector(builder, __players);
    }
    var _boost_pads = default(VectorOffset);
    if (_o.BoostPads != null) {
      StartBoostPadsVector(builder, _o.BoostPads.Count);
      for (var _j = _o.BoostPads.Count - 1; _j >= 0; --_j) { RLBot.Flat.BoostPadState.Pack(builder, _o.BoostPads[_j]); }
      _boost_pads = builder.EndVector();
    }
    var _balls = default(VectorOffset);
    if (_o.Balls != null) {
      var __balls = new Offset<RLBot.Flat.BallInfo>[_o.Balls.Count];
      for (var _j = 0; _j < __balls.Length; ++_j) { __balls[_j] = RLBot.Flat.BallInfo.Pack(builder, _o.Balls[_j]); }
      _balls = CreateBallsVector(builder, __balls);
    }
    var _match_info = _o.MatchInfo == null ? default(Offset<RLBot.Flat.MatchInfo>) : RLBot.Flat.MatchInfo.Pack(builder, _o.MatchInfo);
    var _teams = default(VectorOffset);
    if (_o.Teams != null) {
      StartTeamsVector(builder, _o.Teams.Count);
      for (var _j = _o.Teams.Count - 1; _j >= 0; --_j) { RLBot.Flat.TeamInfo.Pack(builder, _o.Teams[_j]); }
      _teams = builder.EndVector();
    }
    return CreateGamePacket(
      builder,
      _players,
      _boost_pads,
      _balls,
      _match_info,
      _teams);
  }
}

public class GamePacketT
{
  public List<RLBot.Flat.PlayerInfoT> Players { get; set; }
  public List<RLBot.Flat.BoostPadStateT> BoostPads { get; set; }
  public List<RLBot.Flat.BallInfoT> Balls { get; set; }
  public RLBot.Flat.MatchInfoT MatchInfo { get; set; }
  public List<RLBot.Flat.TeamInfoT> Teams { get; set; }

  public GamePacketT() {
    this.Players = null;
    this.BoostPads = null;
    this.Balls = null;
    this.MatchInfo = null;
    this.Teams = null;
  }
}


static public class GamePacketVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfTables(tablePos, 4 /*Players*/, RLBot.Flat.PlayerInfoVerify.Verify, true)
      && verifier.VerifyVectorOfData(tablePos, 6 /*BoostPads*/, 8 /*RLBot.Flat.BoostPadState*/, true)
      && verifier.VerifyVectorOfTables(tablePos, 8 /*Balls*/, RLBot.Flat.BallInfoVerify.Verify, true)
      && verifier.VerifyTable(tablePos, 10 /*MatchInfo*/, RLBot.Flat.MatchInfoVerify.Verify, true)
      && verifier.VerifyVectorOfData(tablePos, 12 /*Teams*/, 8 /*RLBot.Flat.TeamInfo*/, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Static information about a goal on the field such as dimensions and location.
/// More values can be found on https://wiki.rlbot.org/botmaking/useful-game-values/
public struct GoalInfo : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static GoalInfo GetRootAsGoalInfo(ByteBuffer _bb) { return GetRootAsGoalInfo(_bb, new GoalInfo()); }
  public static GoalInfo GetRootAsGoalInfo(ByteBuffer _bb, GoalInfo obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public GoalInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The index of the team that this goal belongs to.
  public int TeamNum { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// The center location of the goal.
  public RLBot.Flat.Vector3? Location { get { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.Vector3?)(new RLBot.Flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// The unit direction point away from the opening of the goal.
  public RLBot.Flat.Vector3? Direction { get { int o = __p.__offset(8); return o != 0 ? (RLBot.Flat.Vector3?)(new RLBot.Flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// The width of the goal. 1785 uu wide on a standard field.
  public float Width { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// The height of the goal. 643 uu tall on a standard field.
  public float Height { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<RLBot.Flat.GoalInfo> CreateGoalInfo(FlatBufferBuilder builder,
      int team_num = 0,
      RLBot.Flat.Vector3T location = null,
      RLBot.Flat.Vector3T direction = null,
      float width = 0.0f,
      float height = 0.0f) {
    builder.StartTable(5);
    GoalInfo.AddHeight(builder, height);
    GoalInfo.AddWidth(builder, width);
    GoalInfo.AddDirection(builder, RLBot.Flat.Vector3.Pack(builder, direction));
    GoalInfo.AddLocation(builder, RLBot.Flat.Vector3.Pack(builder, location));
    GoalInfo.AddTeamNum(builder, team_num);
    return GoalInfo.EndGoalInfo(builder);
  }

  public static void StartGoalInfo(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddTeamNum(FlatBufferBuilder builder, int teamNum) { builder.AddInt(0, teamNum, 0); }
  public static void AddLocation(FlatBufferBuilder builder, Offset<RLBot.Flat.Vector3> locationOffset) { builder.AddStruct(1, locationOffset.Value, 0); }
  public static void AddDirection(FlatBufferBuilder builder, Offset<RLBot.Flat.Vector3> directionOffset) { builder.AddStruct(2, directionOffset.Value, 0); }
  public static void AddWidth(FlatBufferBuilder builder, float width) { builder.AddFloat(3, width, 0.0f); }
  public static void AddHeight(FlatBufferBuilder builder, float height) { builder.AddFloat(4, height, 0.0f); }
  public static Offset<RLBot.Flat.GoalInfo> EndGoalInfo(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 6);  // location
    builder.Required(o, 8);  // direction
    return new Offset<RLBot.Flat.GoalInfo>(o);
  }
  public GoalInfoT UnPack() {
    var _o = new GoalInfoT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(GoalInfoT _o) {
    _o.TeamNum = this.TeamNum;
    _o.Location = this.Location.HasValue ? this.Location.Value.UnPack() : null;
    _o.Direction = this.Direction.HasValue ? this.Direction.Value.UnPack() : null;
    _o.Width = this.Width;
    _o.Height = this.Height;
  }
  public static Offset<RLBot.Flat.GoalInfo> Pack(FlatBufferBuilder builder, GoalInfoT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.GoalInfo>);
    return CreateGoalInfo(
      builder,
      _o.TeamNum,
      _o.Location,
      _o.Direction,
      _o.Width,
      _o.Height);
  }
}

public class GoalInfoT
{
  public int TeamNum { get; set; }
  public RLBot.Flat.Vector3T Location { get; set; }
  public RLBot.Flat.Vector3T Direction { get; set; }
  public float Width { get; set; }
  public float Height { get; set; }

  public GoalInfoT() {
    this.TeamNum = 0;
    this.Location = new RLBot.Flat.Vector3T();
    this.Direction = new RLBot.Flat.Vector3T();
    this.Width = 0.0f;
    this.Height = 0.0f;
  }
}


static public class GoalInfoVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*TeamNum*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Location*/, 12 /*RLBot.Flat.Vector3*/, 4, true)
      && verifier.VerifyField(tablePos, 8 /*Direction*/, 12 /*RLBot.Flat.Vector3*/, 4, true)
      && verifier.VerifyField(tablePos, 10 /*Width*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 12 /*Height*/, 4 /*float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Static information about a boost pad such as location and size.
public struct BoostPad : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static BoostPad GetRootAsBoostPad(ByteBuffer _bb) { return GetRootAsBoostPad(_bb, new BoostPad()); }
  public static BoostPad GetRootAsBoostPad(ByteBuffer _bb, BoostPad obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BoostPad __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The location of the boost pad.
  public RLBot.Flat.Vector3? Location { get { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.Vector3?)(new RLBot.Flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// Whether the boost pad provides a full tank of boost.
  /// A big boost pad provides 100 boost and respawns in 10 seconds.
  /// A small boost pad provides 12 boost and respawns in 4 seconds.
  public bool IsFullBoost { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<RLBot.Flat.BoostPad> CreateBoostPad(FlatBufferBuilder builder,
      RLBot.Flat.Vector3T location = null,
      bool is_full_boost = false) {
    builder.StartTable(2);
    BoostPad.AddLocation(builder, RLBot.Flat.Vector3.Pack(builder, location));
    BoostPad.AddIsFullBoost(builder, is_full_boost);
    return BoostPad.EndBoostPad(builder);
  }

  public static void StartBoostPad(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddLocation(FlatBufferBuilder builder, Offset<RLBot.Flat.Vector3> locationOffset) { builder.AddStruct(0, locationOffset.Value, 0); }
  public static void AddIsFullBoost(FlatBufferBuilder builder, bool isFullBoost) { builder.AddBool(1, isFullBoost, false); }
  public static Offset<RLBot.Flat.BoostPad> EndBoostPad(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // location
    return new Offset<RLBot.Flat.BoostPad>(o);
  }
  public BoostPadT UnPack() {
    var _o = new BoostPadT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(BoostPadT _o) {
    _o.Location = this.Location.HasValue ? this.Location.Value.UnPack() : null;
    _o.IsFullBoost = this.IsFullBoost;
  }
  public static Offset<RLBot.Flat.BoostPad> Pack(FlatBufferBuilder builder, BoostPadT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.BoostPad>);
    return CreateBoostPad(
      builder,
      _o.Location,
      _o.IsFullBoost);
  }
}

public class BoostPadT
{
  public RLBot.Flat.Vector3T Location { get; set; }
  public bool IsFullBoost { get; set; }

  public BoostPadT() {
    this.Location = new RLBot.Flat.Vector3T();
    this.IsFullBoost = false;
  }
}


static public class BoostPadVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Location*/, 12 /*RLBot.Flat.Vector3*/, 4, true)
      && verifier.VerifyField(tablePos, 6 /*IsFullBoost*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Static information about the field.
/// Sent to bots, scripts, etc. upon connecting.
/// Dynamic information is found in the GamePacket.
public struct FieldInfo : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static FieldInfo GetRootAsFieldInfo(ByteBuffer _bb) { return GetRootAsFieldInfo(_bb, new FieldInfo()); }
  public static FieldInfo GetRootAsFieldInfo(ByteBuffer _bb, FieldInfo obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public FieldInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Static information about boost pads on the field.
  /// The dynamic information is found in the GamePacket
  /// The boost pads are ordered by y-coordinate and then x-coordinate.
  public RLBot.Flat.BoostPad? BoostPads(int j) { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.BoostPad?)(new RLBot.Flat.BoostPad()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int BoostPadsLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Information about the goals on the field.
  public RLBot.Flat.GoalInfo? Goals(int j) { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.GoalInfo?)(new RLBot.Flat.GoalInfo()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int GoalsLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<RLBot.Flat.FieldInfo> CreateFieldInfo(FlatBufferBuilder builder,
      VectorOffset boost_padsOffset = default(VectorOffset),
      VectorOffset goalsOffset = default(VectorOffset)) {
    builder.StartTable(2);
    FieldInfo.AddGoals(builder, goalsOffset);
    FieldInfo.AddBoostPads(builder, boost_padsOffset);
    return FieldInfo.EndFieldInfo(builder);
  }

  public static void StartFieldInfo(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddBoostPads(FlatBufferBuilder builder, VectorOffset boostPadsOffset) { builder.AddOffset(0, boostPadsOffset.Value, 0); }
  public static VectorOffset CreateBoostPadsVector(FlatBufferBuilder builder, Offset<RLBot.Flat.BoostPad>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateBoostPadsVectorBlock(FlatBufferBuilder builder, Offset<RLBot.Flat.BoostPad>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBoostPadsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<RLBot.Flat.BoostPad>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBoostPadsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<RLBot.Flat.BoostPad>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartBoostPadsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddGoals(FlatBufferBuilder builder, VectorOffset goalsOffset) { builder.AddOffset(1, goalsOffset.Value, 0); }
  public static VectorOffset CreateGoalsVector(FlatBufferBuilder builder, Offset<RLBot.Flat.GoalInfo>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateGoalsVectorBlock(FlatBufferBuilder builder, Offset<RLBot.Flat.GoalInfo>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateGoalsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<RLBot.Flat.GoalInfo>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateGoalsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<RLBot.Flat.GoalInfo>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartGoalsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<RLBot.Flat.FieldInfo> EndFieldInfo(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // boost_pads
    builder.Required(o, 6);  // goals
    return new Offset<RLBot.Flat.FieldInfo>(o);
  }
  public FieldInfoT UnPack() {
    var _o = new FieldInfoT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(FieldInfoT _o) {
    _o.BoostPads = new List<RLBot.Flat.BoostPadT>();
    for (var _j = 0; _j < this.BoostPadsLength; ++_j) {_o.BoostPads.Add(this.BoostPads(_j).HasValue ? this.BoostPads(_j).Value.UnPack() : null);}
    _o.Goals = new List<RLBot.Flat.GoalInfoT>();
    for (var _j = 0; _j < this.GoalsLength; ++_j) {_o.Goals.Add(this.Goals(_j).HasValue ? this.Goals(_j).Value.UnPack() : null);}
  }
  public static Offset<RLBot.Flat.FieldInfo> Pack(FlatBufferBuilder builder, FieldInfoT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.FieldInfo>);
    var _boost_pads = default(VectorOffset);
    if (_o.BoostPads != null) {
      var __boost_pads = new Offset<RLBot.Flat.BoostPad>[_o.BoostPads.Count];
      for (var _j = 0; _j < __boost_pads.Length; ++_j) { __boost_pads[_j] = RLBot.Flat.BoostPad.Pack(builder, _o.BoostPads[_j]); }
      _boost_pads = CreateBoostPadsVector(builder, __boost_pads);
    }
    var _goals = default(VectorOffset);
    if (_o.Goals != null) {
      var __goals = new Offset<RLBot.Flat.GoalInfo>[_o.Goals.Count];
      for (var _j = 0; _j < __goals.Length; ++_j) { __goals[_j] = RLBot.Flat.GoalInfo.Pack(builder, _o.Goals[_j]); }
      _goals = CreateGoalsVector(builder, __goals);
    }
    return CreateFieldInfo(
      builder,
      _boost_pads,
      _goals);
  }
}

public class FieldInfoT
{
  public List<RLBot.Flat.BoostPadT> BoostPads { get; set; }
  public List<RLBot.Flat.GoalInfoT> Goals { get; set; }

  public FieldInfoT() {
    this.BoostPads = null;
    this.Goals = null;
  }
}


static public class FieldInfoVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfTables(tablePos, 4 /*BoostPads*/, RLBot.Flat.BoostPadVerify.Verify, true)
      && verifier.VerifyVectorOfTables(tablePos, 6 /*Goals*/, RLBot.Flat.GoalInfoVerify.Verify, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// An entry in the ball prediction describing where a ball will be at some future time.
public struct PredictionSlice : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public PredictionSlice __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The moment in game time that this prediction corresponds to.
  /// This corresponds to 'seconds_elapsed' in the MatchInfo.
  public float GameSeconds { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }
  /// The predicted location and motion of the object.
  public RLBot.Flat.Physics Physics { get { return (new RLBot.Flat.Physics()).__assign(__p.bb_pos + 4, __p.bb); } }

  public static Offset<RLBot.Flat.PredictionSlice> CreatePredictionSlice(FlatBufferBuilder builder, float GameSeconds, float physics_location_X, float physics_location_Y, float physics_location_Z, float physics_rotation_Pitch, float physics_rotation_Yaw, float physics_rotation_Roll, float physics_velocity_X, float physics_velocity_Y, float physics_velocity_Z, float physics_angular_velocity_X, float physics_angular_velocity_Y, float physics_angular_velocity_Z) {
    builder.Prep(4, 52);
    builder.Prep(4, 48);
    builder.Prep(4, 12);
    builder.PutFloat(physics_angular_velocity_Z);
    builder.PutFloat(physics_angular_velocity_Y);
    builder.PutFloat(physics_angular_velocity_X);
    builder.Prep(4, 12);
    builder.PutFloat(physics_velocity_Z);
    builder.PutFloat(physics_velocity_Y);
    builder.PutFloat(physics_velocity_X);
    builder.Prep(4, 12);
    builder.PutFloat(physics_rotation_Roll);
    builder.PutFloat(physics_rotation_Yaw);
    builder.PutFloat(physics_rotation_Pitch);
    builder.Prep(4, 12);
    builder.PutFloat(physics_location_Z);
    builder.PutFloat(physics_location_Y);
    builder.PutFloat(physics_location_X);
    builder.PutFloat(GameSeconds);
    return new Offset<RLBot.Flat.PredictionSlice>(builder.Offset);
  }
  public PredictionSliceT UnPack() {
    var _o = new PredictionSliceT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(PredictionSliceT _o) {
    _o.GameSeconds = this.GameSeconds;
    _o.Physics = this.Physics.UnPack();
  }
  public static Offset<RLBot.Flat.PredictionSlice> Pack(FlatBufferBuilder builder, PredictionSliceT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.PredictionSlice>);
    var _physics_location_x = _o.Physics.Location.X;
    var _physics_location_y = _o.Physics.Location.Y;
    var _physics_location_z = _o.Physics.Location.Z;
    var _physics_rotation_pitch = _o.Physics.Rotation.Pitch;
    var _physics_rotation_yaw = _o.Physics.Rotation.Yaw;
    var _physics_rotation_roll = _o.Physics.Rotation.Roll;
    var _physics_velocity_x = _o.Physics.Velocity.X;
    var _physics_velocity_y = _o.Physics.Velocity.Y;
    var _physics_velocity_z = _o.Physics.Velocity.Z;
    var _physics_angular_velocity_x = _o.Physics.AngularVelocity.X;
    var _physics_angular_velocity_y = _o.Physics.AngularVelocity.Y;
    var _physics_angular_velocity_z = _o.Physics.AngularVelocity.Z;
    return CreatePredictionSlice(
      builder,
      _o.GameSeconds,
      _physics_location_x,
      _physics_location_y,
      _physics_location_z,
      _physics_rotation_pitch,
      _physics_rotation_yaw,
      _physics_rotation_roll,
      _physics_velocity_x,
      _physics_velocity_y,
      _physics_velocity_z,
      _physics_angular_velocity_x,
      _physics_angular_velocity_y,
      _physics_angular_velocity_z);
  }
}

public class PredictionSliceT
{
  public float GameSeconds { get; set; }
  public RLBot.Flat.PhysicsT Physics { get; set; }

  public PredictionSliceT() {
    this.GameSeconds = 0.0f;
    this.Physics = new RLBot.Flat.PhysicsT();
  }
}

/// A prediction of a ball's trajectory, assuming no collision with cars.
public struct BallPrediction : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static BallPrediction GetRootAsBallPrediction(ByteBuffer _bb) { return GetRootAsBallPrediction(_bb, new BallPrediction()); }
  public static BallPrediction GetRootAsBallPrediction(ByteBuffer _bb, BallPrediction obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BallPrediction __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// A list of predicted states of the ball at specific times in the future, assuming no collision with cars.
  /// The beginning of the list is now, and the end is 6 seconds into the future.
  /// The prediction is made at 120 Hz, resulting in 720 entries.
  public RLBot.Flat.PredictionSlice? Slices(int j) { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.PredictionSlice?)(new RLBot.Flat.PredictionSlice()).__assign(__p.__vector(o) + j * 52, __p.bb) : null; }
  public int SlicesLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<RLBot.Flat.BallPrediction> CreateBallPrediction(FlatBufferBuilder builder,
      VectorOffset slicesOffset = default(VectorOffset)) {
    builder.StartTable(1);
    BallPrediction.AddSlices(builder, slicesOffset);
    return BallPrediction.EndBallPrediction(builder);
  }

  public static void StartBallPrediction(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddSlices(FlatBufferBuilder builder, VectorOffset slicesOffset) { builder.AddOffset(0, slicesOffset.Value, 0); }
  public static void StartSlicesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(52, numElems, 4); }
  public static Offset<RLBot.Flat.BallPrediction> EndBallPrediction(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // slices
    return new Offset<RLBot.Flat.BallPrediction>(o);
  }
  public BallPredictionT UnPack() {
    var _o = new BallPredictionT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(BallPredictionT _o) {
    _o.Slices = new List<RLBot.Flat.PredictionSliceT>();
    for (var _j = 0; _j < this.SlicesLength; ++_j) {_o.Slices.Add(this.Slices(_j).HasValue ? this.Slices(_j).Value.UnPack() : null);}
  }
  public static Offset<RLBot.Flat.BallPrediction> Pack(FlatBufferBuilder builder, BallPredictionT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.BallPrediction>);
    var _slices = default(VectorOffset);
    if (_o.Slices != null) {
      StartSlicesVector(builder, _o.Slices.Count);
      for (var _j = _o.Slices.Count - 1; _j >= 0; --_j) { RLBot.Flat.PredictionSlice.Pack(builder, _o.Slices[_j]); }
      _slices = builder.EndVector();
    }
    return CreateBallPrediction(
      builder,
      _slices);
  }
}

public class BallPredictionT
{
  public List<RLBot.Flat.PredictionSliceT> Slices { get; set; }

  public BallPredictionT() {
    this.Slices = null;
  }
}


static public class BallPredictionVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*Slices*/, 52 /*RLBot.Flat.PredictionSlice*/, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A floating point value located in a separate struct allowing for optional floats elsewhere.
public struct Float : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public Float __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float Val { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }

  public static Offset<RLBot.Flat.Float> CreateFloat(FlatBufferBuilder builder, float Val) {
    builder.Prep(4, 4);
    builder.PutFloat(Val);
    return new Offset<RLBot.Flat.Float>(builder.Offset);
  }
  public FloatT UnPack() {
    var _o = new FloatT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(FloatT _o) {
    _o.Val = this.Val;
  }
  public static Offset<RLBot.Flat.Float> Pack(FlatBufferBuilder builder, FloatT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.Float>);
    return CreateFloat(
      builder,
      _o.Val);
  }
}

public class FloatT
{
  public float Val { get; set; }

  public FloatT() {
    this.Val = 0.0f;
  }
}

/// A boolean value located in a separate struct allowing for optional floats elsewhere.
public struct Bool : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public Bool __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool Val { get { return 0!=__p.bb.Get(__p.bb_pos + 0); } }

  public static Offset<RLBot.Flat.Bool> CreateBool(FlatBufferBuilder builder, bool Val) {
    builder.Prep(1, 1);
    builder.PutBool(Val);
    return new Offset<RLBot.Flat.Bool>(builder.Offset);
  }
  public BoolT UnPack() {
    var _o = new BoolT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(BoolT _o) {
    _o.Val = this.Val;
  }
  public static Offset<RLBot.Flat.Bool> Pack(FlatBufferBuilder builder, BoolT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.Bool>);
    return CreateBool(
      builder,
      _o.Val);
  }
}

public class BoolT
{
  public bool Val { get; set; }

  public BoolT() {
    this.Val = false;
  }
}

/// A 3D vector where x, y, and z can be null.
/// Used for game state setting to define which part of a vector should change.
/// If a component is null, then the component will keep its current value.
public struct Vector3Partial : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static Vector3Partial GetRootAsVector3Partial(ByteBuffer _bb) { return GetRootAsVector3Partial(_bb, new Vector3Partial()); }
  public static Vector3Partial GetRootAsVector3Partial(ByteBuffer _bb, Vector3Partial obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Vector3Partial __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public RLBot.Flat.Float? X { get { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.Float?)(new RLBot.Flat.Float()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public RLBot.Flat.Float? Y { get { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.Float?)(new RLBot.Flat.Float()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public RLBot.Flat.Float? Z { get { int o = __p.__offset(8); return o != 0 ? (RLBot.Flat.Float?)(new RLBot.Flat.Float()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static void StartVector3Partial(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddX(FlatBufferBuilder builder, Offset<RLBot.Flat.Float> xOffset) { builder.AddStruct(0, xOffset.Value, 0); }
  public static void AddY(FlatBufferBuilder builder, Offset<RLBot.Flat.Float> yOffset) { builder.AddStruct(1, yOffset.Value, 0); }
  public static void AddZ(FlatBufferBuilder builder, Offset<RLBot.Flat.Float> zOffset) { builder.AddStruct(2, zOffset.Value, 0); }
  public static Offset<RLBot.Flat.Vector3Partial> EndVector3Partial(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RLBot.Flat.Vector3Partial>(o);
  }
  public Vector3PartialT UnPack() {
    var _o = new Vector3PartialT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(Vector3PartialT _o) {
    _o.X = this.X.HasValue ? this.X.Value.UnPack() : null;
    _o.Y = this.Y.HasValue ? this.Y.Value.UnPack() : null;
    _o.Z = this.Z.HasValue ? this.Z.Value.UnPack() : null;
  }
  public static Offset<RLBot.Flat.Vector3Partial> Pack(FlatBufferBuilder builder, Vector3PartialT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.Vector3Partial>);
    StartVector3Partial(builder);
    AddX(builder, RLBot.Flat.Float.Pack(builder, _o.X));
    AddY(builder, RLBot.Flat.Float.Pack(builder, _o.Y));
    AddZ(builder, RLBot.Flat.Float.Pack(builder, _o.Z));
    return EndVector3Partial(builder);
  }
}

public class Vector3PartialT
{
  public RLBot.Flat.FloatT X { get; set; }
  public RLBot.Flat.FloatT Y { get; set; }
  public RLBot.Flat.FloatT Z { get; set; }

  public Vector3PartialT() {
    this.X = new RLBot.Flat.FloatT();
    this.Y = new RLBot.Flat.FloatT();
    this.Z = new RLBot.Flat.FloatT();
  }
}


static public class Vector3PartialVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*X*/, 4 /*RLBot.Flat.Float*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Y*/, 4 /*RLBot.Flat.Float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Z*/, 4 /*RLBot.Flat.Float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A rotator describing a rotation with nullable pith, yaw, and roll.
/// Used for game state setting to define which part of a rotator should change.
/// If a component is null, then the component will keep its current value.
/// Values are in radians.
public struct RotatorPartial : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static RotatorPartial GetRootAsRotatorPartial(ByteBuffer _bb) { return GetRootAsRotatorPartial(_bb, new RotatorPartial()); }
  public static RotatorPartial GetRootAsRotatorPartial(ByteBuffer _bb, RotatorPartial obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RotatorPartial __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// In radians with range (-pi/2,+pi/2) where 0 is flat, +pi/2 is nose straight up, -pi/2 is nose straight down.
  public RLBot.Flat.Float? Pitch { get { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.Float?)(new RLBot.Flat.Float()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// In radians with range [-pi,+pi) where 0 is towards positive x, rotating clockwise as increased (when seen from above).
  public RLBot.Flat.Float? Yaw { get { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.Float?)(new RLBot.Flat.Float()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// In radians with range (-pi,+pi) where 0 is upright, positive is tilted right, negative is tilted left.
  public RLBot.Flat.Float? Roll { get { int o = __p.__offset(8); return o != 0 ? (RLBot.Flat.Float?)(new RLBot.Flat.Float()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static void StartRotatorPartial(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddPitch(FlatBufferBuilder builder, Offset<RLBot.Flat.Float> pitchOffset) { builder.AddStruct(0, pitchOffset.Value, 0); }
  public static void AddYaw(FlatBufferBuilder builder, Offset<RLBot.Flat.Float> yawOffset) { builder.AddStruct(1, yawOffset.Value, 0); }
  public static void AddRoll(FlatBufferBuilder builder, Offset<RLBot.Flat.Float> rollOffset) { builder.AddStruct(2, rollOffset.Value, 0); }
  public static Offset<RLBot.Flat.RotatorPartial> EndRotatorPartial(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RLBot.Flat.RotatorPartial>(o);
  }
  public RotatorPartialT UnPack() {
    var _o = new RotatorPartialT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(RotatorPartialT _o) {
    _o.Pitch = this.Pitch.HasValue ? this.Pitch.Value.UnPack() : null;
    _o.Yaw = this.Yaw.HasValue ? this.Yaw.Value.UnPack() : null;
    _o.Roll = this.Roll.HasValue ? this.Roll.Value.UnPack() : null;
  }
  public static Offset<RLBot.Flat.RotatorPartial> Pack(FlatBufferBuilder builder, RotatorPartialT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.RotatorPartial>);
    StartRotatorPartial(builder);
    AddPitch(builder, RLBot.Flat.Float.Pack(builder, _o.Pitch));
    AddYaw(builder, RLBot.Flat.Float.Pack(builder, _o.Yaw));
    AddRoll(builder, RLBot.Flat.Float.Pack(builder, _o.Roll));
    return EndRotatorPartial(builder);
  }
}

public class RotatorPartialT
{
  public RLBot.Flat.FloatT Pitch { get; set; }
  public RLBot.Flat.FloatT Yaw { get; set; }
  public RLBot.Flat.FloatT Roll { get; set; }

  public RotatorPartialT() {
    this.Pitch = new RLBot.Flat.FloatT();
    this.Yaw = new RLBot.Flat.FloatT();
    this.Roll = new RLBot.Flat.FloatT();
  }
}


static public class RotatorPartialVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Pitch*/, 4 /*RLBot.Flat.Float*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Yaw*/, 4 /*RLBot.Flat.Float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Roll*/, 4 /*RLBot.Flat.Float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A physical state of an object, with nullable components.
/// Used for game state setting to define which part of a physics body should change.
/// If a component is null, then the component will keep its current value.
public struct DesiredPhysics : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static DesiredPhysics GetRootAsDesiredPhysics(ByteBuffer _bb) { return GetRootAsDesiredPhysics(_bb, new DesiredPhysics()); }
  public static DesiredPhysics GetRootAsDesiredPhysics(ByteBuffer _bb, DesiredPhysics obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DesiredPhysics __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public RLBot.Flat.Vector3Partial? Location { get { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.Vector3Partial?)(new RLBot.Flat.Vector3Partial()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public RLBot.Flat.RotatorPartial? Rotation { get { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.RotatorPartial?)(new RLBot.Flat.RotatorPartial()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public RLBot.Flat.Vector3Partial? Velocity { get { int o = __p.__offset(8); return o != 0 ? (RLBot.Flat.Vector3Partial?)(new RLBot.Flat.Vector3Partial()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public RLBot.Flat.Vector3Partial? AngularVelocity { get { int o = __p.__offset(10); return o != 0 ? (RLBot.Flat.Vector3Partial?)(new RLBot.Flat.Vector3Partial()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }

  public static Offset<RLBot.Flat.DesiredPhysics> CreateDesiredPhysics(FlatBufferBuilder builder,
      Offset<RLBot.Flat.Vector3Partial> locationOffset = default(Offset<RLBot.Flat.Vector3Partial>),
      Offset<RLBot.Flat.RotatorPartial> rotationOffset = default(Offset<RLBot.Flat.RotatorPartial>),
      Offset<RLBot.Flat.Vector3Partial> velocityOffset = default(Offset<RLBot.Flat.Vector3Partial>),
      Offset<RLBot.Flat.Vector3Partial> angular_velocityOffset = default(Offset<RLBot.Flat.Vector3Partial>)) {
    builder.StartTable(4);
    DesiredPhysics.AddAngularVelocity(builder, angular_velocityOffset);
    DesiredPhysics.AddVelocity(builder, velocityOffset);
    DesiredPhysics.AddRotation(builder, rotationOffset);
    DesiredPhysics.AddLocation(builder, locationOffset);
    return DesiredPhysics.EndDesiredPhysics(builder);
  }

  public static void StartDesiredPhysics(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddLocation(FlatBufferBuilder builder, Offset<RLBot.Flat.Vector3Partial> locationOffset) { builder.AddOffset(0, locationOffset.Value, 0); }
  public static void AddRotation(FlatBufferBuilder builder, Offset<RLBot.Flat.RotatorPartial> rotationOffset) { builder.AddOffset(1, rotationOffset.Value, 0); }
  public static void AddVelocity(FlatBufferBuilder builder, Offset<RLBot.Flat.Vector3Partial> velocityOffset) { builder.AddOffset(2, velocityOffset.Value, 0); }
  public static void AddAngularVelocity(FlatBufferBuilder builder, Offset<RLBot.Flat.Vector3Partial> angularVelocityOffset) { builder.AddOffset(3, angularVelocityOffset.Value, 0); }
  public static Offset<RLBot.Flat.DesiredPhysics> EndDesiredPhysics(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RLBot.Flat.DesiredPhysics>(o);
  }
  public DesiredPhysicsT UnPack() {
    var _o = new DesiredPhysicsT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(DesiredPhysicsT _o) {
    _o.Location = this.Location.HasValue ? this.Location.Value.UnPack() : null;
    _o.Rotation = this.Rotation.HasValue ? this.Rotation.Value.UnPack() : null;
    _o.Velocity = this.Velocity.HasValue ? this.Velocity.Value.UnPack() : null;
    _o.AngularVelocity = this.AngularVelocity.HasValue ? this.AngularVelocity.Value.UnPack() : null;
  }
  public static Offset<RLBot.Flat.DesiredPhysics> Pack(FlatBufferBuilder builder, DesiredPhysicsT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.DesiredPhysics>);
    var _location = _o.Location == null ? default(Offset<RLBot.Flat.Vector3Partial>) : RLBot.Flat.Vector3Partial.Pack(builder, _o.Location);
    var _rotation = _o.Rotation == null ? default(Offset<RLBot.Flat.RotatorPartial>) : RLBot.Flat.RotatorPartial.Pack(builder, _o.Rotation);
    var _velocity = _o.Velocity == null ? default(Offset<RLBot.Flat.Vector3Partial>) : RLBot.Flat.Vector3Partial.Pack(builder, _o.Velocity);
    var _angular_velocity = _o.AngularVelocity == null ? default(Offset<RLBot.Flat.Vector3Partial>) : RLBot.Flat.Vector3Partial.Pack(builder, _o.AngularVelocity);
    return CreateDesiredPhysics(
      builder,
      _location,
      _rotation,
      _velocity,
      _angular_velocity);
  }
}

public class DesiredPhysicsT
{
  public RLBot.Flat.Vector3PartialT Location { get; set; }
  public RLBot.Flat.RotatorPartialT Rotation { get; set; }
  public RLBot.Flat.Vector3PartialT Velocity { get; set; }
  public RLBot.Flat.Vector3PartialT AngularVelocity { get; set; }

  public DesiredPhysicsT() {
    this.Location = null;
    this.Rotation = null;
    this.Velocity = null;
    this.AngularVelocity = null;
  }
}


static public class DesiredPhysicsVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTable(tablePos, 4 /*Location*/, RLBot.Flat.Vector3PartialVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 6 /*Rotation*/, RLBot.Flat.RotatorPartialVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 8 /*Velocity*/, RLBot.Flat.Vector3PartialVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 10 /*AngularVelocity*/, RLBot.Flat.Vector3PartialVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A ball state with nullable components.
/// Used for game state setting to define which part of a ball's state should change.
public struct DesiredBallState : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static DesiredBallState GetRootAsDesiredBallState(ByteBuffer _bb) { return GetRootAsDesiredBallState(_bb, new DesiredBallState()); }
  public static DesiredBallState GetRootAsDesiredBallState(ByteBuffer _bb, DesiredBallState obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DesiredBallState __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public RLBot.Flat.DesiredPhysics? Physics { get { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.DesiredPhysics?)(new RLBot.Flat.DesiredPhysics()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }

  public static Offset<RLBot.Flat.DesiredBallState> CreateDesiredBallState(FlatBufferBuilder builder,
      Offset<RLBot.Flat.DesiredPhysics> physicsOffset = default(Offset<RLBot.Flat.DesiredPhysics>)) {
    builder.StartTable(1);
    DesiredBallState.AddPhysics(builder, physicsOffset);
    return DesiredBallState.EndDesiredBallState(builder);
  }

  public static void StartDesiredBallState(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddPhysics(FlatBufferBuilder builder, Offset<RLBot.Flat.DesiredPhysics> physicsOffset) { builder.AddOffset(0, physicsOffset.Value, 0); }
  public static Offset<RLBot.Flat.DesiredBallState> EndDesiredBallState(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // physics
    return new Offset<RLBot.Flat.DesiredBallState>(o);
  }
  public DesiredBallStateT UnPack() {
    var _o = new DesiredBallStateT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(DesiredBallStateT _o) {
    _o.Physics = this.Physics.HasValue ? this.Physics.Value.UnPack() : null;
  }
  public static Offset<RLBot.Flat.DesiredBallState> Pack(FlatBufferBuilder builder, DesiredBallStateT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.DesiredBallState>);
    var _physics = _o.Physics == null ? default(Offset<RLBot.Flat.DesiredPhysics>) : RLBot.Flat.DesiredPhysics.Pack(builder, _o.Physics);
    return CreateDesiredBallState(
      builder,
      _physics);
  }
}

public class DesiredBallStateT
{
  public RLBot.Flat.DesiredPhysicsT Physics { get; set; }

  public DesiredBallStateT() {
    this.Physics = null;
  }
}


static public class DesiredBallStateVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTable(tablePos, 4 /*Physics*/, RLBot.Flat.DesiredPhysicsVerify.Verify, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A car state with nullable components.
/// Used for game state setting to define which part of a car's state should change.
public struct DesiredCarState : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static DesiredCarState GetRootAsDesiredCarState(ByteBuffer _bb) { return GetRootAsDesiredCarState(_bb, new DesiredCarState()); }
  public static DesiredCarState GetRootAsDesiredCarState(ByteBuffer _bb, DesiredCarState obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DesiredCarState __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public RLBot.Flat.DesiredPhysics? Physics { get { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.DesiredPhysics?)(new RLBot.Flat.DesiredPhysics()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public RLBot.Flat.Float? BoostAmount { get { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.Float?)(new RLBot.Flat.Float()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static Offset<RLBot.Flat.DesiredCarState> CreateDesiredCarState(FlatBufferBuilder builder,
      Offset<RLBot.Flat.DesiredPhysics> physicsOffset = default(Offset<RLBot.Flat.DesiredPhysics>),
      RLBot.Flat.FloatT boost_amount = null) {
    builder.StartTable(2);
    DesiredCarState.AddBoostAmount(builder, RLBot.Flat.Float.Pack(builder, boost_amount));
    DesiredCarState.AddPhysics(builder, physicsOffset);
    return DesiredCarState.EndDesiredCarState(builder);
  }

  public static void StartDesiredCarState(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddPhysics(FlatBufferBuilder builder, Offset<RLBot.Flat.DesiredPhysics> physicsOffset) { builder.AddOffset(0, physicsOffset.Value, 0); }
  public static void AddBoostAmount(FlatBufferBuilder builder, Offset<RLBot.Flat.Float> boostAmountOffset) { builder.AddStruct(1, boostAmountOffset.Value, 0); }
  public static Offset<RLBot.Flat.DesiredCarState> EndDesiredCarState(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RLBot.Flat.DesiredCarState>(o);
  }
  public DesiredCarStateT UnPack() {
    var _o = new DesiredCarStateT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(DesiredCarStateT _o) {
    _o.Physics = this.Physics.HasValue ? this.Physics.Value.UnPack() : null;
    _o.BoostAmount = this.BoostAmount.HasValue ? this.BoostAmount.Value.UnPack() : null;
  }
  public static Offset<RLBot.Flat.DesiredCarState> Pack(FlatBufferBuilder builder, DesiredCarStateT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.DesiredCarState>);
    var _physics = _o.Physics == null ? default(Offset<RLBot.Flat.DesiredPhysics>) : RLBot.Flat.DesiredPhysics.Pack(builder, _o.Physics);
    return CreateDesiredCarState(
      builder,
      _physics,
      _o.BoostAmount);
  }
}

public class DesiredCarStateT
{
  public RLBot.Flat.DesiredPhysicsT Physics { get; set; }
  public RLBot.Flat.FloatT BoostAmount { get; set; }

  public DesiredCarStateT() {
    this.Physics = null;
    this.BoostAmount = new RLBot.Flat.FloatT();
  }
}


static public class DesiredCarStateVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTable(tablePos, 4 /*Physics*/, RLBot.Flat.DesiredPhysicsVerify.Verify, false)
      && verifier.VerifyField(tablePos, 6 /*BoostAmount*/, 4 /*RLBot.Flat.Float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Match info with nullable components.
/// Used for game state setting to define which part of the match info should change.
public struct DesiredMatchInfo : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static DesiredMatchInfo GetRootAsDesiredMatchInfo(ByteBuffer _bb) { return GetRootAsDesiredMatchInfo(_bb, new DesiredMatchInfo()); }
  public static DesiredMatchInfo GetRootAsDesiredMatchInfo(ByteBuffer _bb, DesiredMatchInfo obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DesiredMatchInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The strength of gravity. Default is usually -650 depending on mutators.
  /// To set gravity to 0, use 0.0000001 instead, as 0 will set gravity back to the default.
  public RLBot.Flat.Float? WorldGravityZ { get { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.Float?)(new RLBot.Flat.Float()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// The game speed. Default is 1.0.
  public RLBot.Flat.Float? GameSpeed { get { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.Float?)(new RLBot.Flat.Float()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static void StartDesiredMatchInfo(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddWorldGravityZ(FlatBufferBuilder builder, Offset<RLBot.Flat.Float> worldGravityZOffset) { builder.AddStruct(0, worldGravityZOffset.Value, 0); }
  public static void AddGameSpeed(FlatBufferBuilder builder, Offset<RLBot.Flat.Float> gameSpeedOffset) { builder.AddStruct(1, gameSpeedOffset.Value, 0); }
  public static Offset<RLBot.Flat.DesiredMatchInfo> EndDesiredMatchInfo(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RLBot.Flat.DesiredMatchInfo>(o);
  }
  public DesiredMatchInfoT UnPack() {
    var _o = new DesiredMatchInfoT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(DesiredMatchInfoT _o) {
    _o.WorldGravityZ = this.WorldGravityZ.HasValue ? this.WorldGravityZ.Value.UnPack() : null;
    _o.GameSpeed = this.GameSpeed.HasValue ? this.GameSpeed.Value.UnPack() : null;
  }
  public static Offset<RLBot.Flat.DesiredMatchInfo> Pack(FlatBufferBuilder builder, DesiredMatchInfoT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.DesiredMatchInfo>);
    StartDesiredMatchInfo(builder);
    AddWorldGravityZ(builder, RLBot.Flat.Float.Pack(builder, _o.WorldGravityZ));
    AddGameSpeed(builder, RLBot.Flat.Float.Pack(builder, _o.GameSpeed));
    return EndDesiredMatchInfo(builder);
  }
}

public class DesiredMatchInfoT
{
  public RLBot.Flat.FloatT WorldGravityZ { get; set; }
  public RLBot.Flat.FloatT GameSpeed { get; set; }

  public DesiredMatchInfoT() {
    this.WorldGravityZ = new RLBot.Flat.FloatT();
    this.GameSpeed = new RLBot.Flat.FloatT();
  }
}


static public class DesiredMatchInfoVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*WorldGravityZ*/, 4 /*RLBot.Flat.Float*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*GameSpeed*/, 4 /*RLBot.Flat.Float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A console command which will be executed inside Rocket League.
/// See https://wiki.rlbot.org/framework/console-commands/ for a list of known commands.
public struct ConsoleCommand : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static ConsoleCommand GetRootAsConsoleCommand(ByteBuffer _bb) { return GetRootAsConsoleCommand(_bb, new ConsoleCommand()); }
  public static ConsoleCommand GetRootAsConsoleCommand(ByteBuffer _bb, ConsoleCommand obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ConsoleCommand __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Command { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCommandBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetCommandBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetCommandArray() { return __p.__vector_as_array<byte>(4); }

  public static Offset<RLBot.Flat.ConsoleCommand> CreateConsoleCommand(FlatBufferBuilder builder,
      StringOffset commandOffset = default(StringOffset)) {
    builder.StartTable(1);
    ConsoleCommand.AddCommand(builder, commandOffset);
    return ConsoleCommand.EndConsoleCommand(builder);
  }

  public static void StartConsoleCommand(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddCommand(FlatBufferBuilder builder, StringOffset commandOffset) { builder.AddOffset(0, commandOffset.Value, 0); }
  public static Offset<RLBot.Flat.ConsoleCommand> EndConsoleCommand(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // command
    return new Offset<RLBot.Flat.ConsoleCommand>(o);
  }
  public ConsoleCommandT UnPack() {
    var _o = new ConsoleCommandT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(ConsoleCommandT _o) {
    _o.Command = this.Command;
  }
  public static Offset<RLBot.Flat.ConsoleCommand> Pack(FlatBufferBuilder builder, ConsoleCommandT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.ConsoleCommand>);
    var _command = _o.Command == null ? default(StringOffset) : builder.CreateString(_o.Command);
    return CreateConsoleCommand(
      builder,
      _command);
  }
}

public class ConsoleCommandT
{
  public string Command { get; set; }

  public ConsoleCommandT() {
    this.Command = null;
  }
}


static public class ConsoleCommandVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Command*/, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A game state with nullable subcomponents.
/// Used for game state setting to define which part of the game should change.
/// Values not set will not be updated.
public struct DesiredGameState : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static DesiredGameState GetRootAsDesiredGameState(ByteBuffer _bb) { return GetRootAsDesiredGameState(_bb, new DesiredGameState()); }
  public static DesiredGameState GetRootAsDesiredGameState(ByteBuffer _bb, DesiredGameState obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DesiredGameState __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// A list of desired ball states.
  public RLBot.Flat.DesiredBallState? BallStates(int j) { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.DesiredBallState?)(new RLBot.Flat.DesiredBallState()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int BallStatesLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// A list of desired car states.
  public RLBot.Flat.DesiredCarState? CarStates(int j) { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.DesiredCarState?)(new RLBot.Flat.DesiredCarState()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int CarStatesLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The desired game info.
  public RLBot.Flat.DesiredMatchInfo? MatchInfo { get { int o = __p.__offset(8); return o != 0 ? (RLBot.Flat.DesiredMatchInfo?)(new RLBot.Flat.DesiredMatchInfo()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// A list of console commands to execute.
  /// See https://wiki.rlbot.org/framework/console-commands/ for a list of known commands.
  public RLBot.Flat.ConsoleCommand? ConsoleCommands(int j) { int o = __p.__offset(10); return o != 0 ? (RLBot.Flat.ConsoleCommand?)(new RLBot.Flat.ConsoleCommand()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int ConsoleCommandsLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<RLBot.Flat.DesiredGameState> CreateDesiredGameState(FlatBufferBuilder builder,
      VectorOffset ball_statesOffset = default(VectorOffset),
      VectorOffset car_statesOffset = default(VectorOffset),
      Offset<RLBot.Flat.DesiredMatchInfo> match_infoOffset = default(Offset<RLBot.Flat.DesiredMatchInfo>),
      VectorOffset console_commandsOffset = default(VectorOffset)) {
    builder.StartTable(4);
    DesiredGameState.AddConsoleCommands(builder, console_commandsOffset);
    DesiredGameState.AddMatchInfo(builder, match_infoOffset);
    DesiredGameState.AddCarStates(builder, car_statesOffset);
    DesiredGameState.AddBallStates(builder, ball_statesOffset);
    return DesiredGameState.EndDesiredGameState(builder);
  }

  public static void StartDesiredGameState(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddBallStates(FlatBufferBuilder builder, VectorOffset ballStatesOffset) { builder.AddOffset(0, ballStatesOffset.Value, 0); }
  public static VectorOffset CreateBallStatesVector(FlatBufferBuilder builder, Offset<RLBot.Flat.DesiredBallState>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateBallStatesVectorBlock(FlatBufferBuilder builder, Offset<RLBot.Flat.DesiredBallState>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBallStatesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<RLBot.Flat.DesiredBallState>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBallStatesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<RLBot.Flat.DesiredBallState>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartBallStatesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddCarStates(FlatBufferBuilder builder, VectorOffset carStatesOffset) { builder.AddOffset(1, carStatesOffset.Value, 0); }
  public static VectorOffset CreateCarStatesVector(FlatBufferBuilder builder, Offset<RLBot.Flat.DesiredCarState>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateCarStatesVectorBlock(FlatBufferBuilder builder, Offset<RLBot.Flat.DesiredCarState>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCarStatesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<RLBot.Flat.DesiredCarState>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCarStatesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<RLBot.Flat.DesiredCarState>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCarStatesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddMatchInfo(FlatBufferBuilder builder, Offset<RLBot.Flat.DesiredMatchInfo> matchInfoOffset) { builder.AddOffset(2, matchInfoOffset.Value, 0); }
  public static void AddConsoleCommands(FlatBufferBuilder builder, VectorOffset consoleCommandsOffset) { builder.AddOffset(3, consoleCommandsOffset.Value, 0); }
  public static VectorOffset CreateConsoleCommandsVector(FlatBufferBuilder builder, Offset<RLBot.Flat.ConsoleCommand>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateConsoleCommandsVectorBlock(FlatBufferBuilder builder, Offset<RLBot.Flat.ConsoleCommand>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateConsoleCommandsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<RLBot.Flat.ConsoleCommand>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateConsoleCommandsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<RLBot.Flat.ConsoleCommand>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartConsoleCommandsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<RLBot.Flat.DesiredGameState> EndDesiredGameState(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // ball_states
    builder.Required(o, 6);  // car_states
    builder.Required(o, 10);  // console_commands
    return new Offset<RLBot.Flat.DesiredGameState>(o);
  }
  public DesiredGameStateT UnPack() {
    var _o = new DesiredGameStateT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(DesiredGameStateT _o) {
    _o.BallStates = new List<RLBot.Flat.DesiredBallStateT>();
    for (var _j = 0; _j < this.BallStatesLength; ++_j) {_o.BallStates.Add(this.BallStates(_j).HasValue ? this.BallStates(_j).Value.UnPack() : null);}
    _o.CarStates = new List<RLBot.Flat.DesiredCarStateT>();
    for (var _j = 0; _j < this.CarStatesLength; ++_j) {_o.CarStates.Add(this.CarStates(_j).HasValue ? this.CarStates(_j).Value.UnPack() : null);}
    _o.MatchInfo = this.MatchInfo.HasValue ? this.MatchInfo.Value.UnPack() : null;
    _o.ConsoleCommands = new List<RLBot.Flat.ConsoleCommandT>();
    for (var _j = 0; _j < this.ConsoleCommandsLength; ++_j) {_o.ConsoleCommands.Add(this.ConsoleCommands(_j).HasValue ? this.ConsoleCommands(_j).Value.UnPack() : null);}
  }
  public static Offset<RLBot.Flat.DesiredGameState> Pack(FlatBufferBuilder builder, DesiredGameStateT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.DesiredGameState>);
    var _ball_states = default(VectorOffset);
    if (_o.BallStates != null) {
      var __ball_states = new Offset<RLBot.Flat.DesiredBallState>[_o.BallStates.Count];
      for (var _j = 0; _j < __ball_states.Length; ++_j) { __ball_states[_j] = RLBot.Flat.DesiredBallState.Pack(builder, _o.BallStates[_j]); }
      _ball_states = CreateBallStatesVector(builder, __ball_states);
    }
    var _car_states = default(VectorOffset);
    if (_o.CarStates != null) {
      var __car_states = new Offset<RLBot.Flat.DesiredCarState>[_o.CarStates.Count];
      for (var _j = 0; _j < __car_states.Length; ++_j) { __car_states[_j] = RLBot.Flat.DesiredCarState.Pack(builder, _o.CarStates[_j]); }
      _car_states = CreateCarStatesVector(builder, __car_states);
    }
    var _match_info = _o.MatchInfo == null ? default(Offset<RLBot.Flat.DesiredMatchInfo>) : RLBot.Flat.DesiredMatchInfo.Pack(builder, _o.MatchInfo);
    var _console_commands = default(VectorOffset);
    if (_o.ConsoleCommands != null) {
      var __console_commands = new Offset<RLBot.Flat.ConsoleCommand>[_o.ConsoleCommands.Count];
      for (var _j = 0; _j < __console_commands.Length; ++_j) { __console_commands[_j] = RLBot.Flat.ConsoleCommand.Pack(builder, _o.ConsoleCommands[_j]); }
      _console_commands = CreateConsoleCommandsVector(builder, __console_commands);
    }
    return CreateDesiredGameState(
      builder,
      _ball_states,
      _car_states,
      _match_info,
      _console_commands);
  }
}

public class DesiredGameStateT
{
  public List<RLBot.Flat.DesiredBallStateT> BallStates { get; set; }
  public List<RLBot.Flat.DesiredCarStateT> CarStates { get; set; }
  public RLBot.Flat.DesiredMatchInfoT MatchInfo { get; set; }
  public List<RLBot.Flat.ConsoleCommandT> ConsoleCommands { get; set; }

  public DesiredGameStateT() {
    this.BallStates = null;
    this.CarStates = null;
    this.MatchInfo = null;
    this.ConsoleCommands = null;
  }
}


static public class DesiredGameStateVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfTables(tablePos, 4 /*BallStates*/, RLBot.Flat.DesiredBallStateVerify.Verify, true)
      && verifier.VerifyVectorOfTables(tablePos, 6 /*CarStates*/, RLBot.Flat.DesiredCarStateVerify.Verify, true)
      && verifier.VerifyTable(tablePos, 8 /*MatchInfo*/, RLBot.Flat.DesiredMatchInfoVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 10 /*ConsoleCommands*/, RLBot.Flat.ConsoleCommandVerify.Verify, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// An RGBA color.
public struct Color : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public Color __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public byte R { get { return __p.bb.Get(__p.bb_pos + 0); } }
  public byte G { get { return __p.bb.Get(__p.bb_pos + 1); } }
  public byte B { get { return __p.bb.Get(__p.bb_pos + 2); } }
  public byte A { get { return __p.bb.Get(__p.bb_pos + 3); } }

  public static Offset<RLBot.Flat.Color> CreateColor(FlatBufferBuilder builder, byte R, byte G, byte B, byte A) {
    builder.Prep(1, 4);
    builder.PutByte(A);
    builder.PutByte(B);
    builder.PutByte(G);
    builder.PutByte(R);
    return new Offset<RLBot.Flat.Color>(builder.Offset);
  }
  public ColorT UnPack() {
    var _o = new ColorT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(ColorT _o) {
    _o.R = this.R;
    _o.G = this.G;
    _o.B = this.B;
    _o.A = this.A;
  }
  public static Offset<RLBot.Flat.Color> Pack(FlatBufferBuilder builder, ColorT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.Color>);
    return CreateColor(
      builder,
      _o.R,
      _o.G,
      _o.B,
      _o.A);
  }
}

public class ColorT
{
  public byte R { get; set; }
  public byte G { get; set; }
  public byte B { get; set; }
  public byte A { get; set; }

  public ColorT() {
    this.R = 0;
    this.G = 0;
    this.B = 0;
    this.A = 0;
  }
}

/// A normal human player.
public struct Human : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static Human GetRootAsHuman(ByteBuffer _bb) { return GetRootAsHuman(_bb, new Human()); }
  public static Human GetRootAsHuman(ByteBuffer _bb, Human obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Human __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartHuman(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<RLBot.Flat.Human> EndHuman(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RLBot.Flat.Human>(o);
  }
  public HumanT UnPack() {
    var _o = new HumanT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(HumanT _o) {
  }
  public static Offset<RLBot.Flat.Human> Pack(FlatBufferBuilder builder, HumanT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.Human>);
    StartHuman(builder);
    return EndHuman(builder);
  }
}

public class HumanT
{

  public HumanT() {
  }
}


static public class HumanVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A bot controlled by the RLBot framework.
public struct CustomBot : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static CustomBot GetRootAsCustomBot(ByteBuffer _bb) { return GetRootAsCustomBot(_bb, new CustomBot()); }
  public static CustomBot GetRootAsCustomBot(ByteBuffer _bb, CustomBot obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public CustomBot __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Requested bot name. When match start, RLBot will ensure each bot has a unique name; bots with
  /// duplicate names will be renamed with a suffix like `(2)`
  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(4); }
  /// The root directory of the bot and the working directory for the run command.
  public string RootDir { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetRootDirBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetRootDirBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetRootDirArray() { return __p.__vector_as_array<byte>(6); }
  /// The console command that starts this bot.
  public string RunCommand { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetRunCommandBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetRunCommandBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetRunCommandArray() { return __p.__vector_as_array<byte>(8); }
  /// The loadout of the player.
  public RLBot.Flat.PlayerLoadout? Loadout { get { int o = __p.__offset(10); return o != 0 ? (RLBot.Flat.PlayerLoadout?)(new RLBot.Flat.PlayerLoadout()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// A unique user-defined string that is used to connect clients to the right players/scripts.
  /// If a bot/script has a run command, RLBot will pass this agent id to the process using an environment variable, RLBOT_AGENT_ID.
  /// Upon connecting the process announces that it is responsible for this agent id and RLBot will pair the two.
  /// The recommended format for agent ids is "developer_name/bot_name".
  public string AgentId { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAgentIdBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetAgentIdBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetAgentIdArray() { return __p.__vector_as_array<byte>(12); }
  /// Whether this player is part of a hivemind bot where all players/cars are controlled by the same process.
  /// Players in the hivemind must have the same name, team, run command, and agent id.
  public bool Hivemind { get { int o = __p.__offset(14); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<RLBot.Flat.CustomBot> CreateCustomBot(FlatBufferBuilder builder,
      StringOffset nameOffset = default(StringOffset),
      StringOffset root_dirOffset = default(StringOffset),
      StringOffset run_commandOffset = default(StringOffset),
      Offset<RLBot.Flat.PlayerLoadout> loadoutOffset = default(Offset<RLBot.Flat.PlayerLoadout>),
      StringOffset agent_idOffset = default(StringOffset),
      bool hivemind = false) {
    builder.StartTable(6);
    CustomBot.AddAgentId(builder, agent_idOffset);
    CustomBot.AddLoadout(builder, loadoutOffset);
    CustomBot.AddRunCommand(builder, run_commandOffset);
    CustomBot.AddRootDir(builder, root_dirOffset);
    CustomBot.AddName(builder, nameOffset);
    CustomBot.AddHivemind(builder, hivemind);
    return CustomBot.EndCustomBot(builder);
  }

  public static void StartCustomBot(FlatBufferBuilder builder) { builder.StartTable(6); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }
  public static void AddRootDir(FlatBufferBuilder builder, StringOffset rootDirOffset) { builder.AddOffset(1, rootDirOffset.Value, 0); }
  public static void AddRunCommand(FlatBufferBuilder builder, StringOffset runCommandOffset) { builder.AddOffset(2, runCommandOffset.Value, 0); }
  public static void AddLoadout(FlatBufferBuilder builder, Offset<RLBot.Flat.PlayerLoadout> loadoutOffset) { builder.AddOffset(3, loadoutOffset.Value, 0); }
  public static void AddAgentId(FlatBufferBuilder builder, StringOffset agentIdOffset) { builder.AddOffset(4, agentIdOffset.Value, 0); }
  public static void AddHivemind(FlatBufferBuilder builder, bool hivemind) { builder.AddBool(5, hivemind, false); }
  public static Offset<RLBot.Flat.CustomBot> EndCustomBot(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // name
    builder.Required(o, 6);  // root_dir
    builder.Required(o, 8);  // run_command
    builder.Required(o, 12);  // agent_id
    return new Offset<RLBot.Flat.CustomBot>(o);
  }
  public CustomBotT UnPack() {
    var _o = new CustomBotT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(CustomBotT _o) {
    _o.Name = this.Name;
    _o.RootDir = this.RootDir;
    _o.RunCommand = this.RunCommand;
    _o.Loadout = this.Loadout.HasValue ? this.Loadout.Value.UnPack() : null;
    _o.AgentId = this.AgentId;
    _o.Hivemind = this.Hivemind;
  }
  public static Offset<RLBot.Flat.CustomBot> Pack(FlatBufferBuilder builder, CustomBotT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.CustomBot>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _root_dir = _o.RootDir == null ? default(StringOffset) : builder.CreateString(_o.RootDir);
    var _run_command = _o.RunCommand == null ? default(StringOffset) : builder.CreateString(_o.RunCommand);
    var _loadout = _o.Loadout == null ? default(Offset<RLBot.Flat.PlayerLoadout>) : RLBot.Flat.PlayerLoadout.Pack(builder, _o.Loadout);
    var _agent_id = _o.AgentId == null ? default(StringOffset) : builder.CreateString(_o.AgentId);
    return CreateCustomBot(
      builder,
      _name,
      _root_dir,
      _run_command,
      _loadout,
      _agent_id,
      _o.Hivemind);
  }
}

public class CustomBotT
{
  public string Name { get; set; }
  public string RootDir { get; set; }
  public string RunCommand { get; set; }
  public RLBot.Flat.PlayerLoadoutT Loadout { get; set; }
  public string AgentId { get; set; }
  public bool Hivemind { get; set; }

  public CustomBotT() {
    this.Name = null;
    this.RootDir = null;
    this.RunCommand = null;
    this.Loadout = null;
    this.AgentId = null;
    this.Hivemind = false;
  }
}


static public class CustomBotVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Name*/, true)
      && verifier.VerifyString(tablePos, 6 /*RootDir*/, true)
      && verifier.VerifyString(tablePos, 8 /*RunCommand*/, true)
      && verifier.VerifyTable(tablePos, 10 /*Loadout*/, RLBot.Flat.PlayerLoadoutVerify.Verify, false)
      && verifier.VerifyString(tablePos, 12 /*AgentId*/, true)
      && verifier.VerifyField(tablePos, 14 /*Hivemind*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A Psyonix bot, e.g. All Star bot.
public struct PsyonixBot : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static PsyonixBot GetRootAsPsyonixBot(ByteBuffer _bb) { return GetRootAsPsyonixBot(_bb, new PsyonixBot()); }
  public static PsyonixBot GetRootAsPsyonixBot(ByteBuffer _bb, PsyonixBot obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PsyonixBot __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Requested bot name. When match start, RLBot will ensure each bot has a unique name; bots with
  /// duplicate names will be renamed with a suffix like `(2)`. For psyonix bots, a blank name will
  /// be replaced with one of the official names.
  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(4); }
  /// The loadout of the player.
  public RLBot.Flat.PlayerLoadout? Loadout { get { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.PlayerLoadout?)(new RLBot.Flat.PlayerLoadout()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public RLBot.Flat.PsyonixSkill BotSkill { get { int o = __p.__offset(8); return o != 0 ? (RLBot.Flat.PsyonixSkill)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.PsyonixSkill.Beginner; } }

  public static Offset<RLBot.Flat.PsyonixBot> CreatePsyonixBot(FlatBufferBuilder builder,
      StringOffset nameOffset = default(StringOffset),
      Offset<RLBot.Flat.PlayerLoadout> loadoutOffset = default(Offset<RLBot.Flat.PlayerLoadout>),
      RLBot.Flat.PsyonixSkill bot_skill = RLBot.Flat.PsyonixSkill.Beginner) {
    builder.StartTable(3);
    PsyonixBot.AddLoadout(builder, loadoutOffset);
    PsyonixBot.AddName(builder, nameOffset);
    PsyonixBot.AddBotSkill(builder, bot_skill);
    return PsyonixBot.EndPsyonixBot(builder);
  }

  public static void StartPsyonixBot(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }
  public static void AddLoadout(FlatBufferBuilder builder, Offset<RLBot.Flat.PlayerLoadout> loadoutOffset) { builder.AddOffset(1, loadoutOffset.Value, 0); }
  public static void AddBotSkill(FlatBufferBuilder builder, RLBot.Flat.PsyonixSkill botSkill) { builder.AddByte(2, (byte)botSkill, 0); }
  public static Offset<RLBot.Flat.PsyonixBot> EndPsyonixBot(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // name
    return new Offset<RLBot.Flat.PsyonixBot>(o);
  }
  public PsyonixBotT UnPack() {
    var _o = new PsyonixBotT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(PsyonixBotT _o) {
    _o.Name = this.Name;
    _o.Loadout = this.Loadout.HasValue ? this.Loadout.Value.UnPack() : null;
    _o.BotSkill = this.BotSkill;
  }
  public static Offset<RLBot.Flat.PsyonixBot> Pack(FlatBufferBuilder builder, PsyonixBotT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.PsyonixBot>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _loadout = _o.Loadout == null ? default(Offset<RLBot.Flat.PlayerLoadout>) : RLBot.Flat.PlayerLoadout.Pack(builder, _o.Loadout);
    return CreatePsyonixBot(
      builder,
      _name,
      _loadout,
      _o.BotSkill);
  }
}

public class PsyonixBotT
{
  public string Name { get; set; }
  public RLBot.Flat.PlayerLoadoutT Loadout { get; set; }
  public RLBot.Flat.PsyonixSkill BotSkill { get; set; }

  public PsyonixBotT() {
    this.Name = null;
    this.Loadout = null;
    this.BotSkill = RLBot.Flat.PsyonixSkill.Beginner;
  }
}


static public class PsyonixBotVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Name*/, true)
      && verifier.VerifyTable(tablePos, 6 /*Loadout*/, RLBot.Flat.PlayerLoadoutVerify.Verify, false)
      && verifier.VerifyField(tablePos, 8 /*BotSkill*/, 1 /*RLBot.Flat.PsyonixSkill*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A PlayerConfiguration defines a player of a match.
public struct PlayerConfiguration : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static PlayerConfiguration GetRootAsPlayerConfiguration(ByteBuffer _bb) { return GetRootAsPlayerConfiguration(_bb, new PlayerConfiguration()); }
  public static PlayerConfiguration GetRootAsPlayerConfiguration(ByteBuffer _bb, PlayerConfiguration obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PlayerConfiguration __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public RLBot.Flat.PlayerClass VarietyType { get { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.PlayerClass)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.PlayerClass.NONE; } }
  /// The type of the player, i.e. human, Psyonix bot, or a custom bot.
  public TTable? Variety<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(6); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public RLBot.Flat.Human VarietyAsHuman() { return Variety<RLBot.Flat.Human>().Value; }
  public RLBot.Flat.CustomBot VarietyAsCustomBot() { return Variety<RLBot.Flat.CustomBot>().Value; }
  public RLBot.Flat.PsyonixBot VarietyAsPsyonixBot() { return Variety<RLBot.Flat.PsyonixBot>().Value; }
  /// The team of the player. Blue is 0, orange is 1.
  public uint Team { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  /// The value will be set by RLBot and is always overriden.
  /// This value is mostly used internally to keep track of participants in the match.
  /// The player id can be used to find the corresponding player in the GamePacket.
  public int PlayerId { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<RLBot.Flat.PlayerConfiguration> CreatePlayerConfiguration(FlatBufferBuilder builder,
      RLBot.Flat.PlayerClass variety_type = RLBot.Flat.PlayerClass.NONE,
      int varietyOffset = 0,
      uint team = 0,
      int player_id = 0) {
    builder.StartTable(4);
    PlayerConfiguration.AddPlayerId(builder, player_id);
    PlayerConfiguration.AddTeam(builder, team);
    PlayerConfiguration.AddVariety(builder, varietyOffset);
    PlayerConfiguration.AddVarietyType(builder, variety_type);
    return PlayerConfiguration.EndPlayerConfiguration(builder);
  }

  public static void StartPlayerConfiguration(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddVarietyType(FlatBufferBuilder builder, RLBot.Flat.PlayerClass varietyType) { builder.AddByte(0, (byte)varietyType, 0); }
  public static void AddVariety(FlatBufferBuilder builder, int varietyOffset) { builder.AddOffset(1, varietyOffset, 0); }
  public static void AddTeam(FlatBufferBuilder builder, uint team) { builder.AddUint(2, team, 0); }
  public static void AddPlayerId(FlatBufferBuilder builder, int playerId) { builder.AddInt(3, playerId, 0); }
  public static Offset<RLBot.Flat.PlayerConfiguration> EndPlayerConfiguration(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 6);  // variety
    return new Offset<RLBot.Flat.PlayerConfiguration>(o);
  }
  public PlayerConfigurationT UnPack() {
    var _o = new PlayerConfigurationT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(PlayerConfigurationT _o) {
    _o.Variety = new RLBot.Flat.PlayerClassUnion();
    _o.Variety.Type = this.VarietyType;
    switch (this.VarietyType) {
      default: break;
      case RLBot.Flat.PlayerClass.Human:
        _o.Variety.Value = this.Variety<RLBot.Flat.Human>().HasValue ? this.Variety<RLBot.Flat.Human>().Value.UnPack() : null;
        break;
      case RLBot.Flat.PlayerClass.CustomBot:
        _o.Variety.Value = this.Variety<RLBot.Flat.CustomBot>().HasValue ? this.Variety<RLBot.Flat.CustomBot>().Value.UnPack() : null;
        break;
      case RLBot.Flat.PlayerClass.PsyonixBot:
        _o.Variety.Value = this.Variety<RLBot.Flat.PsyonixBot>().HasValue ? this.Variety<RLBot.Flat.PsyonixBot>().Value.UnPack() : null;
        break;
    }
    _o.Team = this.Team;
    _o.PlayerId = this.PlayerId;
  }
  public static Offset<RLBot.Flat.PlayerConfiguration> Pack(FlatBufferBuilder builder, PlayerConfigurationT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.PlayerConfiguration>);
    var _variety_type = _o.Variety == null ? RLBot.Flat.PlayerClass.NONE : _o.Variety.Type;
    var _variety = _o.Variety == null ? 0 : RLBot.Flat.PlayerClassUnion.Pack(builder, _o.Variety);
    return CreatePlayerConfiguration(
      builder,
      _variety_type,
      _variety,
      _o.Team,
      _o.PlayerId);
  }
}

public class PlayerConfigurationT
{
  public RLBot.Flat.PlayerClassUnion Variety { get; set; }
  public uint Team { get; set; }
  public int PlayerId { get; set; }

  public PlayerConfigurationT() {
    this.Variety = null;
    this.Team = 0;
    this.PlayerId = 0;
  }
}


static public class PlayerConfigurationVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*VarietyType*/, 1 /*RLBot.Flat.PlayerClass*/, 1, false)
      && verifier.VerifyUnion(tablePos, 4, 6 /*Variety*/, RLBot.Flat.PlayerClassVerify.Verify, true)
      && verifier.VerifyField(tablePos, 8 /*Team*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*PlayerId*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Defines the car type, color, and other aspects of the player's appearance.
/// See https://wiki.rlbot.org/botmaking/bot-customization/
public struct PlayerLoadout : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static PlayerLoadout GetRootAsPlayerLoadout(ByteBuffer _bb) { return GetRootAsPlayerLoadout(_bb, new PlayerLoadout()); }
  public static PlayerLoadout GetRootAsPlayerLoadout(ByteBuffer _bb, PlayerLoadout obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PlayerLoadout __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public uint TeamColorId { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint CustomColorId { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint CarId { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint DecalId { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint WheelsId { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint BoostId { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint AntennaId { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint HatId { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint PaintFinishId { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint CustomFinishId { get { int o = __p.__offset(22); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint EngineAudioId { get { int o = __p.__offset(24); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint TrailsId { get { int o = __p.__offset(26); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint GoalExplosionId { get { int o = __p.__offset(28); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public RLBot.Flat.LoadoutPaint? LoadoutPaint { get { int o = __p.__offset(30); return o != 0 ? (RLBot.Flat.LoadoutPaint?)(new RLBot.Flat.LoadoutPaint()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// Sets the primary color of the car to the swatch that most closely matches the provided
  /// RGB color value. If set, this overrides teamColorId.
  public RLBot.Flat.Color? PrimaryColorLookup { get { int o = __p.__offset(32); return o != 0 ? (RLBot.Flat.Color?)(new RLBot.Flat.Color()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// Sets the secondary color of the car to the swatch that most closely matches the provided
  /// RGB color value. If set, this overrides customColorId.
  public RLBot.Flat.Color? SecondaryColorLookup { get { int o = __p.__offset(34); return o != 0 ? (RLBot.Flat.Color?)(new RLBot.Flat.Color()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static Offset<RLBot.Flat.PlayerLoadout> CreatePlayerLoadout(FlatBufferBuilder builder,
      uint team_color_id = 0,
      uint custom_color_id = 0,
      uint car_id = 0,
      uint decal_id = 0,
      uint wheels_id = 0,
      uint boost_id = 0,
      uint antenna_id = 0,
      uint hat_id = 0,
      uint paint_finish_id = 0,
      uint custom_finish_id = 0,
      uint engine_audio_id = 0,
      uint trails_id = 0,
      uint goal_explosion_id = 0,
      Offset<RLBot.Flat.LoadoutPaint> loadout_paintOffset = default(Offset<RLBot.Flat.LoadoutPaint>),
      RLBot.Flat.ColorT primary_color_lookup = null,
      RLBot.Flat.ColorT secondary_color_lookup = null) {
    builder.StartTable(16);
    PlayerLoadout.AddSecondaryColorLookup(builder, RLBot.Flat.Color.Pack(builder, secondary_color_lookup));
    PlayerLoadout.AddPrimaryColorLookup(builder, RLBot.Flat.Color.Pack(builder, primary_color_lookup));
    PlayerLoadout.AddLoadoutPaint(builder, loadout_paintOffset);
    PlayerLoadout.AddGoalExplosionId(builder, goal_explosion_id);
    PlayerLoadout.AddTrailsId(builder, trails_id);
    PlayerLoadout.AddEngineAudioId(builder, engine_audio_id);
    PlayerLoadout.AddCustomFinishId(builder, custom_finish_id);
    PlayerLoadout.AddPaintFinishId(builder, paint_finish_id);
    PlayerLoadout.AddHatId(builder, hat_id);
    PlayerLoadout.AddAntennaId(builder, antenna_id);
    PlayerLoadout.AddBoostId(builder, boost_id);
    PlayerLoadout.AddWheelsId(builder, wheels_id);
    PlayerLoadout.AddDecalId(builder, decal_id);
    PlayerLoadout.AddCarId(builder, car_id);
    PlayerLoadout.AddCustomColorId(builder, custom_color_id);
    PlayerLoadout.AddTeamColorId(builder, team_color_id);
    return PlayerLoadout.EndPlayerLoadout(builder);
  }

  public static void StartPlayerLoadout(FlatBufferBuilder builder) { builder.StartTable(16); }
  public static void AddTeamColorId(FlatBufferBuilder builder, uint teamColorId) { builder.AddUint(0, teamColorId, 0); }
  public static void AddCustomColorId(FlatBufferBuilder builder, uint customColorId) { builder.AddUint(1, customColorId, 0); }
  public static void AddCarId(FlatBufferBuilder builder, uint carId) { builder.AddUint(2, carId, 0); }
  public static void AddDecalId(FlatBufferBuilder builder, uint decalId) { builder.AddUint(3, decalId, 0); }
  public static void AddWheelsId(FlatBufferBuilder builder, uint wheelsId) { builder.AddUint(4, wheelsId, 0); }
  public static void AddBoostId(FlatBufferBuilder builder, uint boostId) { builder.AddUint(5, boostId, 0); }
  public static void AddAntennaId(FlatBufferBuilder builder, uint antennaId) { builder.AddUint(6, antennaId, 0); }
  public static void AddHatId(FlatBufferBuilder builder, uint hatId) { builder.AddUint(7, hatId, 0); }
  public static void AddPaintFinishId(FlatBufferBuilder builder, uint paintFinishId) { builder.AddUint(8, paintFinishId, 0); }
  public static void AddCustomFinishId(FlatBufferBuilder builder, uint customFinishId) { builder.AddUint(9, customFinishId, 0); }
  public static void AddEngineAudioId(FlatBufferBuilder builder, uint engineAudioId) { builder.AddUint(10, engineAudioId, 0); }
  public static void AddTrailsId(FlatBufferBuilder builder, uint trailsId) { builder.AddUint(11, trailsId, 0); }
  public static void AddGoalExplosionId(FlatBufferBuilder builder, uint goalExplosionId) { builder.AddUint(12, goalExplosionId, 0); }
  public static void AddLoadoutPaint(FlatBufferBuilder builder, Offset<RLBot.Flat.LoadoutPaint> loadoutPaintOffset) { builder.AddOffset(13, loadoutPaintOffset.Value, 0); }
  public static void AddPrimaryColorLookup(FlatBufferBuilder builder, Offset<RLBot.Flat.Color> primaryColorLookupOffset) { builder.AddStruct(14, primaryColorLookupOffset.Value, 0); }
  public static void AddSecondaryColorLookup(FlatBufferBuilder builder, Offset<RLBot.Flat.Color> secondaryColorLookupOffset) { builder.AddStruct(15, secondaryColorLookupOffset.Value, 0); }
  public static Offset<RLBot.Flat.PlayerLoadout> EndPlayerLoadout(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RLBot.Flat.PlayerLoadout>(o);
  }
  public PlayerLoadoutT UnPack() {
    var _o = new PlayerLoadoutT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(PlayerLoadoutT _o) {
    _o.TeamColorId = this.TeamColorId;
    _o.CustomColorId = this.CustomColorId;
    _o.CarId = this.CarId;
    _o.DecalId = this.DecalId;
    _o.WheelsId = this.WheelsId;
    _o.BoostId = this.BoostId;
    _o.AntennaId = this.AntennaId;
    _o.HatId = this.HatId;
    _o.PaintFinishId = this.PaintFinishId;
    _o.CustomFinishId = this.CustomFinishId;
    _o.EngineAudioId = this.EngineAudioId;
    _o.TrailsId = this.TrailsId;
    _o.GoalExplosionId = this.GoalExplosionId;
    _o.LoadoutPaint = this.LoadoutPaint.HasValue ? this.LoadoutPaint.Value.UnPack() : null;
    _o.PrimaryColorLookup = this.PrimaryColorLookup.HasValue ? this.PrimaryColorLookup.Value.UnPack() : null;
    _o.SecondaryColorLookup = this.SecondaryColorLookup.HasValue ? this.SecondaryColorLookup.Value.UnPack() : null;
  }
  public static Offset<RLBot.Flat.PlayerLoadout> Pack(FlatBufferBuilder builder, PlayerLoadoutT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.PlayerLoadout>);
    var _loadout_paint = _o.LoadoutPaint == null ? default(Offset<RLBot.Flat.LoadoutPaint>) : RLBot.Flat.LoadoutPaint.Pack(builder, _o.LoadoutPaint);
    return CreatePlayerLoadout(
      builder,
      _o.TeamColorId,
      _o.CustomColorId,
      _o.CarId,
      _o.DecalId,
      _o.WheelsId,
      _o.BoostId,
      _o.AntennaId,
      _o.HatId,
      _o.PaintFinishId,
      _o.CustomFinishId,
      _o.EngineAudioId,
      _o.TrailsId,
      _o.GoalExplosionId,
      _loadout_paint,
      _o.PrimaryColorLookup,
      _o.SecondaryColorLookup);
  }
}

public class PlayerLoadoutT
{
  public uint TeamColorId { get; set; }
  public uint CustomColorId { get; set; }
  public uint CarId { get; set; }
  public uint DecalId { get; set; }
  public uint WheelsId { get; set; }
  public uint BoostId { get; set; }
  public uint AntennaId { get; set; }
  public uint HatId { get; set; }
  public uint PaintFinishId { get; set; }
  public uint CustomFinishId { get; set; }
  public uint EngineAudioId { get; set; }
  public uint TrailsId { get; set; }
  public uint GoalExplosionId { get; set; }
  public RLBot.Flat.LoadoutPaintT LoadoutPaint { get; set; }
  public RLBot.Flat.ColorT PrimaryColorLookup { get; set; }
  public RLBot.Flat.ColorT SecondaryColorLookup { get; set; }

  public PlayerLoadoutT() {
    this.TeamColorId = 0;
    this.CustomColorId = 0;
    this.CarId = 0;
    this.DecalId = 0;
    this.WheelsId = 0;
    this.BoostId = 0;
    this.AntennaId = 0;
    this.HatId = 0;
    this.PaintFinishId = 0;
    this.CustomFinishId = 0;
    this.EngineAudioId = 0;
    this.TrailsId = 0;
    this.GoalExplosionId = 0;
    this.LoadoutPaint = null;
    this.PrimaryColorLookup = new RLBot.Flat.ColorT();
    this.SecondaryColorLookup = new RLBot.Flat.ColorT();
  }
}


static public class PlayerLoadoutVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*TeamColorId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*CustomColorId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*CarId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*DecalId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 12 /*WheelsId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 14 /*BoostId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 16 /*AntennaId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 18 /*HatId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 20 /*PaintFinishId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 22 /*CustomFinishId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 24 /*EngineAudioId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 26 /*TrailsId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 28 /*GoalExplosionId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyTable(tablePos, 30 /*LoadoutPaint*/, RLBot.Flat.LoadoutPaintVerify.Verify, false)
      && verifier.VerifyField(tablePos, 32 /*PrimaryColorLookup*/, 4 /*RLBot.Flat.Color*/, 1, false)
      && verifier.VerifyField(tablePos, 34 /*SecondaryColorLookup*/, 4 /*RLBot.Flat.Color*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Specification for 'painted' items. See https://wiki.rlbot.org/botmaking/bot-customization/
public struct LoadoutPaint : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static LoadoutPaint GetRootAsLoadoutPaint(ByteBuffer _bb) { return GetRootAsLoadoutPaint(_bb, new LoadoutPaint()); }
  public static LoadoutPaint GetRootAsLoadoutPaint(ByteBuffer _bb, LoadoutPaint obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public LoadoutPaint __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public uint CarPaintId { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint DecalPaintId { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint WheelsPaintId { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint BoostPaintId { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint AntennaPaintId { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint HatPaintId { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint TrailsPaintId { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint GoalExplosionPaintId { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }

  public static Offset<RLBot.Flat.LoadoutPaint> CreateLoadoutPaint(FlatBufferBuilder builder,
      uint car_paint_id = 0,
      uint decal_paint_id = 0,
      uint wheels_paint_id = 0,
      uint boost_paint_id = 0,
      uint antenna_paint_id = 0,
      uint hat_paint_id = 0,
      uint trails_paint_id = 0,
      uint goal_explosion_paint_id = 0) {
    builder.StartTable(8);
    LoadoutPaint.AddGoalExplosionPaintId(builder, goal_explosion_paint_id);
    LoadoutPaint.AddTrailsPaintId(builder, trails_paint_id);
    LoadoutPaint.AddHatPaintId(builder, hat_paint_id);
    LoadoutPaint.AddAntennaPaintId(builder, antenna_paint_id);
    LoadoutPaint.AddBoostPaintId(builder, boost_paint_id);
    LoadoutPaint.AddWheelsPaintId(builder, wheels_paint_id);
    LoadoutPaint.AddDecalPaintId(builder, decal_paint_id);
    LoadoutPaint.AddCarPaintId(builder, car_paint_id);
    return LoadoutPaint.EndLoadoutPaint(builder);
  }

  public static void StartLoadoutPaint(FlatBufferBuilder builder) { builder.StartTable(8); }
  public static void AddCarPaintId(FlatBufferBuilder builder, uint carPaintId) { builder.AddUint(0, carPaintId, 0); }
  public static void AddDecalPaintId(FlatBufferBuilder builder, uint decalPaintId) { builder.AddUint(1, decalPaintId, 0); }
  public static void AddWheelsPaintId(FlatBufferBuilder builder, uint wheelsPaintId) { builder.AddUint(2, wheelsPaintId, 0); }
  public static void AddBoostPaintId(FlatBufferBuilder builder, uint boostPaintId) { builder.AddUint(3, boostPaintId, 0); }
  public static void AddAntennaPaintId(FlatBufferBuilder builder, uint antennaPaintId) { builder.AddUint(4, antennaPaintId, 0); }
  public static void AddHatPaintId(FlatBufferBuilder builder, uint hatPaintId) { builder.AddUint(5, hatPaintId, 0); }
  public static void AddTrailsPaintId(FlatBufferBuilder builder, uint trailsPaintId) { builder.AddUint(6, trailsPaintId, 0); }
  public static void AddGoalExplosionPaintId(FlatBufferBuilder builder, uint goalExplosionPaintId) { builder.AddUint(7, goalExplosionPaintId, 0); }
  public static Offset<RLBot.Flat.LoadoutPaint> EndLoadoutPaint(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RLBot.Flat.LoadoutPaint>(o);
  }
  public LoadoutPaintT UnPack() {
    var _o = new LoadoutPaintT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(LoadoutPaintT _o) {
    _o.CarPaintId = this.CarPaintId;
    _o.DecalPaintId = this.DecalPaintId;
    _o.WheelsPaintId = this.WheelsPaintId;
    _o.BoostPaintId = this.BoostPaintId;
    _o.AntennaPaintId = this.AntennaPaintId;
    _o.HatPaintId = this.HatPaintId;
    _o.TrailsPaintId = this.TrailsPaintId;
    _o.GoalExplosionPaintId = this.GoalExplosionPaintId;
  }
  public static Offset<RLBot.Flat.LoadoutPaint> Pack(FlatBufferBuilder builder, LoadoutPaintT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.LoadoutPaint>);
    return CreateLoadoutPaint(
      builder,
      _o.CarPaintId,
      _o.DecalPaintId,
      _o.WheelsPaintId,
      _o.BoostPaintId,
      _o.AntennaPaintId,
      _o.HatPaintId,
      _o.TrailsPaintId,
      _o.GoalExplosionPaintId);
  }
}

public class LoadoutPaintT
{
  public uint CarPaintId { get; set; }
  public uint DecalPaintId { get; set; }
  public uint WheelsPaintId { get; set; }
  public uint BoostPaintId { get; set; }
  public uint AntennaPaintId { get; set; }
  public uint HatPaintId { get; set; }
  public uint TrailsPaintId { get; set; }
  public uint GoalExplosionPaintId { get; set; }

  public LoadoutPaintT() {
    this.CarPaintId = 0;
    this.DecalPaintId = 0;
    this.WheelsPaintId = 0;
    this.BoostPaintId = 0;
    this.AntennaPaintId = 0;
    this.HatPaintId = 0;
    this.TrailsPaintId = 0;
    this.GoalExplosionPaintId = 0;
  }
}


static public class LoadoutPaintVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*CarPaintId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*DecalPaintId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*WheelsPaintId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*BoostPaintId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 12 /*AntennaPaintId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 14 /*HatPaintId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 16 /*TrailsPaintId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 18 /*GoalExplosionPaintId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// All mutators options.
public struct MutatorSettings : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static MutatorSettings GetRootAsMutatorSettings(ByteBuffer _bb) { return GetRootAsMutatorSettings(_bb, new MutatorSettings()); }
  public static MutatorSettings GetRootAsMutatorSettings(ByteBuffer _bb, MutatorSettings obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public MutatorSettings __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Duration of the match.
  public RLBot.Flat.MatchLengthMutator MatchLength { get { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.MatchLengthMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.MatchLengthMutator.FiveMinutes; } }
  /// Max score of match. If this score is reached, the team immediately wins.
  public RLBot.Flat.MaxScoreMutator MaxScore { get { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.MaxScoreMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.MaxScoreMutator.Unlimited; } }
  /// The number of balls.
  public RLBot.Flat.MultiBallMutator MultiBall { get { int o = __p.__offset(8); return o != 0 ? (RLBot.Flat.MultiBallMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.MultiBallMutator.One; } }
  /// The overtime rules and tiebreaker.
  public RLBot.Flat.OvertimeMutator Overtime { get { int o = __p.__offset(10); return o != 0 ? (RLBot.Flat.OvertimeMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.OvertimeMutator.Unlimited; } }
  /// The series length.
  public RLBot.Flat.SeriesLengthMutator SeriesLength { get { int o = __p.__offset(12); return o != 0 ? (RLBot.Flat.SeriesLengthMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.SeriesLengthMutator.Unlimited; } }
  /// A game speed multiplier.
  public RLBot.Flat.GameSpeedMutator GameSpeed { get { int o = __p.__offset(14); return o != 0 ? (RLBot.Flat.GameSpeedMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.GameSpeedMutator.Default; } }
  /// Ball max speed.
  public RLBot.Flat.BallMaxSpeedMutator BallMaxSpeed { get { int o = __p.__offset(16); return o != 0 ? (RLBot.Flat.BallMaxSpeedMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.BallMaxSpeedMutator.Default; } }
  /// Ball type and shape.
  public RLBot.Flat.BallTypeMutator BallType { get { int o = __p.__offset(18); return o != 0 ? (RLBot.Flat.BallTypeMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.BallTypeMutator.Default; } }
  /// Ball weight and how much is curves.
  public RLBot.Flat.BallWeightMutator BallWeight { get { int o = __p.__offset(20); return o != 0 ? (RLBot.Flat.BallWeightMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.BallWeightMutator.Default; } }
  /// Ball size.
  public RLBot.Flat.BallSizeMutator BallSize { get { int o = __p.__offset(22); return o != 0 ? (RLBot.Flat.BallSizeMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.BallSizeMutator.Default; } }
  /// Ball bounciness.
  public RLBot.Flat.BallBouncinessMutator BallBounciness { get { int o = __p.__offset(24); return o != 0 ? (RLBot.Flat.BallBouncinessMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.BallBouncinessMutator.Default; } }
  /// Boost amount/recharge.
  public RLBot.Flat.BoostAmountMutator BoostAmount { get { int o = __p.__offset(26); return o != 0 ? (RLBot.Flat.BoostAmountMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.BoostAmountMutator.NormalBoost; } }
  /// Rumble item rules.
  public RLBot.Flat.RumbleMutator Rumble { get { int o = __p.__offset(28); return o != 0 ? (RLBot.Flat.RumbleMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.RumbleMutator.Off; } }
  /// Boost strength multiplier.
  public RLBot.Flat.BoostStrengthMutator BoostStrength { get { int o = __p.__offset(30); return o != 0 ? (RLBot.Flat.BoostStrengthMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.BoostStrengthMutator.One; } }
  /// Strength of gravity.
  public RLBot.Flat.GravityMutator Gravity { get { int o = __p.__offset(32); return o != 0 ? (RLBot.Flat.GravityMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.GravityMutator.Default; } }
  /// Demolition conditions.
  public RLBot.Flat.DemolishMutator Demolish { get { int o = __p.__offset(34); return o != 0 ? (RLBot.Flat.DemolishMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.DemolishMutator.Default; } }
  /// Demolition respawn time.
  public RLBot.Flat.RespawnTimeMutator RespawnTime { get { int o = __p.__offset(36); return o != 0 ? (RLBot.Flat.RespawnTimeMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.RespawnTimeMutator.ThreeSeconds; } }
  /// Max real-time duration of match including kickoff, replays, and more.
  /// If the score is tied upon time-out, the number of shots determine the winner.
  public RLBot.Flat.MaxTimeMutator MaxTime { get { int o = __p.__offset(38); return o != 0 ? (RLBot.Flat.MaxTimeMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.MaxTimeMutator.Unlimited; } }
  /// Additional game behaviour for custom modes.
  public RLBot.Flat.GameEventMutator GameEvent { get { int o = __p.__offset(40); return o != 0 ? (RLBot.Flat.GameEventMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.GameEventMutator.Default; } }
  /// Additional audio options for custom modes.
  public RLBot.Flat.AudioMutator Audio { get { int o = __p.__offset(42); return o != 0 ? (RLBot.Flat.AudioMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.AudioMutator.Default; } }
  /// Ball gravity.
  public RLBot.Flat.BallGravityMutator BallGravity { get { int o = __p.__offset(44); return o != 0 ? (RLBot.Flat.BallGravityMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.BallGravityMutator.Default; } }
  /// Territory mutator.
  public RLBot.Flat.TerritoryMutator Territory { get { int o = __p.__offset(46); return o != 0 ? (RLBot.Flat.TerritoryMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.TerritoryMutator.Off; } }
  /// Stale ball mutator.
  public RLBot.Flat.StaleBallMutator StaleBall { get { int o = __p.__offset(48); return o != 0 ? (RLBot.Flat.StaleBallMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.StaleBallMutator.Unlimited; } }
  /// Jumps mutator.
  public RLBot.Flat.JumpMutator Jump { get { int o = __p.__offset(50); return o != 0 ? (RLBot.Flat.JumpMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.JumpMutator.Default; } }
  /// Dodge timer mutator.
  public RLBot.Flat.DodgeTimerMutator DodgeTimer { get { int o = __p.__offset(52); return o != 0 ? (RLBot.Flat.DodgeTimerMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.DodgeTimerMutator.OnePointTwentyFiveSeconds; } }
  /// Possession score mutator.
  public RLBot.Flat.PossessionScoreMutator PossessionScore { get { int o = __p.__offset(54); return o != 0 ? (RLBot.Flat.PossessionScoreMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.PossessionScoreMutator.Off; } }
  /// Demolish score mutator.
  public RLBot.Flat.DemolishScoreMutator DemolishScore { get { int o = __p.__offset(56); return o != 0 ? (RLBot.Flat.DemolishScoreMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.DemolishScoreMutator.Zero; } }
  /// Normal goal score mutator.
  public RLBot.Flat.NormalGoalScoreMutator NormalGoalScore { get { int o = __p.__offset(58); return o != 0 ? (RLBot.Flat.NormalGoalScoreMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.NormalGoalScoreMutator.One; } }
  /// Aerial goal score mutator.
  public RLBot.Flat.AerialGoalScoreMutator AerialGoalScore { get { int o = __p.__offset(60); return o != 0 ? (RLBot.Flat.AerialGoalScoreMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.AerialGoalScoreMutator.One; } }
  /// Assist goal score mutator.
  public RLBot.Flat.AssistGoalScoreMutator AssistGoalScore { get { int o = __p.__offset(62); return o != 0 ? (RLBot.Flat.AssistGoalScoreMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.AssistGoalScoreMutator.Zero; } }
  /// Player input restriction mutator.
  public RLBot.Flat.InputRestrictionMutator InputRestriction { get { int o = __p.__offset(64); return o != 0 ? (RLBot.Flat.InputRestrictionMutator)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.InputRestrictionMutator.Default; } }
  /// Additional rules that apply to scoring goals
  public RLBot.Flat.ScoringRule ScoringRule { get { int o = __p.__offset(66); return o != 0 ? (RLBot.Flat.ScoringRule)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.ScoringRule.Default; } }

  public static Offset<RLBot.Flat.MutatorSettings> CreateMutatorSettings(FlatBufferBuilder builder,
      RLBot.Flat.MatchLengthMutator match_length = RLBot.Flat.MatchLengthMutator.FiveMinutes,
      RLBot.Flat.MaxScoreMutator max_score = RLBot.Flat.MaxScoreMutator.Unlimited,
      RLBot.Flat.MultiBallMutator multi_ball = RLBot.Flat.MultiBallMutator.One,
      RLBot.Flat.OvertimeMutator overtime = RLBot.Flat.OvertimeMutator.Unlimited,
      RLBot.Flat.SeriesLengthMutator series_length = RLBot.Flat.SeriesLengthMutator.Unlimited,
      RLBot.Flat.GameSpeedMutator game_speed = RLBot.Flat.GameSpeedMutator.Default,
      RLBot.Flat.BallMaxSpeedMutator ball_max_speed = RLBot.Flat.BallMaxSpeedMutator.Default,
      RLBot.Flat.BallTypeMutator ball_type = RLBot.Flat.BallTypeMutator.Default,
      RLBot.Flat.BallWeightMutator ball_weight = RLBot.Flat.BallWeightMutator.Default,
      RLBot.Flat.BallSizeMutator ball_size = RLBot.Flat.BallSizeMutator.Default,
      RLBot.Flat.BallBouncinessMutator ball_bounciness = RLBot.Flat.BallBouncinessMutator.Default,
      RLBot.Flat.BoostAmountMutator boost_amount = RLBot.Flat.BoostAmountMutator.NormalBoost,
      RLBot.Flat.RumbleMutator rumble = RLBot.Flat.RumbleMutator.Off,
      RLBot.Flat.BoostStrengthMutator boost_strength = RLBot.Flat.BoostStrengthMutator.One,
      RLBot.Flat.GravityMutator gravity = RLBot.Flat.GravityMutator.Default,
      RLBot.Flat.DemolishMutator demolish = RLBot.Flat.DemolishMutator.Default,
      RLBot.Flat.RespawnTimeMutator respawn_time = RLBot.Flat.RespawnTimeMutator.ThreeSeconds,
      RLBot.Flat.MaxTimeMutator max_time = RLBot.Flat.MaxTimeMutator.Unlimited,
      RLBot.Flat.GameEventMutator game_event = RLBot.Flat.GameEventMutator.Default,
      RLBot.Flat.AudioMutator audio = RLBot.Flat.AudioMutator.Default,
      RLBot.Flat.BallGravityMutator ball_gravity = RLBot.Flat.BallGravityMutator.Default,
      RLBot.Flat.TerritoryMutator territory = RLBot.Flat.TerritoryMutator.Off,
      RLBot.Flat.StaleBallMutator stale_ball = RLBot.Flat.StaleBallMutator.Unlimited,
      RLBot.Flat.JumpMutator jump = RLBot.Flat.JumpMutator.Default,
      RLBot.Flat.DodgeTimerMutator dodge_timer = RLBot.Flat.DodgeTimerMutator.OnePointTwentyFiveSeconds,
      RLBot.Flat.PossessionScoreMutator possession_score = RLBot.Flat.PossessionScoreMutator.Off,
      RLBot.Flat.DemolishScoreMutator demolish_score = RLBot.Flat.DemolishScoreMutator.Zero,
      RLBot.Flat.NormalGoalScoreMutator normal_goal_score = RLBot.Flat.NormalGoalScoreMutator.One,
      RLBot.Flat.AerialGoalScoreMutator aerial_goal_score = RLBot.Flat.AerialGoalScoreMutator.One,
      RLBot.Flat.AssistGoalScoreMutator assist_goal_score = RLBot.Flat.AssistGoalScoreMutator.Zero,
      RLBot.Flat.InputRestrictionMutator input_restriction = RLBot.Flat.InputRestrictionMutator.Default,
      RLBot.Flat.ScoringRule scoring_rule = RLBot.Flat.ScoringRule.Default) {
    builder.StartTable(32);
    MutatorSettings.AddScoringRule(builder, scoring_rule);
    MutatorSettings.AddInputRestriction(builder, input_restriction);
    MutatorSettings.AddAssistGoalScore(builder, assist_goal_score);
    MutatorSettings.AddAerialGoalScore(builder, aerial_goal_score);
    MutatorSettings.AddNormalGoalScore(builder, normal_goal_score);
    MutatorSettings.AddDemolishScore(builder, demolish_score);
    MutatorSettings.AddPossessionScore(builder, possession_score);
    MutatorSettings.AddDodgeTimer(builder, dodge_timer);
    MutatorSettings.AddJump(builder, jump);
    MutatorSettings.AddStaleBall(builder, stale_ball);
    MutatorSettings.AddTerritory(builder, territory);
    MutatorSettings.AddBallGravity(builder, ball_gravity);
    MutatorSettings.AddAudio(builder, audio);
    MutatorSettings.AddGameEvent(builder, game_event);
    MutatorSettings.AddMaxTime(builder, max_time);
    MutatorSettings.AddRespawnTime(builder, respawn_time);
    MutatorSettings.AddDemolish(builder, demolish);
    MutatorSettings.AddGravity(builder, gravity);
    MutatorSettings.AddBoostStrength(builder, boost_strength);
    MutatorSettings.AddRumble(builder, rumble);
    MutatorSettings.AddBoostAmount(builder, boost_amount);
    MutatorSettings.AddBallBounciness(builder, ball_bounciness);
    MutatorSettings.AddBallSize(builder, ball_size);
    MutatorSettings.AddBallWeight(builder, ball_weight);
    MutatorSettings.AddBallType(builder, ball_type);
    MutatorSettings.AddBallMaxSpeed(builder, ball_max_speed);
    MutatorSettings.AddGameSpeed(builder, game_speed);
    MutatorSettings.AddSeriesLength(builder, series_length);
    MutatorSettings.AddOvertime(builder, overtime);
    MutatorSettings.AddMultiBall(builder, multi_ball);
    MutatorSettings.AddMaxScore(builder, max_score);
    MutatorSettings.AddMatchLength(builder, match_length);
    return MutatorSettings.EndMutatorSettings(builder);
  }

  public static void StartMutatorSettings(FlatBufferBuilder builder) { builder.StartTable(32); }
  public static void AddMatchLength(FlatBufferBuilder builder, RLBot.Flat.MatchLengthMutator matchLength) { builder.AddByte(0, (byte)matchLength, 0); }
  public static void AddMaxScore(FlatBufferBuilder builder, RLBot.Flat.MaxScoreMutator maxScore) { builder.AddByte(1, (byte)maxScore, 0); }
  public static void AddMultiBall(FlatBufferBuilder builder, RLBot.Flat.MultiBallMutator multiBall) { builder.AddByte(2, (byte)multiBall, 0); }
  public static void AddOvertime(FlatBufferBuilder builder, RLBot.Flat.OvertimeMutator overtime) { builder.AddByte(3, (byte)overtime, 0); }
  public static void AddSeriesLength(FlatBufferBuilder builder, RLBot.Flat.SeriesLengthMutator seriesLength) { builder.AddByte(4, (byte)seriesLength, 0); }
  public static void AddGameSpeed(FlatBufferBuilder builder, RLBot.Flat.GameSpeedMutator gameSpeed) { builder.AddByte(5, (byte)gameSpeed, 0); }
  public static void AddBallMaxSpeed(FlatBufferBuilder builder, RLBot.Flat.BallMaxSpeedMutator ballMaxSpeed) { builder.AddByte(6, (byte)ballMaxSpeed, 0); }
  public static void AddBallType(FlatBufferBuilder builder, RLBot.Flat.BallTypeMutator ballType) { builder.AddByte(7, (byte)ballType, 0); }
  public static void AddBallWeight(FlatBufferBuilder builder, RLBot.Flat.BallWeightMutator ballWeight) { builder.AddByte(8, (byte)ballWeight, 0); }
  public static void AddBallSize(FlatBufferBuilder builder, RLBot.Flat.BallSizeMutator ballSize) { builder.AddByte(9, (byte)ballSize, 0); }
  public static void AddBallBounciness(FlatBufferBuilder builder, RLBot.Flat.BallBouncinessMutator ballBounciness) { builder.AddByte(10, (byte)ballBounciness, 0); }
  public static void AddBoostAmount(FlatBufferBuilder builder, RLBot.Flat.BoostAmountMutator boostAmount) { builder.AddByte(11, (byte)boostAmount, 0); }
  public static void AddRumble(FlatBufferBuilder builder, RLBot.Flat.RumbleMutator rumble) { builder.AddByte(12, (byte)rumble, 0); }
  public static void AddBoostStrength(FlatBufferBuilder builder, RLBot.Flat.BoostStrengthMutator boostStrength) { builder.AddByte(13, (byte)boostStrength, 0); }
  public static void AddGravity(FlatBufferBuilder builder, RLBot.Flat.GravityMutator gravity) { builder.AddByte(14, (byte)gravity, 0); }
  public static void AddDemolish(FlatBufferBuilder builder, RLBot.Flat.DemolishMutator demolish) { builder.AddByte(15, (byte)demolish, 0); }
  public static void AddRespawnTime(FlatBufferBuilder builder, RLBot.Flat.RespawnTimeMutator respawnTime) { builder.AddByte(16, (byte)respawnTime, 0); }
  public static void AddMaxTime(FlatBufferBuilder builder, RLBot.Flat.MaxTimeMutator maxTime) { builder.AddByte(17, (byte)maxTime, 0); }
  public static void AddGameEvent(FlatBufferBuilder builder, RLBot.Flat.GameEventMutator gameEvent) { builder.AddByte(18, (byte)gameEvent, 0); }
  public static void AddAudio(FlatBufferBuilder builder, RLBot.Flat.AudioMutator audio) { builder.AddByte(19, (byte)audio, 0); }
  public static void AddBallGravity(FlatBufferBuilder builder, RLBot.Flat.BallGravityMutator ballGravity) { builder.AddByte(20, (byte)ballGravity, 0); }
  public static void AddTerritory(FlatBufferBuilder builder, RLBot.Flat.TerritoryMutator territory) { builder.AddByte(21, (byte)territory, 0); }
  public static void AddStaleBall(FlatBufferBuilder builder, RLBot.Flat.StaleBallMutator staleBall) { builder.AddByte(22, (byte)staleBall, 0); }
  public static void AddJump(FlatBufferBuilder builder, RLBot.Flat.JumpMutator jump) { builder.AddByte(23, (byte)jump, 0); }
  public static void AddDodgeTimer(FlatBufferBuilder builder, RLBot.Flat.DodgeTimerMutator dodgeTimer) { builder.AddByte(24, (byte)dodgeTimer, 0); }
  public static void AddPossessionScore(FlatBufferBuilder builder, RLBot.Flat.PossessionScoreMutator possessionScore) { builder.AddByte(25, (byte)possessionScore, 0); }
  public static void AddDemolishScore(FlatBufferBuilder builder, RLBot.Flat.DemolishScoreMutator demolishScore) { builder.AddByte(26, (byte)demolishScore, 0); }
  public static void AddNormalGoalScore(FlatBufferBuilder builder, RLBot.Flat.NormalGoalScoreMutator normalGoalScore) { builder.AddByte(27, (byte)normalGoalScore, 0); }
  public static void AddAerialGoalScore(FlatBufferBuilder builder, RLBot.Flat.AerialGoalScoreMutator aerialGoalScore) { builder.AddByte(28, (byte)aerialGoalScore, 0); }
  public static void AddAssistGoalScore(FlatBufferBuilder builder, RLBot.Flat.AssistGoalScoreMutator assistGoalScore) { builder.AddByte(29, (byte)assistGoalScore, 0); }
  public static void AddInputRestriction(FlatBufferBuilder builder, RLBot.Flat.InputRestrictionMutator inputRestriction) { builder.AddByte(30, (byte)inputRestriction, 0); }
  public static void AddScoringRule(FlatBufferBuilder builder, RLBot.Flat.ScoringRule scoringRule) { builder.AddByte(31, (byte)scoringRule, 0); }
  public static Offset<RLBot.Flat.MutatorSettings> EndMutatorSettings(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RLBot.Flat.MutatorSettings>(o);
  }
  public MutatorSettingsT UnPack() {
    var _o = new MutatorSettingsT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(MutatorSettingsT _o) {
    _o.MatchLength = this.MatchLength;
    _o.MaxScore = this.MaxScore;
    _o.MultiBall = this.MultiBall;
    _o.Overtime = this.Overtime;
    _o.SeriesLength = this.SeriesLength;
    _o.GameSpeed = this.GameSpeed;
    _o.BallMaxSpeed = this.BallMaxSpeed;
    _o.BallType = this.BallType;
    _o.BallWeight = this.BallWeight;
    _o.BallSize = this.BallSize;
    _o.BallBounciness = this.BallBounciness;
    _o.BoostAmount = this.BoostAmount;
    _o.Rumble = this.Rumble;
    _o.BoostStrength = this.BoostStrength;
    _o.Gravity = this.Gravity;
    _o.Demolish = this.Demolish;
    _o.RespawnTime = this.RespawnTime;
    _o.MaxTime = this.MaxTime;
    _o.GameEvent = this.GameEvent;
    _o.Audio = this.Audio;
    _o.BallGravity = this.BallGravity;
    _o.Territory = this.Territory;
    _o.StaleBall = this.StaleBall;
    _o.Jump = this.Jump;
    _o.DodgeTimer = this.DodgeTimer;
    _o.PossessionScore = this.PossessionScore;
    _o.DemolishScore = this.DemolishScore;
    _o.NormalGoalScore = this.NormalGoalScore;
    _o.AerialGoalScore = this.AerialGoalScore;
    _o.AssistGoalScore = this.AssistGoalScore;
    _o.InputRestriction = this.InputRestriction;
    _o.ScoringRule = this.ScoringRule;
  }
  public static Offset<RLBot.Flat.MutatorSettings> Pack(FlatBufferBuilder builder, MutatorSettingsT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.MutatorSettings>);
    return CreateMutatorSettings(
      builder,
      _o.MatchLength,
      _o.MaxScore,
      _o.MultiBall,
      _o.Overtime,
      _o.SeriesLength,
      _o.GameSpeed,
      _o.BallMaxSpeed,
      _o.BallType,
      _o.BallWeight,
      _o.BallSize,
      _o.BallBounciness,
      _o.BoostAmount,
      _o.Rumble,
      _o.BoostStrength,
      _o.Gravity,
      _o.Demolish,
      _o.RespawnTime,
      _o.MaxTime,
      _o.GameEvent,
      _o.Audio,
      _o.BallGravity,
      _o.Territory,
      _o.StaleBall,
      _o.Jump,
      _o.DodgeTimer,
      _o.PossessionScore,
      _o.DemolishScore,
      _o.NormalGoalScore,
      _o.AerialGoalScore,
      _o.AssistGoalScore,
      _o.InputRestriction,
      _o.ScoringRule);
  }
}

public class MutatorSettingsT
{
  public RLBot.Flat.MatchLengthMutator MatchLength { get; set; }
  public RLBot.Flat.MaxScoreMutator MaxScore { get; set; }
  public RLBot.Flat.MultiBallMutator MultiBall { get; set; }
  public RLBot.Flat.OvertimeMutator Overtime { get; set; }
  public RLBot.Flat.SeriesLengthMutator SeriesLength { get; set; }
  public RLBot.Flat.GameSpeedMutator GameSpeed { get; set; }
  public RLBot.Flat.BallMaxSpeedMutator BallMaxSpeed { get; set; }
  public RLBot.Flat.BallTypeMutator BallType { get; set; }
  public RLBot.Flat.BallWeightMutator BallWeight { get; set; }
  public RLBot.Flat.BallSizeMutator BallSize { get; set; }
  public RLBot.Flat.BallBouncinessMutator BallBounciness { get; set; }
  public RLBot.Flat.BoostAmountMutator BoostAmount { get; set; }
  public RLBot.Flat.RumbleMutator Rumble { get; set; }
  public RLBot.Flat.BoostStrengthMutator BoostStrength { get; set; }
  public RLBot.Flat.GravityMutator Gravity { get; set; }
  public RLBot.Flat.DemolishMutator Demolish { get; set; }
  public RLBot.Flat.RespawnTimeMutator RespawnTime { get; set; }
  public RLBot.Flat.MaxTimeMutator MaxTime { get; set; }
  public RLBot.Flat.GameEventMutator GameEvent { get; set; }
  public RLBot.Flat.AudioMutator Audio { get; set; }
  public RLBot.Flat.BallGravityMutator BallGravity { get; set; }
  public RLBot.Flat.TerritoryMutator Territory { get; set; }
  public RLBot.Flat.StaleBallMutator StaleBall { get; set; }
  public RLBot.Flat.JumpMutator Jump { get; set; }
  public RLBot.Flat.DodgeTimerMutator DodgeTimer { get; set; }
  public RLBot.Flat.PossessionScoreMutator PossessionScore { get; set; }
  public RLBot.Flat.DemolishScoreMutator DemolishScore { get; set; }
  public RLBot.Flat.NormalGoalScoreMutator NormalGoalScore { get; set; }
  public RLBot.Flat.AerialGoalScoreMutator AerialGoalScore { get; set; }
  public RLBot.Flat.AssistGoalScoreMutator AssistGoalScore { get; set; }
  public RLBot.Flat.InputRestrictionMutator InputRestriction { get; set; }
  public RLBot.Flat.ScoringRule ScoringRule { get; set; }

  public MutatorSettingsT() {
    this.MatchLength = RLBot.Flat.MatchLengthMutator.FiveMinutes;
    this.MaxScore = RLBot.Flat.MaxScoreMutator.Unlimited;
    this.MultiBall = RLBot.Flat.MultiBallMutator.One;
    this.Overtime = RLBot.Flat.OvertimeMutator.Unlimited;
    this.SeriesLength = RLBot.Flat.SeriesLengthMutator.Unlimited;
    this.GameSpeed = RLBot.Flat.GameSpeedMutator.Default;
    this.BallMaxSpeed = RLBot.Flat.BallMaxSpeedMutator.Default;
    this.BallType = RLBot.Flat.BallTypeMutator.Default;
    this.BallWeight = RLBot.Flat.BallWeightMutator.Default;
    this.BallSize = RLBot.Flat.BallSizeMutator.Default;
    this.BallBounciness = RLBot.Flat.BallBouncinessMutator.Default;
    this.BoostAmount = RLBot.Flat.BoostAmountMutator.NormalBoost;
    this.Rumble = RLBot.Flat.RumbleMutator.Off;
    this.BoostStrength = RLBot.Flat.BoostStrengthMutator.One;
    this.Gravity = RLBot.Flat.GravityMutator.Default;
    this.Demolish = RLBot.Flat.DemolishMutator.Default;
    this.RespawnTime = RLBot.Flat.RespawnTimeMutator.ThreeSeconds;
    this.MaxTime = RLBot.Flat.MaxTimeMutator.Unlimited;
    this.GameEvent = RLBot.Flat.GameEventMutator.Default;
    this.Audio = RLBot.Flat.AudioMutator.Default;
    this.BallGravity = RLBot.Flat.BallGravityMutator.Default;
    this.Territory = RLBot.Flat.TerritoryMutator.Off;
    this.StaleBall = RLBot.Flat.StaleBallMutator.Unlimited;
    this.Jump = RLBot.Flat.JumpMutator.Default;
    this.DodgeTimer = RLBot.Flat.DodgeTimerMutator.OnePointTwentyFiveSeconds;
    this.PossessionScore = RLBot.Flat.PossessionScoreMutator.Off;
    this.DemolishScore = RLBot.Flat.DemolishScoreMutator.Zero;
    this.NormalGoalScore = RLBot.Flat.NormalGoalScoreMutator.One;
    this.AerialGoalScore = RLBot.Flat.AerialGoalScoreMutator.One;
    this.AssistGoalScore = RLBot.Flat.AssistGoalScoreMutator.Zero;
    this.InputRestriction = RLBot.Flat.InputRestrictionMutator.Default;
    this.ScoringRule = RLBot.Flat.ScoringRule.Default;
  }
}


static public class MutatorSettingsVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*MatchLength*/, 1 /*RLBot.Flat.MatchLengthMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*MaxScore*/, 1 /*RLBot.Flat.MaxScoreMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 8 /*MultiBall*/, 1 /*RLBot.Flat.MultiBallMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*Overtime*/, 1 /*RLBot.Flat.OvertimeMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 12 /*SeriesLength*/, 1 /*RLBot.Flat.SeriesLengthMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 14 /*GameSpeed*/, 1 /*RLBot.Flat.GameSpeedMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 16 /*BallMaxSpeed*/, 1 /*RLBot.Flat.BallMaxSpeedMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 18 /*BallType*/, 1 /*RLBot.Flat.BallTypeMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 20 /*BallWeight*/, 1 /*RLBot.Flat.BallWeightMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 22 /*BallSize*/, 1 /*RLBot.Flat.BallSizeMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 24 /*BallBounciness*/, 1 /*RLBot.Flat.BallBouncinessMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 26 /*BoostAmount*/, 1 /*RLBot.Flat.BoostAmountMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 28 /*Rumble*/, 1 /*RLBot.Flat.RumbleMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 30 /*BoostStrength*/, 1 /*RLBot.Flat.BoostStrengthMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 32 /*Gravity*/, 1 /*RLBot.Flat.GravityMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 34 /*Demolish*/, 1 /*RLBot.Flat.DemolishMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 36 /*RespawnTime*/, 1 /*RLBot.Flat.RespawnTimeMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 38 /*MaxTime*/, 1 /*RLBot.Flat.MaxTimeMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 40 /*GameEvent*/, 1 /*RLBot.Flat.GameEventMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 42 /*Audio*/, 1 /*RLBot.Flat.AudioMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 44 /*BallGravity*/, 1 /*RLBot.Flat.BallGravityMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 46 /*Territory*/, 1 /*RLBot.Flat.TerritoryMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 48 /*StaleBall*/, 1 /*RLBot.Flat.StaleBallMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 50 /*Jump*/, 1 /*RLBot.Flat.JumpMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 52 /*DodgeTimer*/, 1 /*RLBot.Flat.DodgeTimerMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 54 /*PossessionScore*/, 1 /*RLBot.Flat.PossessionScoreMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 56 /*DemolishScore*/, 1 /*RLBot.Flat.DemolishScoreMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 58 /*NormalGoalScore*/, 1 /*RLBot.Flat.NormalGoalScoreMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 60 /*AerialGoalScore*/, 1 /*RLBot.Flat.AerialGoalScoreMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 62 /*AssistGoalScore*/, 1 /*RLBot.Flat.AssistGoalScoreMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 64 /*InputRestriction*/, 1 /*RLBot.Flat.InputRestrictionMutator*/, 1, false)
      && verifier.VerifyField(tablePos, 66 /*ScoringRule*/, 1 /*RLBot.Flat.ScoringRule*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A ScriptConfiguration defines a script of a match.
public struct ScriptConfiguration : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static ScriptConfiguration GetRootAsScriptConfiguration(ByteBuffer _bb) { return GetRootAsScriptConfiguration(_bb, new ScriptConfiguration()); }
  public static ScriptConfiguration GetRootAsScriptConfiguration(ByteBuffer _bb, ScriptConfiguration obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ScriptConfiguration __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The name of the script.
  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(4); }
  /// The root directory of the script and the working directory for the run command.
  public string RootDir { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetRootDirBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetRootDirBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetRootDirArray() { return __p.__vector_as_array<byte>(6); }
  /// A console command that will start up the script.
  public string RunCommand { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetRunCommandBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetRunCommandBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetRunCommandArray() { return __p.__vector_as_array<byte>(8); }
  /// The id of the script.
  /// This value is mostly used internally to keep track of participants in the match.
  public int ScriptId { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// A unique user-defined string that is used to connect clients to the right players/scripts.
  /// If a bot/script has a run command, RLBot will pass this agent id to the process using an environment variable, RLBOT_AGENT_ID.
  /// Upon connecting the process announces that it is responsible for this agent id and RLBot will pair the two.
  /// The recommended format for agent ids is "developername/botname".
  public string AgentId { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAgentIdBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetAgentIdBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetAgentIdArray() { return __p.__vector_as_array<byte>(12); }

  public static Offset<RLBot.Flat.ScriptConfiguration> CreateScriptConfiguration(FlatBufferBuilder builder,
      StringOffset nameOffset = default(StringOffset),
      StringOffset root_dirOffset = default(StringOffset),
      StringOffset run_commandOffset = default(StringOffset),
      int script_id = 0,
      StringOffset agent_idOffset = default(StringOffset)) {
    builder.StartTable(5);
    ScriptConfiguration.AddAgentId(builder, agent_idOffset);
    ScriptConfiguration.AddScriptId(builder, script_id);
    ScriptConfiguration.AddRunCommand(builder, run_commandOffset);
    ScriptConfiguration.AddRootDir(builder, root_dirOffset);
    ScriptConfiguration.AddName(builder, nameOffset);
    return ScriptConfiguration.EndScriptConfiguration(builder);
  }

  public static void StartScriptConfiguration(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }
  public static void AddRootDir(FlatBufferBuilder builder, StringOffset rootDirOffset) { builder.AddOffset(1, rootDirOffset.Value, 0); }
  public static void AddRunCommand(FlatBufferBuilder builder, StringOffset runCommandOffset) { builder.AddOffset(2, runCommandOffset.Value, 0); }
  public static void AddScriptId(FlatBufferBuilder builder, int scriptId) { builder.AddInt(3, scriptId, 0); }
  public static void AddAgentId(FlatBufferBuilder builder, StringOffset agentIdOffset) { builder.AddOffset(4, agentIdOffset.Value, 0); }
  public static Offset<RLBot.Flat.ScriptConfiguration> EndScriptConfiguration(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // name
    builder.Required(o, 6);  // root_dir
    builder.Required(o, 8);  // run_command
    builder.Required(o, 12);  // agent_id
    return new Offset<RLBot.Flat.ScriptConfiguration>(o);
  }
  public ScriptConfigurationT UnPack() {
    var _o = new ScriptConfigurationT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(ScriptConfigurationT _o) {
    _o.Name = this.Name;
    _o.RootDir = this.RootDir;
    _o.RunCommand = this.RunCommand;
    _o.ScriptId = this.ScriptId;
    _o.AgentId = this.AgentId;
  }
  public static Offset<RLBot.Flat.ScriptConfiguration> Pack(FlatBufferBuilder builder, ScriptConfigurationT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.ScriptConfiguration>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _root_dir = _o.RootDir == null ? default(StringOffset) : builder.CreateString(_o.RootDir);
    var _run_command = _o.RunCommand == null ? default(StringOffset) : builder.CreateString(_o.RunCommand);
    var _agent_id = _o.AgentId == null ? default(StringOffset) : builder.CreateString(_o.AgentId);
    return CreateScriptConfiguration(
      builder,
      _name,
      _root_dir,
      _run_command,
      _o.ScriptId,
      _agent_id);
  }
}

public class ScriptConfigurationT
{
  public string Name { get; set; }
  public string RootDir { get; set; }
  public string RunCommand { get; set; }
  public int ScriptId { get; set; }
  public string AgentId { get; set; }

  public ScriptConfigurationT() {
    this.Name = null;
    this.RootDir = null;
    this.RunCommand = null;
    this.ScriptId = 0;
    this.AgentId = null;
  }
}


static public class ScriptConfigurationVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Name*/, true)
      && verifier.VerifyString(tablePos, 6 /*RootDir*/, true)
      && verifier.VerifyString(tablePos, 8 /*RunCommand*/, true)
      && verifier.VerifyField(tablePos, 10 /*ScriptId*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 12 /*AgentId*/, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Definition of a match.
/// Can be sent to RLBot to request the start of a match.
public struct MatchConfiguration : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static MatchConfiguration GetRootAsMatchConfiguration(ByteBuffer _bb) { return GetRootAsMatchConfiguration(_bb, new MatchConfiguration()); }
  public static MatchConfiguration GetRootAsMatchConfiguration(ByteBuffer _bb, MatchConfiguration obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public MatchConfiguration __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// How to launch Rocket League.
  /// If left unset, RLBot will not launch the game.
  /// To use Legendary, use Custom and set launcher_arg="legendary".
  public RLBot.Flat.Launcher Launcher { get { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.Launcher)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.Launcher.Steam; } }
  /// Additional configuration for the launching method.
  /// See launcher.
  public string LauncherArg { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLauncherArgBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetLauncherArgBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetLauncherArgArray() { return __p.__vector_as_array<byte>(6); }
  /// If true, RLBot will start the bots and scripts that has a non-empty run command in their player/script configuration.
  public bool AutoStartAgents { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)true; } }
  /// If true, RLBot will start the match only once all bots and script have connected and are ready.
  /// If false, the match will start as soon as the map loads.
  public bool WaitForAgents { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)true; } }
  /// The name of a upk file, like UtopiaStadium_P, which should be loaded.
  /// On Steam version of Rocket League this can be used to load custom map files,
  /// but on Epic version it only works on the Psyonix maps.
  /// Available maps can be found here: https://github.com/VirxEC/python-interface/blob/master/rlbot/utils/maps.py
  public string GameMapUpk { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetGameMapUpkBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetGameMapUpkBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetGameMapUpkArray() { return __p.__vector_as_array<byte>(12); }
  /// The players in the match.
  public RLBot.Flat.PlayerConfiguration? PlayerConfigurations(int j) { int o = __p.__offset(14); return o != 0 ? (RLBot.Flat.PlayerConfiguration?)(new RLBot.Flat.PlayerConfiguration()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int PlayerConfigurationsLength { get { int o = __p.__offset(14); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The custom scripts used in the match.
  public RLBot.Flat.ScriptConfiguration? ScriptConfigurations(int j) { int o = __p.__offset(16); return o != 0 ? (RLBot.Flat.ScriptConfiguration?)(new RLBot.Flat.ScriptConfiguration()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int ScriptConfigurationsLength { get { int o = __p.__offset(16); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The game mode.
  /// This affects a few of the game rules although many game modes can also be recreated solely from mutators.
  /// See what mutators and game mode combinations make up the official modes at https://github.com/VirxEC/python-interface/tree/master/tests/gamemodes
  public RLBot.Flat.GameMode GameMode { get { int o = __p.__offset(18); return o != 0 ? (RLBot.Flat.GameMode)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.GameMode.Soccar; } }
  /// Whether to skip goal replays.
  public bool SkipReplays { get { int o = __p.__offset(20); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Whether to start without a kickoff countdown.
  public bool InstantStart { get { int o = __p.__offset(22); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Mutator settings.
  public RLBot.Flat.MutatorSettings? Mutators { get { int o = __p.__offset(24); return o != 0 ? (RLBot.Flat.MutatorSettings?)(new RLBot.Flat.MutatorSettings()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// How to handle any ongoing match.
  public RLBot.Flat.ExistingMatchBehavior ExistingMatchBehavior { get { int o = __p.__offset(26); return o != 0 ? (RLBot.Flat.ExistingMatchBehavior)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.ExistingMatchBehavior.Restart; } }
  /// Whether debug rendering is displayed.
  public RLBot.Flat.DebugRendering EnableRendering { get { int o = __p.__offset(28); return o != 0 ? (RLBot.Flat.DebugRendering)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.DebugRendering.OffByDefault; } }
  /// Whether clients are allowed to manipulate the game state, e.g. teleporting cars and ball.
  public bool EnableStateSetting { get { int o = __p.__offset(30); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)true; } }
  /// Whether the match replay should be saved.
  public bool AutoSaveReplay { get { int o = __p.__offset(32); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// If set to true, a free play match is launched instead of an exhibition match.
  /// This allows the players to use training keybinds, Bakkesmod plugins, and other features that are only allowed in free play.
  public bool Freeplay { get { int o = __p.__offset(34); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<RLBot.Flat.MatchConfiguration> CreateMatchConfiguration(FlatBufferBuilder builder,
      RLBot.Flat.Launcher launcher = RLBot.Flat.Launcher.Steam,
      StringOffset launcher_argOffset = default(StringOffset),
      bool auto_start_agents = true,
      bool wait_for_agents = true,
      StringOffset game_map_upkOffset = default(StringOffset),
      VectorOffset player_configurationsOffset = default(VectorOffset),
      VectorOffset script_configurationsOffset = default(VectorOffset),
      RLBot.Flat.GameMode game_mode = RLBot.Flat.GameMode.Soccar,
      bool skip_replays = false,
      bool instant_start = false,
      Offset<RLBot.Flat.MutatorSettings> mutatorsOffset = default(Offset<RLBot.Flat.MutatorSettings>),
      RLBot.Flat.ExistingMatchBehavior existing_match_behavior = RLBot.Flat.ExistingMatchBehavior.Restart,
      RLBot.Flat.DebugRendering enable_rendering = RLBot.Flat.DebugRendering.OffByDefault,
      bool enable_state_setting = true,
      bool auto_save_replay = false,
      bool freeplay = false) {
    builder.StartTable(16);
    MatchConfiguration.AddMutators(builder, mutatorsOffset);
    MatchConfiguration.AddScriptConfigurations(builder, script_configurationsOffset);
    MatchConfiguration.AddPlayerConfigurations(builder, player_configurationsOffset);
    MatchConfiguration.AddGameMapUpk(builder, game_map_upkOffset);
    MatchConfiguration.AddLauncherArg(builder, launcher_argOffset);
    MatchConfiguration.AddFreeplay(builder, freeplay);
    MatchConfiguration.AddAutoSaveReplay(builder, auto_save_replay);
    MatchConfiguration.AddEnableStateSetting(builder, enable_state_setting);
    MatchConfiguration.AddEnableRendering(builder, enable_rendering);
    MatchConfiguration.AddExistingMatchBehavior(builder, existing_match_behavior);
    MatchConfiguration.AddInstantStart(builder, instant_start);
    MatchConfiguration.AddSkipReplays(builder, skip_replays);
    MatchConfiguration.AddGameMode(builder, game_mode);
    MatchConfiguration.AddWaitForAgents(builder, wait_for_agents);
    MatchConfiguration.AddAutoStartAgents(builder, auto_start_agents);
    MatchConfiguration.AddLauncher(builder, launcher);
    return MatchConfiguration.EndMatchConfiguration(builder);
  }

  public static void StartMatchConfiguration(FlatBufferBuilder builder) { builder.StartTable(16); }
  public static void AddLauncher(FlatBufferBuilder builder, RLBot.Flat.Launcher launcher) { builder.AddByte(0, (byte)launcher, 0); }
  public static void AddLauncherArg(FlatBufferBuilder builder, StringOffset launcherArgOffset) { builder.AddOffset(1, launcherArgOffset.Value, 0); }
  public static void AddAutoStartAgents(FlatBufferBuilder builder, bool autoStartAgents) { builder.AddBool(2, autoStartAgents, true); }
  public static void AddWaitForAgents(FlatBufferBuilder builder, bool waitForAgents) { builder.AddBool(3, waitForAgents, true); }
  public static void AddGameMapUpk(FlatBufferBuilder builder, StringOffset gameMapUpkOffset) { builder.AddOffset(4, gameMapUpkOffset.Value, 0); }
  public static void AddPlayerConfigurations(FlatBufferBuilder builder, VectorOffset playerConfigurationsOffset) { builder.AddOffset(5, playerConfigurationsOffset.Value, 0); }
  public static VectorOffset CreatePlayerConfigurationsVector(FlatBufferBuilder builder, Offset<RLBot.Flat.PlayerConfiguration>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreatePlayerConfigurationsVectorBlock(FlatBufferBuilder builder, Offset<RLBot.Flat.PlayerConfiguration>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePlayerConfigurationsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<RLBot.Flat.PlayerConfiguration>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePlayerConfigurationsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<RLBot.Flat.PlayerConfiguration>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPlayerConfigurationsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddScriptConfigurations(FlatBufferBuilder builder, VectorOffset scriptConfigurationsOffset) { builder.AddOffset(6, scriptConfigurationsOffset.Value, 0); }
  public static VectorOffset CreateScriptConfigurationsVector(FlatBufferBuilder builder, Offset<RLBot.Flat.ScriptConfiguration>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateScriptConfigurationsVectorBlock(FlatBufferBuilder builder, Offset<RLBot.Flat.ScriptConfiguration>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateScriptConfigurationsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<RLBot.Flat.ScriptConfiguration>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateScriptConfigurationsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<RLBot.Flat.ScriptConfiguration>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartScriptConfigurationsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddGameMode(FlatBufferBuilder builder, RLBot.Flat.GameMode gameMode) { builder.AddByte(7, (byte)gameMode, 0); }
  public static void AddSkipReplays(FlatBufferBuilder builder, bool skipReplays) { builder.AddBool(8, skipReplays, false); }
  public static void AddInstantStart(FlatBufferBuilder builder, bool instantStart) { builder.AddBool(9, instantStart, false); }
  public static void AddMutators(FlatBufferBuilder builder, Offset<RLBot.Flat.MutatorSettings> mutatorsOffset) { builder.AddOffset(10, mutatorsOffset.Value, 0); }
  public static void AddExistingMatchBehavior(FlatBufferBuilder builder, RLBot.Flat.ExistingMatchBehavior existingMatchBehavior) { builder.AddByte(11, (byte)existingMatchBehavior, 0); }
  public static void AddEnableRendering(FlatBufferBuilder builder, RLBot.Flat.DebugRendering enableRendering) { builder.AddByte(12, (byte)enableRendering, 0); }
  public static void AddEnableStateSetting(FlatBufferBuilder builder, bool enableStateSetting) { builder.AddBool(13, enableStateSetting, true); }
  public static void AddAutoSaveReplay(FlatBufferBuilder builder, bool autoSaveReplay) { builder.AddBool(14, autoSaveReplay, false); }
  public static void AddFreeplay(FlatBufferBuilder builder, bool freeplay) { builder.AddBool(15, freeplay, false); }
  public static Offset<RLBot.Flat.MatchConfiguration> EndMatchConfiguration(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 6);  // launcher_arg
    builder.Required(o, 12);  // game_map_upk
    builder.Required(o, 14);  // player_configurations
    builder.Required(o, 16);  // script_configurations
    return new Offset<RLBot.Flat.MatchConfiguration>(o);
  }
  public MatchConfigurationT UnPack() {
    var _o = new MatchConfigurationT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(MatchConfigurationT _o) {
    _o.Launcher = this.Launcher;
    _o.LauncherArg = this.LauncherArg;
    _o.AutoStartAgents = this.AutoStartAgents;
    _o.WaitForAgents = this.WaitForAgents;
    _o.GameMapUpk = this.GameMapUpk;
    _o.PlayerConfigurations = new List<RLBot.Flat.PlayerConfigurationT>();
    for (var _j = 0; _j < this.PlayerConfigurationsLength; ++_j) {_o.PlayerConfigurations.Add(this.PlayerConfigurations(_j).HasValue ? this.PlayerConfigurations(_j).Value.UnPack() : null);}
    _o.ScriptConfigurations = new List<RLBot.Flat.ScriptConfigurationT>();
    for (var _j = 0; _j < this.ScriptConfigurationsLength; ++_j) {_o.ScriptConfigurations.Add(this.ScriptConfigurations(_j).HasValue ? this.ScriptConfigurations(_j).Value.UnPack() : null);}
    _o.GameMode = this.GameMode;
    _o.SkipReplays = this.SkipReplays;
    _o.InstantStart = this.InstantStart;
    _o.Mutators = this.Mutators.HasValue ? this.Mutators.Value.UnPack() : null;
    _o.ExistingMatchBehavior = this.ExistingMatchBehavior;
    _o.EnableRendering = this.EnableRendering;
    _o.EnableStateSetting = this.EnableStateSetting;
    _o.AutoSaveReplay = this.AutoSaveReplay;
    _o.Freeplay = this.Freeplay;
  }
  public static Offset<RLBot.Flat.MatchConfiguration> Pack(FlatBufferBuilder builder, MatchConfigurationT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.MatchConfiguration>);
    var _launcher_arg = _o.LauncherArg == null ? default(StringOffset) : builder.CreateString(_o.LauncherArg);
    var _game_map_upk = _o.GameMapUpk == null ? default(StringOffset) : builder.CreateString(_o.GameMapUpk);
    var _player_configurations = default(VectorOffset);
    if (_o.PlayerConfigurations != null) {
      var __player_configurations = new Offset<RLBot.Flat.PlayerConfiguration>[_o.PlayerConfigurations.Count];
      for (var _j = 0; _j < __player_configurations.Length; ++_j) { __player_configurations[_j] = RLBot.Flat.PlayerConfiguration.Pack(builder, _o.PlayerConfigurations[_j]); }
      _player_configurations = CreatePlayerConfigurationsVector(builder, __player_configurations);
    }
    var _script_configurations = default(VectorOffset);
    if (_o.ScriptConfigurations != null) {
      var __script_configurations = new Offset<RLBot.Flat.ScriptConfiguration>[_o.ScriptConfigurations.Count];
      for (var _j = 0; _j < __script_configurations.Length; ++_j) { __script_configurations[_j] = RLBot.Flat.ScriptConfiguration.Pack(builder, _o.ScriptConfigurations[_j]); }
      _script_configurations = CreateScriptConfigurationsVector(builder, __script_configurations);
    }
    var _mutators = _o.Mutators == null ? default(Offset<RLBot.Flat.MutatorSettings>) : RLBot.Flat.MutatorSettings.Pack(builder, _o.Mutators);
    return CreateMatchConfiguration(
      builder,
      _o.Launcher,
      _launcher_arg,
      _o.AutoStartAgents,
      _o.WaitForAgents,
      _game_map_upk,
      _player_configurations,
      _script_configurations,
      _o.GameMode,
      _o.SkipReplays,
      _o.InstantStart,
      _mutators,
      _o.ExistingMatchBehavior,
      _o.EnableRendering,
      _o.EnableStateSetting,
      _o.AutoSaveReplay,
      _o.Freeplay);
  }
}

public class MatchConfigurationT
{
  public RLBot.Flat.Launcher Launcher { get; set; }
  public string LauncherArg { get; set; }
  public bool AutoStartAgents { get; set; }
  public bool WaitForAgents { get; set; }
  public string GameMapUpk { get; set; }
  public List<RLBot.Flat.PlayerConfigurationT> PlayerConfigurations { get; set; }
  public List<RLBot.Flat.ScriptConfigurationT> ScriptConfigurations { get; set; }
  public RLBot.Flat.GameMode GameMode { get; set; }
  public bool SkipReplays { get; set; }
  public bool InstantStart { get; set; }
  public RLBot.Flat.MutatorSettingsT Mutators { get; set; }
  public RLBot.Flat.ExistingMatchBehavior ExistingMatchBehavior { get; set; }
  public RLBot.Flat.DebugRendering EnableRendering { get; set; }
  public bool EnableStateSetting { get; set; }
  public bool AutoSaveReplay { get; set; }
  public bool Freeplay { get; set; }

  public MatchConfigurationT() {
    this.Launcher = RLBot.Flat.Launcher.Steam;
    this.LauncherArg = null;
    this.AutoStartAgents = true;
    this.WaitForAgents = true;
    this.GameMapUpk = null;
    this.PlayerConfigurations = null;
    this.ScriptConfigurations = null;
    this.GameMode = RLBot.Flat.GameMode.Soccar;
    this.SkipReplays = false;
    this.InstantStart = false;
    this.Mutators = null;
    this.ExistingMatchBehavior = RLBot.Flat.ExistingMatchBehavior.Restart;
    this.EnableRendering = RLBot.Flat.DebugRendering.OffByDefault;
    this.EnableStateSetting = true;
    this.AutoSaveReplay = false;
    this.Freeplay = false;
  }
}


static public class MatchConfigurationVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Launcher*/, 1 /*RLBot.Flat.Launcher*/, 1, false)
      && verifier.VerifyString(tablePos, 6 /*LauncherArg*/, true)
      && verifier.VerifyField(tablePos, 8 /*AutoStartAgents*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*WaitForAgents*/, 1 /*bool*/, 1, false)
      && verifier.VerifyString(tablePos, 12 /*GameMapUpk*/, true)
      && verifier.VerifyVectorOfTables(tablePos, 14 /*PlayerConfigurations*/, RLBot.Flat.PlayerConfigurationVerify.Verify, true)
      && verifier.VerifyVectorOfTables(tablePos, 16 /*ScriptConfigurations*/, RLBot.Flat.ScriptConfigurationVerify.Verify, true)
      && verifier.VerifyField(tablePos, 18 /*GameMode*/, 1 /*RLBot.Flat.GameMode*/, 1, false)
      && verifier.VerifyField(tablePos, 20 /*SkipReplays*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 22 /*InstantStart*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTable(tablePos, 24 /*Mutators*/, RLBot.Flat.MutatorSettingsVerify.Verify, false)
      && verifier.VerifyField(tablePos, 26 /*ExistingMatchBehavior*/, 1 /*RLBot.Flat.ExistingMatchBehavior*/, 1, false)
      && verifier.VerifyField(tablePos, 28 /*EnableRendering*/, 1 /*RLBot.Flat.DebugRendering*/, 1, false)
      && verifier.VerifyField(tablePos, 30 /*EnableStateSetting*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 32 /*AutoSaveReplay*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 34 /*Freeplay*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A RenderAnchor attached to a ball.
/// The local field allows for an offset in local coordinates taking the ball's orientation into account.
public struct BallAnchor : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static BallAnchor GetRootAsBallAnchor(ByteBuffer _bb) { return GetRootAsBallAnchor(_bb, new BallAnchor()); }
  public static BallAnchor GetRootAsBallAnchor(ByteBuffer _bb, BallAnchor obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BallAnchor __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The index of the ball.
  public uint Index { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  /// An offset in local coordinates.
  /// x is forwards, y is left, and z is up.
  public RLBot.Flat.Vector3? Local { get { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.Vector3?)(new RLBot.Flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static Offset<RLBot.Flat.BallAnchor> CreateBallAnchor(FlatBufferBuilder builder,
      uint index = 0,
      RLBot.Flat.Vector3T local = null) {
    builder.StartTable(2);
    BallAnchor.AddLocal(builder, RLBot.Flat.Vector3.Pack(builder, local));
    BallAnchor.AddIndex(builder, index);
    return BallAnchor.EndBallAnchor(builder);
  }

  public static void StartBallAnchor(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddIndex(FlatBufferBuilder builder, uint index) { builder.AddUint(0, index, 0); }
  public static void AddLocal(FlatBufferBuilder builder, Offset<RLBot.Flat.Vector3> localOffset) { builder.AddStruct(1, localOffset.Value, 0); }
  public static Offset<RLBot.Flat.BallAnchor> EndBallAnchor(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 6);  // local
    return new Offset<RLBot.Flat.BallAnchor>(o);
  }
  public BallAnchorT UnPack() {
    var _o = new BallAnchorT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(BallAnchorT _o) {
    _o.Index = this.Index;
    _o.Local = this.Local.HasValue ? this.Local.Value.UnPack() : null;
  }
  public static Offset<RLBot.Flat.BallAnchor> Pack(FlatBufferBuilder builder, BallAnchorT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.BallAnchor>);
    return CreateBallAnchor(
      builder,
      _o.Index,
      _o.Local);
  }
}

public class BallAnchorT
{
  public uint Index { get; set; }
  public RLBot.Flat.Vector3T Local { get; set; }

  public BallAnchorT() {
    this.Index = 0;
    this.Local = new RLBot.Flat.Vector3T();
  }
}


static public class BallAnchorVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Index*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Local*/, 12 /*RLBot.Flat.Vector3*/, 4, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A RenderAnchor attached to a car.
/// The local field allows for an offset in local coordinates taking the car's orientation into account.
public struct CarAnchor : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static CarAnchor GetRootAsCarAnchor(ByteBuffer _bb) { return GetRootAsCarAnchor(_bb, new CarAnchor()); }
  public static CarAnchor GetRootAsCarAnchor(ByteBuffer _bb, CarAnchor obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public CarAnchor __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The index of the car.
  public uint Index { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  /// An offset in local coordinates.
  /// x is forwards, y is left, and z is up.
  public RLBot.Flat.Vector3? Local { get { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.Vector3?)(new RLBot.Flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static Offset<RLBot.Flat.CarAnchor> CreateCarAnchor(FlatBufferBuilder builder,
      uint index = 0,
      RLBot.Flat.Vector3T local = null) {
    builder.StartTable(2);
    CarAnchor.AddLocal(builder, RLBot.Flat.Vector3.Pack(builder, local));
    CarAnchor.AddIndex(builder, index);
    return CarAnchor.EndCarAnchor(builder);
  }

  public static void StartCarAnchor(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddIndex(FlatBufferBuilder builder, uint index) { builder.AddUint(0, index, 0); }
  public static void AddLocal(FlatBufferBuilder builder, Offset<RLBot.Flat.Vector3> localOffset) { builder.AddStruct(1, localOffset.Value, 0); }
  public static Offset<RLBot.Flat.CarAnchor> EndCarAnchor(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 6);  // local
    return new Offset<RLBot.Flat.CarAnchor>(o);
  }
  public CarAnchorT UnPack() {
    var _o = new CarAnchorT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(CarAnchorT _o) {
    _o.Index = this.Index;
    _o.Local = this.Local.HasValue ? this.Local.Value.UnPack() : null;
  }
  public static Offset<RLBot.Flat.CarAnchor> Pack(FlatBufferBuilder builder, CarAnchorT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.CarAnchor>);
    return CreateCarAnchor(
      builder,
      _o.Index,
      _o.Local);
  }
}

public class CarAnchorT
{
  public uint Index { get; set; }
  public RLBot.Flat.Vector3T Local { get; set; }

  public CarAnchorT() {
    this.Index = 0;
    this.Local = new RLBot.Flat.Vector3T();
  }
}


static public class CarAnchorVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Index*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Local*/, 12 /*RLBot.Flat.Vector3*/, 4, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A RenderAnchor is a point in space consisting of a world component and optionally a relative component.
/// The relative component is given by a car or ball and includes a local offset that takes the orientation of the object into account.
/// The RenderAnchor stays attached to the object and does not have to be updated each tick.
/// Rendering that uses a RenderAnchor attached to an object disappears if the object is destroyed, i.e. the car demolished or the ball is scored.
public struct RenderAnchor : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static RenderAnchor GetRootAsRenderAnchor(ByteBuffer _bb) { return GetRootAsRenderAnchor(_bb, new RenderAnchor()); }
  public static RenderAnchor GetRootAsRenderAnchor(ByteBuffer _bb, RenderAnchor obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RenderAnchor __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// An offset in global coordinates.
  /// If the relative component is null, then this simply a point in 3D space.
  public RLBot.Flat.Vector3? World { get { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.Vector3?)(new RLBot.Flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public RLBot.Flat.RelativeAnchor RelativeType { get { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.RelativeAnchor)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.RelativeAnchor.NONE; } }
  /// An optional offset given by the position of an object and includes a local offset that takes the object's orientation into account.
  public TTable? Relative<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(8); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public RLBot.Flat.BallAnchor RelativeAsBallAnchor() { return Relative<RLBot.Flat.BallAnchor>().Value; }
  public RLBot.Flat.CarAnchor RelativeAsCarAnchor() { return Relative<RLBot.Flat.CarAnchor>().Value; }

  public static Offset<RLBot.Flat.RenderAnchor> CreateRenderAnchor(FlatBufferBuilder builder,
      RLBot.Flat.Vector3T world = null,
      RLBot.Flat.RelativeAnchor relative_type = RLBot.Flat.RelativeAnchor.NONE,
      int relativeOffset = 0) {
    builder.StartTable(3);
    RenderAnchor.AddRelative(builder, relativeOffset);
    RenderAnchor.AddWorld(builder, RLBot.Flat.Vector3.Pack(builder, world));
    RenderAnchor.AddRelativeType(builder, relative_type);
    return RenderAnchor.EndRenderAnchor(builder);
  }

  public static void StartRenderAnchor(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddWorld(FlatBufferBuilder builder, Offset<RLBot.Flat.Vector3> worldOffset) { builder.AddStruct(0, worldOffset.Value, 0); }
  public static void AddRelativeType(FlatBufferBuilder builder, RLBot.Flat.RelativeAnchor relativeType) { builder.AddByte(1, (byte)relativeType, 0); }
  public static void AddRelative(FlatBufferBuilder builder, int relativeOffset) { builder.AddOffset(2, relativeOffset, 0); }
  public static Offset<RLBot.Flat.RenderAnchor> EndRenderAnchor(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // world
    return new Offset<RLBot.Flat.RenderAnchor>(o);
  }
  public RenderAnchorT UnPack() {
    var _o = new RenderAnchorT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(RenderAnchorT _o) {
    _o.World = this.World.HasValue ? this.World.Value.UnPack() : null;
    _o.Relative = new RLBot.Flat.RelativeAnchorUnion();
    _o.Relative.Type = this.RelativeType;
    switch (this.RelativeType) {
      default: break;
      case RLBot.Flat.RelativeAnchor.BallAnchor:
        _o.Relative.Value = this.Relative<RLBot.Flat.BallAnchor>().HasValue ? this.Relative<RLBot.Flat.BallAnchor>().Value.UnPack() : null;
        break;
      case RLBot.Flat.RelativeAnchor.CarAnchor:
        _o.Relative.Value = this.Relative<RLBot.Flat.CarAnchor>().HasValue ? this.Relative<RLBot.Flat.CarAnchor>().Value.UnPack() : null;
        break;
    }
  }
  public static Offset<RLBot.Flat.RenderAnchor> Pack(FlatBufferBuilder builder, RenderAnchorT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.RenderAnchor>);
    var _relative_type = _o.Relative == null ? RLBot.Flat.RelativeAnchor.NONE : _o.Relative.Type;
    var _relative = _o.Relative == null ? 0 : RLBot.Flat.RelativeAnchorUnion.Pack(builder, _o.Relative);
    return CreateRenderAnchor(
      builder,
      _o.World,
      _relative_type,
      _relative);
  }
}

public class RenderAnchorT
{
  public RLBot.Flat.Vector3T World { get; set; }
  public RLBot.Flat.RelativeAnchorUnion Relative { get; set; }

  public RenderAnchorT() {
    this.World = new RLBot.Flat.Vector3T();
    this.Relative = null;
  }
}


static public class RenderAnchorVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*World*/, 12 /*RLBot.Flat.Vector3*/, 4, true)
      && verifier.VerifyField(tablePos, 6 /*RelativeType*/, 1 /*RLBot.Flat.RelativeAnchor*/, 1, false)
      && verifier.VerifyUnion(tablePos, 6, 8 /*Relative*/, RLBot.Flat.RelativeAnchorVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A RenderMessage for a line in 3D space between two RenderAnchors.
public struct Line3D : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static Line3D GetRootAsLine3D(ByteBuffer _bb) { return GetRootAsLine3D(_bb, new Line3D()); }
  public static Line3D GetRootAsLine3D(ByteBuffer _bb, Line3D obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Line3D __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public RLBot.Flat.RenderAnchor? Start { get { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.RenderAnchor?)(new RLBot.Flat.RenderAnchor()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public RLBot.Flat.RenderAnchor? End { get { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.RenderAnchor?)(new RLBot.Flat.RenderAnchor()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public RLBot.Flat.Color? Color { get { int o = __p.__offset(8); return o != 0 ? (RLBot.Flat.Color?)(new RLBot.Flat.Color()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static Offset<RLBot.Flat.Line3D> CreateLine3D(FlatBufferBuilder builder,
      Offset<RLBot.Flat.RenderAnchor> startOffset = default(Offset<RLBot.Flat.RenderAnchor>),
      Offset<RLBot.Flat.RenderAnchor> endOffset = default(Offset<RLBot.Flat.RenderAnchor>),
      RLBot.Flat.ColorT color = null) {
    builder.StartTable(3);
    Line3D.AddColor(builder, RLBot.Flat.Color.Pack(builder, color));
    Line3D.AddEnd(builder, endOffset);
    Line3D.AddStart(builder, startOffset);
    return Line3D.EndLine3D(builder);
  }

  public static void StartLine3D(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddStart(FlatBufferBuilder builder, Offset<RLBot.Flat.RenderAnchor> startOffset) { builder.AddOffset(0, startOffset.Value, 0); }
  public static void AddEnd(FlatBufferBuilder builder, Offset<RLBot.Flat.RenderAnchor> endOffset) { builder.AddOffset(1, endOffset.Value, 0); }
  public static void AddColor(FlatBufferBuilder builder, Offset<RLBot.Flat.Color> colorOffset) { builder.AddStruct(2, colorOffset.Value, 0); }
  public static Offset<RLBot.Flat.Line3D> EndLine3D(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // start
    builder.Required(o, 6);  // end
    builder.Required(o, 8);  // color
    return new Offset<RLBot.Flat.Line3D>(o);
  }
  public Line3DT UnPack() {
    var _o = new Line3DT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(Line3DT _o) {
    _o.Start = this.Start.HasValue ? this.Start.Value.UnPack() : null;
    _o.End = this.End.HasValue ? this.End.Value.UnPack() : null;
    _o.Color = this.Color.HasValue ? this.Color.Value.UnPack() : null;
  }
  public static Offset<RLBot.Flat.Line3D> Pack(FlatBufferBuilder builder, Line3DT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.Line3D>);
    var _start = _o.Start == null ? default(Offset<RLBot.Flat.RenderAnchor>) : RLBot.Flat.RenderAnchor.Pack(builder, _o.Start);
    var _end = _o.End == null ? default(Offset<RLBot.Flat.RenderAnchor>) : RLBot.Flat.RenderAnchor.Pack(builder, _o.End);
    return CreateLine3D(
      builder,
      _start,
      _end,
      _o.Color);
  }
}

public class Line3DT
{
  public RLBot.Flat.RenderAnchorT Start { get; set; }
  public RLBot.Flat.RenderAnchorT End { get; set; }
  public RLBot.Flat.ColorT Color { get; set; }

  public Line3DT() {
    this.Start = null;
    this.End = null;
    this.Color = new RLBot.Flat.ColorT();
  }
}


static public class Line3DVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTable(tablePos, 4 /*Start*/, RLBot.Flat.RenderAnchorVerify.Verify, true)
      && verifier.VerifyTable(tablePos, 6 /*End*/, RLBot.Flat.RenderAnchorVerify.Verify, true)
      && verifier.VerifyField(tablePos, 8 /*Color*/, 4 /*RLBot.Flat.Color*/, 1, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A RenderMessage for a line in 3D space going through a series of points.
public struct PolyLine3D : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static PolyLine3D GetRootAsPolyLine3D(ByteBuffer _bb) { return GetRootAsPolyLine3D(_bb, new PolyLine3D()); }
  public static PolyLine3D GetRootAsPolyLine3D(ByteBuffer _bb, PolyLine3D obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PolyLine3D __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public RLBot.Flat.Vector3? Points(int j) { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.Vector3?)(new RLBot.Flat.Vector3()).__assign(__p.__vector(o) + j * 12, __p.bb) : null; }
  public int PointsLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
  public RLBot.Flat.Color? Color { get { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.Color?)(new RLBot.Flat.Color()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static Offset<RLBot.Flat.PolyLine3D> CreatePolyLine3D(FlatBufferBuilder builder,
      VectorOffset pointsOffset = default(VectorOffset),
      RLBot.Flat.ColorT color = null) {
    builder.StartTable(2);
    PolyLine3D.AddColor(builder, RLBot.Flat.Color.Pack(builder, color));
    PolyLine3D.AddPoints(builder, pointsOffset);
    return PolyLine3D.EndPolyLine3D(builder);
  }

  public static void StartPolyLine3D(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddPoints(FlatBufferBuilder builder, VectorOffset pointsOffset) { builder.AddOffset(0, pointsOffset.Value, 0); }
  public static void StartPointsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(12, numElems, 4); }
  public static void AddColor(FlatBufferBuilder builder, Offset<RLBot.Flat.Color> colorOffset) { builder.AddStruct(1, colorOffset.Value, 0); }
  public static Offset<RLBot.Flat.PolyLine3D> EndPolyLine3D(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // points
    builder.Required(o, 6);  // color
    return new Offset<RLBot.Flat.PolyLine3D>(o);
  }
  public PolyLine3DT UnPack() {
    var _o = new PolyLine3DT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(PolyLine3DT _o) {
    _o.Points = new List<RLBot.Flat.Vector3T>();
    for (var _j = 0; _j < this.PointsLength; ++_j) {_o.Points.Add(this.Points(_j).HasValue ? this.Points(_j).Value.UnPack() : null);}
    _o.Color = this.Color.HasValue ? this.Color.Value.UnPack() : null;
  }
  public static Offset<RLBot.Flat.PolyLine3D> Pack(FlatBufferBuilder builder, PolyLine3DT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.PolyLine3D>);
    var _points = default(VectorOffset);
    if (_o.Points != null) {
      StartPointsVector(builder, _o.Points.Count);
      for (var _j = _o.Points.Count - 1; _j >= 0; --_j) { RLBot.Flat.Vector3.Pack(builder, _o.Points[_j]); }
      _points = builder.EndVector();
    }
    return CreatePolyLine3D(
      builder,
      _points,
      _o.Color);
  }
}

public class PolyLine3DT
{
  public List<RLBot.Flat.Vector3T> Points { get; set; }
  public RLBot.Flat.ColorT Color { get; set; }

  public PolyLine3DT() {
    this.Points = null;
    this.Color = new RLBot.Flat.ColorT();
  }
}


static public class PolyLine3DVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*Points*/, 12 /*RLBot.Flat.Vector3*/, true)
      && verifier.VerifyField(tablePos, 6 /*Color*/, 4 /*RLBot.Flat.Color*/, 1, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A RenderMessage for text in 2D space.
/// Note that the position is given in screen-space coordinates.
public struct String2D : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static String2D GetRootAsString2D(ByteBuffer _bb) { return GetRootAsString2D(_bb, new String2D()); }
  public static String2D GetRootAsString2D(ByteBuffer _bb, String2D obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public String2D __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The text to be displayed.
  public string Text { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTextBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetTextBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetTextArray() { return __p.__vector_as_array<byte>(4); }
  /// Screen-space x coordinate such that x=0 is left edge and x=1 is right edge of window.
  public float X { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// Screen-space y coordinate such that y=0 is top edge and y=1 is bottom edge of window.
  public float Y { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// Scale of the text.
  /// When scale is 1, the characters are 20 pixels tall and 10 pixels wide.
  public float Scale { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// The color of the text.
  public RLBot.Flat.Color? Foreground { get { int o = __p.__offset(12); return o != 0 ? (RLBot.Flat.Color?)(new RLBot.Flat.Color()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// The color of the background for the text.
  public RLBot.Flat.Color? Background { get { int o = __p.__offset(14); return o != 0 ? (RLBot.Flat.Color?)(new RLBot.Flat.Color()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// The horizontal alignment of the text.
  public RLBot.Flat.TextHAlign HAlign { get { int o = __p.__offset(16); return o != 0 ? (RLBot.Flat.TextHAlign)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.TextHAlign.Left; } }
  /// The vertical alignment of the text.
  public RLBot.Flat.TextVAlign VAlign { get { int o = __p.__offset(18); return o != 0 ? (RLBot.Flat.TextVAlign)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.TextVAlign.Top; } }

  public static Offset<RLBot.Flat.String2D> CreateString2D(FlatBufferBuilder builder,
      StringOffset textOffset = default(StringOffset),
      float x = 0.0f,
      float y = 0.0f,
      float scale = 0.0f,
      RLBot.Flat.ColorT foreground = null,
      RLBot.Flat.ColorT background = null,
      RLBot.Flat.TextHAlign h_align = RLBot.Flat.TextHAlign.Left,
      RLBot.Flat.TextVAlign v_align = RLBot.Flat.TextVAlign.Top) {
    builder.StartTable(8);
    String2D.AddBackground(builder, RLBot.Flat.Color.Pack(builder, background));
    String2D.AddForeground(builder, RLBot.Flat.Color.Pack(builder, foreground));
    String2D.AddScale(builder, scale);
    String2D.AddY(builder, y);
    String2D.AddX(builder, x);
    String2D.AddText(builder, textOffset);
    String2D.AddVAlign(builder, v_align);
    String2D.AddHAlign(builder, h_align);
    return String2D.EndString2D(builder);
  }

  public static void StartString2D(FlatBufferBuilder builder) { builder.StartTable(8); }
  public static void AddText(FlatBufferBuilder builder, StringOffset textOffset) { builder.AddOffset(0, textOffset.Value, 0); }
  public static void AddX(FlatBufferBuilder builder, float x) { builder.AddFloat(1, x, 0.0f); }
  public static void AddY(FlatBufferBuilder builder, float y) { builder.AddFloat(2, y, 0.0f); }
  public static void AddScale(FlatBufferBuilder builder, float scale) { builder.AddFloat(3, scale, 0.0f); }
  public static void AddForeground(FlatBufferBuilder builder, Offset<RLBot.Flat.Color> foregroundOffset) { builder.AddStruct(4, foregroundOffset.Value, 0); }
  public static void AddBackground(FlatBufferBuilder builder, Offset<RLBot.Flat.Color> backgroundOffset) { builder.AddStruct(5, backgroundOffset.Value, 0); }
  public static void AddHAlign(FlatBufferBuilder builder, RLBot.Flat.TextHAlign hAlign) { builder.AddByte(6, (byte)hAlign, 0); }
  public static void AddVAlign(FlatBufferBuilder builder, RLBot.Flat.TextVAlign vAlign) { builder.AddByte(7, (byte)vAlign, 0); }
  public static Offset<RLBot.Flat.String2D> EndString2D(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // text
    builder.Required(o, 12);  // foreground
    builder.Required(o, 14);  // background
    return new Offset<RLBot.Flat.String2D>(o);
  }
  public String2DT UnPack() {
    var _o = new String2DT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(String2DT _o) {
    _o.Text = this.Text;
    _o.X = this.X;
    _o.Y = this.Y;
    _o.Scale = this.Scale;
    _o.Foreground = this.Foreground.HasValue ? this.Foreground.Value.UnPack() : null;
    _o.Background = this.Background.HasValue ? this.Background.Value.UnPack() : null;
    _o.HAlign = this.HAlign;
    _o.VAlign = this.VAlign;
  }
  public static Offset<RLBot.Flat.String2D> Pack(FlatBufferBuilder builder, String2DT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.String2D>);
    var _text = _o.Text == null ? default(StringOffset) : builder.CreateString(_o.Text);
    return CreateString2D(
      builder,
      _text,
      _o.X,
      _o.Y,
      _o.Scale,
      _o.Foreground,
      _o.Background,
      _o.HAlign,
      _o.VAlign);
  }
}

public class String2DT
{
  public string Text { get; set; }
  public float X { get; set; }
  public float Y { get; set; }
  public float Scale { get; set; }
  public RLBot.Flat.ColorT Foreground { get; set; }
  public RLBot.Flat.ColorT Background { get; set; }
  public RLBot.Flat.TextHAlign HAlign { get; set; }
  public RLBot.Flat.TextVAlign VAlign { get; set; }

  public String2DT() {
    this.Text = null;
    this.X = 0.0f;
    this.Y = 0.0f;
    this.Scale = 0.0f;
    this.Foreground = new RLBot.Flat.ColorT();
    this.Background = new RLBot.Flat.ColorT();
    this.HAlign = RLBot.Flat.TextHAlign.Left;
    this.VAlign = RLBot.Flat.TextVAlign.Top;
  }
}


static public class String2DVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Text*/, true)
      && verifier.VerifyField(tablePos, 6 /*X*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Y*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*Scale*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 12 /*Foreground*/, 4 /*RLBot.Flat.Color*/, 1, true)
      && verifier.VerifyField(tablePos, 14 /*Background*/, 4 /*RLBot.Flat.Color*/, 1, true)
      && verifier.VerifyField(tablePos, 16 /*HAlign*/, 1 /*RLBot.Flat.TextHAlign*/, 1, false)
      && verifier.VerifyField(tablePos, 18 /*VAlign*/, 1 /*RLBot.Flat.TextVAlign*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A RenderMessage for text in 3D space.
public struct String3D : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static String3D GetRootAsString3D(ByteBuffer _bb) { return GetRootAsString3D(_bb, new String3D()); }
  public static String3D GetRootAsString3D(ByteBuffer _bb, String3D obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public String3D __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The text to be displayed.
  public string Text { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTextBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetTextBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetTextArray() { return __p.__vector_as_array<byte>(4); }
  /// The position of the text.
  public RLBot.Flat.RenderAnchor? Anchor { get { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.RenderAnchor?)(new RLBot.Flat.RenderAnchor()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// The scale of the text.
  /// When scale is 1, the characters are 20 pixels tall and 10 pixels wide.
  public float Scale { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// The color of the text.
  public RLBot.Flat.Color? Foreground { get { int o = __p.__offset(10); return o != 0 ? (RLBot.Flat.Color?)(new RLBot.Flat.Color()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// The color of the background for the text.
  public RLBot.Flat.Color? Background { get { int o = __p.__offset(12); return o != 0 ? (RLBot.Flat.Color?)(new RLBot.Flat.Color()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// The horizontal alignment of the text.
  public RLBot.Flat.TextHAlign HAlign { get { int o = __p.__offset(14); return o != 0 ? (RLBot.Flat.TextHAlign)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.TextHAlign.Left; } }
  /// The vertical alignment of the text.
  public RLBot.Flat.TextVAlign VAlign { get { int o = __p.__offset(16); return o != 0 ? (RLBot.Flat.TextVAlign)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.TextVAlign.Top; } }

  public static Offset<RLBot.Flat.String3D> CreateString3D(FlatBufferBuilder builder,
      StringOffset textOffset = default(StringOffset),
      Offset<RLBot.Flat.RenderAnchor> anchorOffset = default(Offset<RLBot.Flat.RenderAnchor>),
      float scale = 0.0f,
      RLBot.Flat.ColorT foreground = null,
      RLBot.Flat.ColorT background = null,
      RLBot.Flat.TextHAlign h_align = RLBot.Flat.TextHAlign.Left,
      RLBot.Flat.TextVAlign v_align = RLBot.Flat.TextVAlign.Top) {
    builder.StartTable(7);
    String3D.AddBackground(builder, RLBot.Flat.Color.Pack(builder, background));
    String3D.AddForeground(builder, RLBot.Flat.Color.Pack(builder, foreground));
    String3D.AddScale(builder, scale);
    String3D.AddAnchor(builder, anchorOffset);
    String3D.AddText(builder, textOffset);
    String3D.AddVAlign(builder, v_align);
    String3D.AddHAlign(builder, h_align);
    return String3D.EndString3D(builder);
  }

  public static void StartString3D(FlatBufferBuilder builder) { builder.StartTable(7); }
  public static void AddText(FlatBufferBuilder builder, StringOffset textOffset) { builder.AddOffset(0, textOffset.Value, 0); }
  public static void AddAnchor(FlatBufferBuilder builder, Offset<RLBot.Flat.RenderAnchor> anchorOffset) { builder.AddOffset(1, anchorOffset.Value, 0); }
  public static void AddScale(FlatBufferBuilder builder, float scale) { builder.AddFloat(2, scale, 0.0f); }
  public static void AddForeground(FlatBufferBuilder builder, Offset<RLBot.Flat.Color> foregroundOffset) { builder.AddStruct(3, foregroundOffset.Value, 0); }
  public static void AddBackground(FlatBufferBuilder builder, Offset<RLBot.Flat.Color> backgroundOffset) { builder.AddStruct(4, backgroundOffset.Value, 0); }
  public static void AddHAlign(FlatBufferBuilder builder, RLBot.Flat.TextHAlign hAlign) { builder.AddByte(5, (byte)hAlign, 0); }
  public static void AddVAlign(FlatBufferBuilder builder, RLBot.Flat.TextVAlign vAlign) { builder.AddByte(6, (byte)vAlign, 0); }
  public static Offset<RLBot.Flat.String3D> EndString3D(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // text
    builder.Required(o, 6);  // anchor
    builder.Required(o, 10);  // foreground
    builder.Required(o, 12);  // background
    return new Offset<RLBot.Flat.String3D>(o);
  }
  public String3DT UnPack() {
    var _o = new String3DT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(String3DT _o) {
    _o.Text = this.Text;
    _o.Anchor = this.Anchor.HasValue ? this.Anchor.Value.UnPack() : null;
    _o.Scale = this.Scale;
    _o.Foreground = this.Foreground.HasValue ? this.Foreground.Value.UnPack() : null;
    _o.Background = this.Background.HasValue ? this.Background.Value.UnPack() : null;
    _o.HAlign = this.HAlign;
    _o.VAlign = this.VAlign;
  }
  public static Offset<RLBot.Flat.String3D> Pack(FlatBufferBuilder builder, String3DT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.String3D>);
    var _text = _o.Text == null ? default(StringOffset) : builder.CreateString(_o.Text);
    var _anchor = _o.Anchor == null ? default(Offset<RLBot.Flat.RenderAnchor>) : RLBot.Flat.RenderAnchor.Pack(builder, _o.Anchor);
    return CreateString3D(
      builder,
      _text,
      _anchor,
      _o.Scale,
      _o.Foreground,
      _o.Background,
      _o.HAlign,
      _o.VAlign);
  }
}

public class String3DT
{
  public string Text { get; set; }
  public RLBot.Flat.RenderAnchorT Anchor { get; set; }
  public float Scale { get; set; }
  public RLBot.Flat.ColorT Foreground { get; set; }
  public RLBot.Flat.ColorT Background { get; set; }
  public RLBot.Flat.TextHAlign HAlign { get; set; }
  public RLBot.Flat.TextVAlign VAlign { get; set; }

  public String3DT() {
    this.Text = null;
    this.Anchor = null;
    this.Scale = 0.0f;
    this.Foreground = new RLBot.Flat.ColorT();
    this.Background = new RLBot.Flat.ColorT();
    this.HAlign = RLBot.Flat.TextHAlign.Left;
    this.VAlign = RLBot.Flat.TextVAlign.Top;
  }
}


static public class String3DVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Text*/, true)
      && verifier.VerifyTable(tablePos, 6 /*Anchor*/, RLBot.Flat.RenderAnchorVerify.Verify, true)
      && verifier.VerifyField(tablePos, 8 /*Scale*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*Foreground*/, 4 /*RLBot.Flat.Color*/, 1, true)
      && verifier.VerifyField(tablePos, 12 /*Background*/, 4 /*RLBot.Flat.Color*/, 1, true)
      && verifier.VerifyField(tablePos, 14 /*HAlign*/, 1 /*RLBot.Flat.TextHAlign*/, 1, false)
      && verifier.VerifyField(tablePos, 16 /*VAlign*/, 1 /*RLBot.Flat.TextVAlign*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A RenderMessage for a rectangle in 2D space.
/// Note that the position and size is given in screen-space coordinates.
public struct Rect2D : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static Rect2D GetRootAsRect2D(ByteBuffer _bb) { return GetRootAsRect2D(_bb, new Rect2D()); }
  public static Rect2D GetRootAsRect2D(ByteBuffer _bb, Rect2D obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Rect2D __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Screen-space x coordinate such that x=0 is left edge and x=1 is right edge of window.
  public float X { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// Screen-space y coordinate such that y=0 is top edge and y=1 is bottom edge of window.
  public float Y { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// Screen-space size such that width=0.1 is 10% of window width.
  public float Width { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// Screen-space size such that height=0.1 is 10% of window height.
  public float Height { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// Color of the rectangle.
  public RLBot.Flat.Color? Color { get { int o = __p.__offset(12); return o != 0 ? (RLBot.Flat.Color?)(new RLBot.Flat.Color()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// The horizontal alignment of the rectangle.
  public RLBot.Flat.TextHAlign HAlign { get { int o = __p.__offset(14); return o != 0 ? (RLBot.Flat.TextHAlign)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.TextHAlign.Left; } }
  /// The vertical alignment of the rectangle.
  public RLBot.Flat.TextVAlign VAlign { get { int o = __p.__offset(16); return o != 0 ? (RLBot.Flat.TextVAlign)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.TextVAlign.Top; } }

  public static Offset<RLBot.Flat.Rect2D> CreateRect2D(FlatBufferBuilder builder,
      float x = 0.0f,
      float y = 0.0f,
      float width = 0.0f,
      float height = 0.0f,
      RLBot.Flat.ColorT color = null,
      RLBot.Flat.TextHAlign h_align = RLBot.Flat.TextHAlign.Left,
      RLBot.Flat.TextVAlign v_align = RLBot.Flat.TextVAlign.Top) {
    builder.StartTable(7);
    Rect2D.AddColor(builder, RLBot.Flat.Color.Pack(builder, color));
    Rect2D.AddHeight(builder, height);
    Rect2D.AddWidth(builder, width);
    Rect2D.AddY(builder, y);
    Rect2D.AddX(builder, x);
    Rect2D.AddVAlign(builder, v_align);
    Rect2D.AddHAlign(builder, h_align);
    return Rect2D.EndRect2D(builder);
  }

  public static void StartRect2D(FlatBufferBuilder builder) { builder.StartTable(7); }
  public static void AddX(FlatBufferBuilder builder, float x) { builder.AddFloat(0, x, 0.0f); }
  public static void AddY(FlatBufferBuilder builder, float y) { builder.AddFloat(1, y, 0.0f); }
  public static void AddWidth(FlatBufferBuilder builder, float width) { builder.AddFloat(2, width, 0.0f); }
  public static void AddHeight(FlatBufferBuilder builder, float height) { builder.AddFloat(3, height, 0.0f); }
  public static void AddColor(FlatBufferBuilder builder, Offset<RLBot.Flat.Color> colorOffset) { builder.AddStruct(4, colorOffset.Value, 0); }
  public static void AddHAlign(FlatBufferBuilder builder, RLBot.Flat.TextHAlign hAlign) { builder.AddByte(5, (byte)hAlign, 0); }
  public static void AddVAlign(FlatBufferBuilder builder, RLBot.Flat.TextVAlign vAlign) { builder.AddByte(6, (byte)vAlign, 0); }
  public static Offset<RLBot.Flat.Rect2D> EndRect2D(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 12);  // color
    return new Offset<RLBot.Flat.Rect2D>(o);
  }
  public Rect2DT UnPack() {
    var _o = new Rect2DT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(Rect2DT _o) {
    _o.X = this.X;
    _o.Y = this.Y;
    _o.Width = this.Width;
    _o.Height = this.Height;
    _o.Color = this.Color.HasValue ? this.Color.Value.UnPack() : null;
    _o.HAlign = this.HAlign;
    _o.VAlign = this.VAlign;
  }
  public static Offset<RLBot.Flat.Rect2D> Pack(FlatBufferBuilder builder, Rect2DT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.Rect2D>);
    return CreateRect2D(
      builder,
      _o.X,
      _o.Y,
      _o.Width,
      _o.Height,
      _o.Color,
      _o.HAlign,
      _o.VAlign);
  }
}

public class Rect2DT
{
  public float X { get; set; }
  public float Y { get; set; }
  public float Width { get; set; }
  public float Height { get; set; }
  public RLBot.Flat.ColorT Color { get; set; }
  public RLBot.Flat.TextHAlign HAlign { get; set; }
  public RLBot.Flat.TextVAlign VAlign { get; set; }

  public Rect2DT() {
    this.X = 0.0f;
    this.Y = 0.0f;
    this.Width = 0.0f;
    this.Height = 0.0f;
    this.Color = new RLBot.Flat.ColorT();
    this.HAlign = RLBot.Flat.TextHAlign.Left;
    this.VAlign = RLBot.Flat.TextVAlign.Top;
  }
}


static public class Rect2DVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*X*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Y*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Width*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*Height*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 12 /*Color*/, 4 /*RLBot.Flat.Color*/, 1, true)
      && verifier.VerifyField(tablePos, 14 /*HAlign*/, 1 /*RLBot.Flat.TextHAlign*/, 1, false)
      && verifier.VerifyField(tablePos, 16 /*VAlign*/, 1 /*RLBot.Flat.TextVAlign*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A RenderMessage for a rectangle in 3D space.
/// Note that the size is given in screen-space sizes.
public struct Rect3D : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static Rect3D GetRootAsRect3D(ByteBuffer _bb) { return GetRootAsRect3D(_bb, new Rect3D()); }
  public static Rect3D GetRootAsRect3D(ByteBuffer _bb, Rect3D obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Rect3D __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The position of the rectangle.
  public RLBot.Flat.RenderAnchor? Anchor { get { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.RenderAnchor?)(new RLBot.Flat.RenderAnchor()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// Screen-space size such that width=0.1 is 10% of window width.
  public float Width { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// Screen-space size such that height=0.1 is 10% of window height.
  public float Height { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// The color of the rectangle.
  public RLBot.Flat.Color? Color { get { int o = __p.__offset(10); return o != 0 ? (RLBot.Flat.Color?)(new RLBot.Flat.Color()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// The horizontal alignment of the anchor in the rectangle.
  public RLBot.Flat.TextHAlign HAlign { get { int o = __p.__offset(12); return o != 0 ? (RLBot.Flat.TextHAlign)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.TextHAlign.Left; } }
  /// The vertical alignment of the anchor in the rectangle.
  public RLBot.Flat.TextVAlign VAlign { get { int o = __p.__offset(14); return o != 0 ? (RLBot.Flat.TextVAlign)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.TextVAlign.Top; } }

  public static Offset<RLBot.Flat.Rect3D> CreateRect3D(FlatBufferBuilder builder,
      Offset<RLBot.Flat.RenderAnchor> anchorOffset = default(Offset<RLBot.Flat.RenderAnchor>),
      float width = 0.0f,
      float height = 0.0f,
      RLBot.Flat.ColorT color = null,
      RLBot.Flat.TextHAlign h_align = RLBot.Flat.TextHAlign.Left,
      RLBot.Flat.TextVAlign v_align = RLBot.Flat.TextVAlign.Top) {
    builder.StartTable(6);
    Rect3D.AddColor(builder, RLBot.Flat.Color.Pack(builder, color));
    Rect3D.AddHeight(builder, height);
    Rect3D.AddWidth(builder, width);
    Rect3D.AddAnchor(builder, anchorOffset);
    Rect3D.AddVAlign(builder, v_align);
    Rect3D.AddHAlign(builder, h_align);
    return Rect3D.EndRect3D(builder);
  }

  public static void StartRect3D(FlatBufferBuilder builder) { builder.StartTable(6); }
  public static void AddAnchor(FlatBufferBuilder builder, Offset<RLBot.Flat.RenderAnchor> anchorOffset) { builder.AddOffset(0, anchorOffset.Value, 0); }
  public static void AddWidth(FlatBufferBuilder builder, float width) { builder.AddFloat(1, width, 0.0f); }
  public static void AddHeight(FlatBufferBuilder builder, float height) { builder.AddFloat(2, height, 0.0f); }
  public static void AddColor(FlatBufferBuilder builder, Offset<RLBot.Flat.Color> colorOffset) { builder.AddStruct(3, colorOffset.Value, 0); }
  public static void AddHAlign(FlatBufferBuilder builder, RLBot.Flat.TextHAlign hAlign) { builder.AddByte(4, (byte)hAlign, 0); }
  public static void AddVAlign(FlatBufferBuilder builder, RLBot.Flat.TextVAlign vAlign) { builder.AddByte(5, (byte)vAlign, 0); }
  public static Offset<RLBot.Flat.Rect3D> EndRect3D(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // anchor
    builder.Required(o, 10);  // color
    return new Offset<RLBot.Flat.Rect3D>(o);
  }
  public Rect3DT UnPack() {
    var _o = new Rect3DT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(Rect3DT _o) {
    _o.Anchor = this.Anchor.HasValue ? this.Anchor.Value.UnPack() : null;
    _o.Width = this.Width;
    _o.Height = this.Height;
    _o.Color = this.Color.HasValue ? this.Color.Value.UnPack() : null;
    _o.HAlign = this.HAlign;
    _o.VAlign = this.VAlign;
  }
  public static Offset<RLBot.Flat.Rect3D> Pack(FlatBufferBuilder builder, Rect3DT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.Rect3D>);
    var _anchor = _o.Anchor == null ? default(Offset<RLBot.Flat.RenderAnchor>) : RLBot.Flat.RenderAnchor.Pack(builder, _o.Anchor);
    return CreateRect3D(
      builder,
      _anchor,
      _o.Width,
      _o.Height,
      _o.Color,
      _o.HAlign,
      _o.VAlign);
  }
}

public class Rect3DT
{
  public RLBot.Flat.RenderAnchorT Anchor { get; set; }
  public float Width { get; set; }
  public float Height { get; set; }
  public RLBot.Flat.ColorT Color { get; set; }
  public RLBot.Flat.TextHAlign HAlign { get; set; }
  public RLBot.Flat.TextVAlign VAlign { get; set; }

  public Rect3DT() {
    this.Anchor = null;
    this.Width = 0.0f;
    this.Height = 0.0f;
    this.Color = new RLBot.Flat.ColorT();
    this.HAlign = RLBot.Flat.TextHAlign.Left;
    this.VAlign = RLBot.Flat.TextVAlign.Top;
  }
}


static public class Rect3DVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTable(tablePos, 4 /*Anchor*/, RLBot.Flat.RenderAnchorVerify.Verify, true)
      && verifier.VerifyField(tablePos, 6 /*Width*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Height*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*Color*/, 4 /*RLBot.Flat.Color*/, 1, true)
      && verifier.VerifyField(tablePos, 12 /*HAlign*/, 1 /*RLBot.Flat.TextHAlign*/, 1, false)
      && verifier.VerifyField(tablePos, 14 /*VAlign*/, 1 /*RLBot.Flat.TextVAlign*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A RenderMessage, describing a piece of debug rendering.
public struct RenderMessage : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static RenderMessage GetRootAsRenderMessage(ByteBuffer _bb) { return GetRootAsRenderMessage(_bb, new RenderMessage()); }
  public static RenderMessage GetRootAsRenderMessage(ByteBuffer _bb, RenderMessage obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RenderMessage __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public RLBot.Flat.RenderType VarietyType { get { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.RenderType)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.RenderType.NONE; } }
  public TTable? Variety<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(6); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public RLBot.Flat.Line3D VarietyAsLine3D() { return Variety<RLBot.Flat.Line3D>().Value; }
  public RLBot.Flat.PolyLine3D VarietyAsPolyLine3D() { return Variety<RLBot.Flat.PolyLine3D>().Value; }
  public RLBot.Flat.String2D VarietyAsString2D() { return Variety<RLBot.Flat.String2D>().Value; }
  public RLBot.Flat.String3D VarietyAsString3D() { return Variety<RLBot.Flat.String3D>().Value; }
  public RLBot.Flat.Rect2D VarietyAsRect2D() { return Variety<RLBot.Flat.Rect2D>().Value; }
  public RLBot.Flat.Rect3D VarietyAsRect3D() { return Variety<RLBot.Flat.Rect3D>().Value; }

  public static Offset<RLBot.Flat.RenderMessage> CreateRenderMessage(FlatBufferBuilder builder,
      RLBot.Flat.RenderType variety_type = RLBot.Flat.RenderType.NONE,
      int varietyOffset = 0) {
    builder.StartTable(2);
    RenderMessage.AddVariety(builder, varietyOffset);
    RenderMessage.AddVarietyType(builder, variety_type);
    return RenderMessage.EndRenderMessage(builder);
  }

  public static void StartRenderMessage(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddVarietyType(FlatBufferBuilder builder, RLBot.Flat.RenderType varietyType) { builder.AddByte(0, (byte)varietyType, 0); }
  public static void AddVariety(FlatBufferBuilder builder, int varietyOffset) { builder.AddOffset(1, varietyOffset, 0); }
  public static Offset<RLBot.Flat.RenderMessage> EndRenderMessage(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 6);  // variety
    return new Offset<RLBot.Flat.RenderMessage>(o);
  }
  public RenderMessageT UnPack() {
    var _o = new RenderMessageT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(RenderMessageT _o) {
    _o.Variety = new RLBot.Flat.RenderTypeUnion();
    _o.Variety.Type = this.VarietyType;
    switch (this.VarietyType) {
      default: break;
      case RLBot.Flat.RenderType.Line3D:
        _o.Variety.Value = this.Variety<RLBot.Flat.Line3D>().HasValue ? this.Variety<RLBot.Flat.Line3D>().Value.UnPack() : null;
        break;
      case RLBot.Flat.RenderType.PolyLine3D:
        _o.Variety.Value = this.Variety<RLBot.Flat.PolyLine3D>().HasValue ? this.Variety<RLBot.Flat.PolyLine3D>().Value.UnPack() : null;
        break;
      case RLBot.Flat.RenderType.String2D:
        _o.Variety.Value = this.Variety<RLBot.Flat.String2D>().HasValue ? this.Variety<RLBot.Flat.String2D>().Value.UnPack() : null;
        break;
      case RLBot.Flat.RenderType.String3D:
        _o.Variety.Value = this.Variety<RLBot.Flat.String3D>().HasValue ? this.Variety<RLBot.Flat.String3D>().Value.UnPack() : null;
        break;
      case RLBot.Flat.RenderType.Rect2D:
        _o.Variety.Value = this.Variety<RLBot.Flat.Rect2D>().HasValue ? this.Variety<RLBot.Flat.Rect2D>().Value.UnPack() : null;
        break;
      case RLBot.Flat.RenderType.Rect3D:
        _o.Variety.Value = this.Variety<RLBot.Flat.Rect3D>().HasValue ? this.Variety<RLBot.Flat.Rect3D>().Value.UnPack() : null;
        break;
    }
  }
  public static Offset<RLBot.Flat.RenderMessage> Pack(FlatBufferBuilder builder, RenderMessageT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.RenderMessage>);
    var _variety_type = _o.Variety == null ? RLBot.Flat.RenderType.NONE : _o.Variety.Type;
    var _variety = _o.Variety == null ? 0 : RLBot.Flat.RenderTypeUnion.Pack(builder, _o.Variety);
    return CreateRenderMessage(
      builder,
      _variety_type,
      _variety);
  }
}

public class RenderMessageT
{
  public RLBot.Flat.RenderTypeUnion Variety { get; set; }

  public RenderMessageT() {
    this.Variety = null;
  }
}


static public class RenderMessageVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*VarietyType*/, 1 /*RLBot.Flat.RenderType*/, 1, false)
      && verifier.VerifyUnion(tablePos, 4, 6 /*Variety*/, RLBot.Flat.RenderTypeVerify.Verify, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A group of RenderMessages that are drawn and cleared together.
/// A RenderGroup will stay rendered until it is overriden or cleared.
/// The group is identified by a unique id.
/// A client can only clear its own RenderGroups.
public struct RenderGroup : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static RenderGroup GetRootAsRenderGroup(ByteBuffer _bb) { return GetRootAsRenderGroup(_bb, new RenderGroup()); }
  public static RenderGroup GetRootAsRenderGroup(ByteBuffer _bb, RenderGroup obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RenderGroup __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The content of the RenderGroup.
  public RLBot.Flat.RenderMessage? RenderMessages(int j) { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.RenderMessage?)(new RLBot.Flat.RenderMessage()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int RenderMessagesLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The id of the RenderGroup.
  public int Id { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<RLBot.Flat.RenderGroup> CreateRenderGroup(FlatBufferBuilder builder,
      VectorOffset render_messagesOffset = default(VectorOffset),
      int id = 0) {
    builder.StartTable(2);
    RenderGroup.AddId(builder, id);
    RenderGroup.AddRenderMessages(builder, render_messagesOffset);
    return RenderGroup.EndRenderGroup(builder);
  }

  public static void StartRenderGroup(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddRenderMessages(FlatBufferBuilder builder, VectorOffset renderMessagesOffset) { builder.AddOffset(0, renderMessagesOffset.Value, 0); }
  public static VectorOffset CreateRenderMessagesVector(FlatBufferBuilder builder, Offset<RLBot.Flat.RenderMessage>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateRenderMessagesVectorBlock(FlatBufferBuilder builder, Offset<RLBot.Flat.RenderMessage>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRenderMessagesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<RLBot.Flat.RenderMessage>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRenderMessagesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<RLBot.Flat.RenderMessage>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartRenderMessagesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddId(FlatBufferBuilder builder, int id) { builder.AddInt(1, id, 0); }
  public static Offset<RLBot.Flat.RenderGroup> EndRenderGroup(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // render_messages
    return new Offset<RLBot.Flat.RenderGroup>(o);
  }
  public RenderGroupT UnPack() {
    var _o = new RenderGroupT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(RenderGroupT _o) {
    _o.RenderMessages = new List<RLBot.Flat.RenderMessageT>();
    for (var _j = 0; _j < this.RenderMessagesLength; ++_j) {_o.RenderMessages.Add(this.RenderMessages(_j).HasValue ? this.RenderMessages(_j).Value.UnPack() : null);}
    _o.Id = this.Id;
  }
  public static Offset<RLBot.Flat.RenderGroup> Pack(FlatBufferBuilder builder, RenderGroupT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.RenderGroup>);
    var _render_messages = default(VectorOffset);
    if (_o.RenderMessages != null) {
      var __render_messages = new Offset<RLBot.Flat.RenderMessage>[_o.RenderMessages.Count];
      for (var _j = 0; _j < __render_messages.Length; ++_j) { __render_messages[_j] = RLBot.Flat.RenderMessage.Pack(builder, _o.RenderMessages[_j]); }
      _render_messages = CreateRenderMessagesVector(builder, __render_messages);
    }
    return CreateRenderGroup(
      builder,
      _render_messages,
      _o.Id);
  }
}

public class RenderGroupT
{
  public List<RLBot.Flat.RenderMessageT> RenderMessages { get; set; }
  public int Id { get; set; }

  public RenderGroupT() {
    this.RenderMessages = null;
    this.Id = 0;
  }
}


static public class RenderGroupVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfTables(tablePos, 4 /*RenderMessages*/, RLBot.Flat.RenderMessageVerify.Verify, true)
      && verifier.VerifyField(tablePos, 6 /*Id*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A client message request removal of a RenderGroup.
/// A client can only clear its own RenderGroups.
public struct RemoveRenderGroup : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static RemoveRenderGroup GetRootAsRemoveRenderGroup(ByteBuffer _bb) { return GetRootAsRemoveRenderGroup(_bb, new RemoveRenderGroup()); }
  public static RemoveRenderGroup GetRootAsRemoveRenderGroup(ByteBuffer _bb, RemoveRenderGroup obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RemoveRenderGroup __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int Id { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<RLBot.Flat.RemoveRenderGroup> CreateRemoveRenderGroup(FlatBufferBuilder builder,
      int id = 0) {
    builder.StartTable(1);
    RemoveRenderGroup.AddId(builder, id);
    return RemoveRenderGroup.EndRemoveRenderGroup(builder);
  }

  public static void StartRemoveRenderGroup(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddId(FlatBufferBuilder builder, int id) { builder.AddInt(0, id, 0); }
  public static Offset<RLBot.Flat.RemoveRenderGroup> EndRemoveRenderGroup(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RLBot.Flat.RemoveRenderGroup>(o);
  }
  public RemoveRenderGroupT UnPack() {
    var _o = new RemoveRenderGroupT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(RemoveRenderGroupT _o) {
    _o.Id = this.Id;
  }
  public static Offset<RLBot.Flat.RemoveRenderGroup> Pack(FlatBufferBuilder builder, RemoveRenderGroupT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.RemoveRenderGroup>);
    return CreateRemoveRenderGroup(
      builder,
      _o.Id);
  }
}

public class RemoveRenderGroupT
{
  public int Id { get; set; }

  public RemoveRenderGroupT() {
    this.Id = 0;
  }
}


static public class RemoveRenderGroupVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Id*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Sent to core to indicate that you want to disconnect.
/// Sent from core to indicate that you should exit.
public struct DisconnectSignal : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static DisconnectSignal GetRootAsDisconnectSignal(ByteBuffer _bb) { return GetRootAsDisconnectSignal(_bb, new DisconnectSignal()); }
  public static DisconnectSignal GetRootAsDisconnectSignal(ByteBuffer _bb, DisconnectSignal obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DisconnectSignal __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartDisconnectSignal(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<RLBot.Flat.DisconnectSignal> EndDisconnectSignal(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RLBot.Flat.DisconnectSignal>(o);
  }
  public DisconnectSignalT UnPack() {
    var _o = new DisconnectSignalT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(DisconnectSignalT _o) {
  }
  public static Offset<RLBot.Flat.DisconnectSignal> Pack(FlatBufferBuilder builder, DisconnectSignalT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.DisconnectSignal>);
    StartDisconnectSignal(builder);
    return EndDisconnectSignal(builder);
  }
}

public class DisconnectSignalT
{

  public DisconnectSignalT() {
  }
}


static public class DisconnectSignalVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Indicates that the session has finished all initialization and is ready to start receiving
/// game messages without delay.
public struct InitComplete : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static InitComplete GetRootAsInitComplete(ByteBuffer _bb) { return GetRootAsInitComplete(_bb, new InitComplete()); }
  public static InitComplete GetRootAsInitComplete(ByteBuffer _bb, InitComplete obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public InitComplete __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartInitComplete(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<RLBot.Flat.InitComplete> EndInitComplete(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RLBot.Flat.InitComplete>(o);
  }
  public InitCompleteT UnPack() {
    var _o = new InitCompleteT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(InitCompleteT _o) {
  }
  public static Offset<RLBot.Flat.InitComplete> Pack(FlatBufferBuilder builder, InitCompleteT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.InitComplete>);
    StartInitComplete(builder);
    return EndInitComplete(builder);
  }
}

public class InitCompleteT
{

  public InitCompleteT() {
  }
}


static public class InitCompleteVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A client message to start a match using a path to a match config file.
public struct StartCommand : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static StartCommand GetRootAsStartCommand(ByteBuffer _bb) { return GetRootAsStartCommand(_bb, new StartCommand()); }
  public static StartCommand GetRootAsStartCommand(ByteBuffer _bb, StartCommand obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StartCommand __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string ConfigPath { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetConfigPathBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetConfigPathBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetConfigPathArray() { return __p.__vector_as_array<byte>(4); }

  public static Offset<RLBot.Flat.StartCommand> CreateStartCommand(FlatBufferBuilder builder,
      StringOffset config_pathOffset = default(StringOffset)) {
    builder.StartTable(1);
    StartCommand.AddConfigPath(builder, config_pathOffset);
    return StartCommand.EndStartCommand(builder);
  }

  public static void StartStartCommand(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddConfigPath(FlatBufferBuilder builder, StringOffset configPathOffset) { builder.AddOffset(0, configPathOffset.Value, 0); }
  public static Offset<RLBot.Flat.StartCommand> EndStartCommand(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // config_path
    return new Offset<RLBot.Flat.StartCommand>(o);
  }
  public StartCommandT UnPack() {
    var _o = new StartCommandT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(StartCommandT _o) {
    _o.ConfigPath = this.ConfigPath;
  }
  public static Offset<RLBot.Flat.StartCommand> Pack(FlatBufferBuilder builder, StartCommandT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.StartCommand>);
    var _config_path = _o.ConfigPath == null ? default(StringOffset) : builder.CreateString(_o.ConfigPath);
    return CreateStartCommand(
      builder,
      _config_path);
  }
}

public class StartCommandT
{
  public string ConfigPath { get; set; }

  public StartCommandT() {
    this.ConfigPath = null;
  }
}


static public class StartCommandVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*ConfigPath*/, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A client message to stop a match and optionally the RLBot server too.
public struct StopCommand : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static StopCommand GetRootAsStopCommand(ByteBuffer _bb) { return GetRootAsStopCommand(_bb, new StopCommand()); }
  public static StopCommand GetRootAsStopCommand(ByteBuffer _bb, StopCommand obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StopCommand __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool ShutdownServer { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<RLBot.Flat.StopCommand> CreateStopCommand(FlatBufferBuilder builder,
      bool shutdown_server = false) {
    builder.StartTable(1);
    StopCommand.AddShutdownServer(builder, shutdown_server);
    return StopCommand.EndStopCommand(builder);
  }

  public static void StartStopCommand(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddShutdownServer(FlatBufferBuilder builder, bool shutdownServer) { builder.AddBool(0, shutdownServer, false); }
  public static Offset<RLBot.Flat.StopCommand> EndStopCommand(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RLBot.Flat.StopCommand>(o);
  }
  public StopCommandT UnPack() {
    var _o = new StopCommandT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(StopCommandT _o) {
    _o.ShutdownServer = this.ShutdownServer;
  }
  public static Offset<RLBot.Flat.StopCommand> Pack(FlatBufferBuilder builder, StopCommandT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.StopCommand>);
    return CreateStopCommand(
      builder,
      _o.ShutdownServer);
  }
}

public class StopCommandT
{
  public bool ShutdownServer { get; set; }

  public StopCommandT() {
    this.ShutdownServer = false;
  }
}


static public class StopCommandVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*ShutdownServer*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Sent by clients when connecting to RLBot to indicate what type of messages are desired.
/// This could be sent by a bot, or a bot manager governing several bots, an
/// overlay, or any other utility that connects to the RLBot process.
public struct ConnectionSettings : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static ConnectionSettings GetRootAsConnectionSettings(ByteBuffer _bb) { return GetRootAsConnectionSettings(_bb, new ConnectionSettings()); }
  public static ConnectionSettings GetRootAsConnectionSettings(ByteBuffer _bb, ConnectionSettings obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ConnectionSettings __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The ID of the bot/script that is associated with the incoming connection.
  public string AgentId { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAgentIdBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetAgentIdBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetAgentIdArray() { return __p.__vector_as_array<byte>(4); }
  /// If this is set, RLBot will send BallPrediction data back to the client when available.
  public bool WantsBallPredictions { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// If this is set, RLBot will send MatchComms to the client when available.
  public bool WantsComms { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// If this is set, RLBot will close the connection when a match is stopped or when a new
  /// match is started. The GUI and other match runners should likely not set this.
  public bool CloseBetweenMatches { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<RLBot.Flat.ConnectionSettings> CreateConnectionSettings(FlatBufferBuilder builder,
      StringOffset agent_idOffset = default(StringOffset),
      bool wants_ball_predictions = false,
      bool wants_comms = false,
      bool close_between_matches = false) {
    builder.StartTable(4);
    ConnectionSettings.AddAgentId(builder, agent_idOffset);
    ConnectionSettings.AddCloseBetweenMatches(builder, close_between_matches);
    ConnectionSettings.AddWantsComms(builder, wants_comms);
    ConnectionSettings.AddWantsBallPredictions(builder, wants_ball_predictions);
    return ConnectionSettings.EndConnectionSettings(builder);
  }

  public static void StartConnectionSettings(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddAgentId(FlatBufferBuilder builder, StringOffset agentIdOffset) { builder.AddOffset(0, agentIdOffset.Value, 0); }
  public static void AddWantsBallPredictions(FlatBufferBuilder builder, bool wantsBallPredictions) { builder.AddBool(1, wantsBallPredictions, false); }
  public static void AddWantsComms(FlatBufferBuilder builder, bool wantsComms) { builder.AddBool(2, wantsComms, false); }
  public static void AddCloseBetweenMatches(FlatBufferBuilder builder, bool closeBetweenMatches) { builder.AddBool(3, closeBetweenMatches, false); }
  public static Offset<RLBot.Flat.ConnectionSettings> EndConnectionSettings(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // agent_id
    return new Offset<RLBot.Flat.ConnectionSettings>(o);
  }
  public ConnectionSettingsT UnPack() {
    var _o = new ConnectionSettingsT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(ConnectionSettingsT _o) {
    _o.AgentId = this.AgentId;
    _o.WantsBallPredictions = this.WantsBallPredictions;
    _o.WantsComms = this.WantsComms;
    _o.CloseBetweenMatches = this.CloseBetweenMatches;
  }
  public static Offset<RLBot.Flat.ConnectionSettings> Pack(FlatBufferBuilder builder, ConnectionSettingsT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.ConnectionSettings>);
    var _agent_id = _o.AgentId == null ? default(StringOffset) : builder.CreateString(_o.AgentId);
    return CreateConnectionSettings(
      builder,
      _agent_id,
      _o.WantsBallPredictions,
      _o.WantsComms,
      _o.CloseBetweenMatches);
  }
}

public class ConnectionSettingsT
{
  public string AgentId { get; set; }
  public bool WantsBallPredictions { get; set; }
  public bool WantsComms { get; set; }
  public bool CloseBetweenMatches { get; set; }

  public ConnectionSettingsT() {
    this.AgentId = null;
    this.WantsBallPredictions = false;
    this.WantsComms = false;
    this.CloseBetweenMatches = false;
  }
}


static public class ConnectionSettingsVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*AgentId*/, true)
      && verifier.VerifyField(tablePos, 6 /*WantsBallPredictions*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 8 /*WantsComms*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*CloseBetweenMatches*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A client message to change the loadout of a car.
/// If sent before the ready message, this simply sets the loadout of the car.
/// If sent after the ready message and if game state setting is enabled, this will respawn the car with the new loadout.
/// Bots can only set the loadout of their own car(s).
public struct SetLoadout : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static SetLoadout GetRootAsSetLoadout(ByteBuffer _bb) { return GetRootAsSetLoadout(_bb, new SetLoadout()); }
  public static SetLoadout GetRootAsSetLoadout(ByteBuffer _bb, SetLoadout obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SetLoadout __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The index of the car to change loadout off.
  public uint Index { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  /// The new loadout of the car.
  public RLBot.Flat.PlayerLoadout? Loadout { get { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.PlayerLoadout?)(new RLBot.Flat.PlayerLoadout()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }

  public static Offset<RLBot.Flat.SetLoadout> CreateSetLoadout(FlatBufferBuilder builder,
      uint index = 0,
      Offset<RLBot.Flat.PlayerLoadout> loadoutOffset = default(Offset<RLBot.Flat.PlayerLoadout>)) {
    builder.StartTable(2);
    SetLoadout.AddLoadout(builder, loadoutOffset);
    SetLoadout.AddIndex(builder, index);
    return SetLoadout.EndSetLoadout(builder);
  }

  public static void StartSetLoadout(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddIndex(FlatBufferBuilder builder, uint index) { builder.AddUint(0, index, 0); }
  public static void AddLoadout(FlatBufferBuilder builder, Offset<RLBot.Flat.PlayerLoadout> loadoutOffset) { builder.AddOffset(1, loadoutOffset.Value, 0); }
  public static Offset<RLBot.Flat.SetLoadout> EndSetLoadout(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 6);  // loadout
    return new Offset<RLBot.Flat.SetLoadout>(o);
  }
  public SetLoadoutT UnPack() {
    var _o = new SetLoadoutT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(SetLoadoutT _o) {
    _o.Index = this.Index;
    _o.Loadout = this.Loadout.HasValue ? this.Loadout.Value.UnPack() : null;
  }
  public static Offset<RLBot.Flat.SetLoadout> Pack(FlatBufferBuilder builder, SetLoadoutT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.SetLoadout>);
    var _loadout = _o.Loadout == null ? default(Offset<RLBot.Flat.PlayerLoadout>) : RLBot.Flat.PlayerLoadout.Pack(builder, _o.Loadout);
    return CreateSetLoadout(
      builder,
      _o.Index,
      _loadout);
  }
}

public class SetLoadoutT
{
  public uint Index { get; set; }
  public RLBot.Flat.PlayerLoadoutT Loadout { get; set; }

  public SetLoadoutT() {
    this.Index = 0;
    this.Loadout = null;
  }
}


static public class SetLoadoutVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Index*/, 4 /*uint*/, 4, false)
      && verifier.VerifyTable(tablePos, 6 /*Loadout*/, RLBot.Flat.PlayerLoadoutVerify.Verify, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Information about a car that the client can control.
public struct ControllableInfo : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static ControllableInfo GetRootAsControllableInfo(ByteBuffer _bb) { return GetRootAsControllableInfo(_bb, new ControllableInfo()); }
  public static ControllableInfo GetRootAsControllableInfo(ByteBuffer _bb, ControllableInfo obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ControllableInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The index of the bot/script.
  public uint Index { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  /// The id of the bot/script.
  /// This value is mostly used internally to keep track of participants in the match.
  /// The id can be used to find the corresponding PlayerConfiguration in the MatchConfiguration.
  public int Identifier { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<RLBot.Flat.ControllableInfo> CreateControllableInfo(FlatBufferBuilder builder,
      uint index = 0,
      int identifier = 0) {
    builder.StartTable(2);
    ControllableInfo.AddIdentifier(builder, identifier);
    ControllableInfo.AddIndex(builder, index);
    return ControllableInfo.EndControllableInfo(builder);
  }

  public static void StartControllableInfo(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddIndex(FlatBufferBuilder builder, uint index) { builder.AddUint(0, index, 0); }
  public static void AddIdentifier(FlatBufferBuilder builder, int identifier) { builder.AddInt(1, identifier, 0); }
  public static Offset<RLBot.Flat.ControllableInfo> EndControllableInfo(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RLBot.Flat.ControllableInfo>(o);
  }
  public ControllableInfoT UnPack() {
    var _o = new ControllableInfoT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(ControllableInfoT _o) {
    _o.Index = this.Index;
    _o.Identifier = this.Identifier;
  }
  public static Offset<RLBot.Flat.ControllableInfo> Pack(FlatBufferBuilder builder, ControllableInfoT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.ControllableInfo>);
    return CreateControllableInfo(
      builder,
      _o.Index,
      _o.Identifier);
  }
}

public class ControllableInfoT
{
  public uint Index { get; set; }
  public int Identifier { get; set; }

  public ControllableInfoT() {
    this.Index = 0;
    this.Identifier = 0;
  }
}


static public class ControllableInfoVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Index*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Identifier*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Server message with information about the cars that the client can control.
/// Sent to bot clients as a response to ConnectionSettings.
/// There may be more than one car in case the bot is a hivemind.
public struct ControllableTeamInfo : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static ControllableTeamInfo GetRootAsControllableTeamInfo(ByteBuffer _bb) { return GetRootAsControllableTeamInfo(_bb, new ControllableTeamInfo()); }
  public static ControllableTeamInfo GetRootAsControllableTeamInfo(ByteBuffer _bb, ControllableTeamInfo obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ControllableTeamInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The assigned team for this client.
  public uint Team { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  /// The bots that RLBot will allow this client to control.
  public RLBot.Flat.ControllableInfo? Controllables(int j) { int o = __p.__offset(6); return o != 0 ? (RLBot.Flat.ControllableInfo?)(new RLBot.Flat.ControllableInfo()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int ControllablesLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<RLBot.Flat.ControllableTeamInfo> CreateControllableTeamInfo(FlatBufferBuilder builder,
      uint team = 0,
      VectorOffset controllablesOffset = default(VectorOffset)) {
    builder.StartTable(2);
    ControllableTeamInfo.AddControllables(builder, controllablesOffset);
    ControllableTeamInfo.AddTeam(builder, team);
    return ControllableTeamInfo.EndControllableTeamInfo(builder);
  }

  public static void StartControllableTeamInfo(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddTeam(FlatBufferBuilder builder, uint team) { builder.AddUint(0, team, 0); }
  public static void AddControllables(FlatBufferBuilder builder, VectorOffset controllablesOffset) { builder.AddOffset(1, controllablesOffset.Value, 0); }
  public static VectorOffset CreateControllablesVector(FlatBufferBuilder builder, Offset<RLBot.Flat.ControllableInfo>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateControllablesVectorBlock(FlatBufferBuilder builder, Offset<RLBot.Flat.ControllableInfo>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateControllablesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<RLBot.Flat.ControllableInfo>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateControllablesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<RLBot.Flat.ControllableInfo>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartControllablesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<RLBot.Flat.ControllableTeamInfo> EndControllableTeamInfo(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 6);  // controllables
    return new Offset<RLBot.Flat.ControllableTeamInfo>(o);
  }
  public ControllableTeamInfoT UnPack() {
    var _o = new ControllableTeamInfoT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(ControllableTeamInfoT _o) {
    _o.Team = this.Team;
    _o.Controllables = new List<RLBot.Flat.ControllableInfoT>();
    for (var _j = 0; _j < this.ControllablesLength; ++_j) {_o.Controllables.Add(this.Controllables(_j).HasValue ? this.Controllables(_j).Value.UnPack() : null);}
  }
  public static Offset<RLBot.Flat.ControllableTeamInfo> Pack(FlatBufferBuilder builder, ControllableTeamInfoT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.ControllableTeamInfo>);
    var _controllables = default(VectorOffset);
    if (_o.Controllables != null) {
      var __controllables = new Offset<RLBot.Flat.ControllableInfo>[_o.Controllables.Count];
      for (var _j = 0; _j < __controllables.Length; ++_j) { __controllables[_j] = RLBot.Flat.ControllableInfo.Pack(builder, _o.Controllables[_j]); }
      _controllables = CreateControllablesVector(builder, __controllables);
    }
    return CreateControllableTeamInfo(
      builder,
      _o.Team,
      _controllables);
  }
}

public class ControllableTeamInfoT
{
  public uint Team { get; set; }
  public List<RLBot.Flat.ControllableInfoT> Controllables { get; set; }

  public ControllableTeamInfoT() {
    this.Team = 0;
    this.Controllables = null;
  }
}


static public class ControllableTeamInfoVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Team*/, 4 /*uint*/, 4, false)
      && verifier.VerifyVectorOfTables(tablePos, 6 /*Controllables*/, RLBot.Flat.ControllableInfoVerify.Verify, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// As an interface message, this requests for a specificed agent to have its ability to render changed.
/// This changed will then be broadcasted to all current connections as a core message.
/// Does nothing if rendering has been completely disabled.
public struct RenderingStatus : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static RenderingStatus GetRootAsRenderingStatus(ByteBuffer _bb) { return GetRootAsRenderingStatus(_bb, new RenderingStatus()); }
  public static RenderingStatus GetRootAsRenderingStatus(ByteBuffer _bb, RenderingStatus obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RenderingStatus __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// If `is_bot`, this is the index of the bot in `GamePacket` that has been updated.
  /// Otherwise, this is the index of the script in `MatchConfiguration` that has been updated.
  public uint Index { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  /// Identifies if the index is that of a bot or a script
  public bool IsBot { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// If rendering is now enabled or disabled for the specific agent
  public bool Status { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<RLBot.Flat.RenderingStatus> CreateRenderingStatus(FlatBufferBuilder builder,
      uint index = 0,
      bool is_bot = false,
      bool status = false) {
    builder.StartTable(3);
    RenderingStatus.AddIndex(builder, index);
    RenderingStatus.AddStatus(builder, status);
    RenderingStatus.AddIsBot(builder, is_bot);
    return RenderingStatus.EndRenderingStatus(builder);
  }

  public static void StartRenderingStatus(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddIndex(FlatBufferBuilder builder, uint index) { builder.AddUint(0, index, 0); }
  public static void AddIsBot(FlatBufferBuilder builder, bool isBot) { builder.AddBool(1, isBot, false); }
  public static void AddStatus(FlatBufferBuilder builder, bool status) { builder.AddBool(2, status, false); }
  public static Offset<RLBot.Flat.RenderingStatus> EndRenderingStatus(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RLBot.Flat.RenderingStatus>(o);
  }
  public RenderingStatusT UnPack() {
    var _o = new RenderingStatusT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(RenderingStatusT _o) {
    _o.Index = this.Index;
    _o.IsBot = this.IsBot;
    _o.Status = this.Status;
  }
  public static Offset<RLBot.Flat.RenderingStatus> Pack(FlatBufferBuilder builder, RenderingStatusT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.RenderingStatus>);
    return CreateRenderingStatus(
      builder,
      _o.Index,
      _o.IsBot,
      _o.Status);
  }
}

public class RenderingStatusT
{
  public uint Index { get; set; }
  public bool IsBot { get; set; }
  public bool Status { get; set; }

  public RenderingStatusT() {
    this.Index = 0;
    this.IsBot = false;
    this.Status = false;
  }
}


static public class RenderingStatusVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Index*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*IsBot*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 8 /*Status*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Packet containing a CoreMessage
public struct CorePacket : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static CorePacket GetRootAsCorePacket(ByteBuffer _bb) { return GetRootAsCorePacket(_bb, new CorePacket()); }
  public static CorePacket GetRootAsCorePacket(ByteBuffer _bb, CorePacket obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public CorePacket __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public RLBot.Flat.CoreMessage MessageType { get { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.CoreMessage)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.CoreMessage.NONE; } }
  public TTable? Message<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(6); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public RLBot.Flat.DisconnectSignal MessageAsDisconnectSignal() { return Message<RLBot.Flat.DisconnectSignal>().Value; }
  public RLBot.Flat.GamePacket MessageAsGamePacket() { return Message<RLBot.Flat.GamePacket>().Value; }
  public RLBot.Flat.FieldInfo MessageAsFieldInfo() { return Message<RLBot.Flat.FieldInfo>().Value; }
  public RLBot.Flat.MatchConfiguration MessageAsMatchConfiguration() { return Message<RLBot.Flat.MatchConfiguration>().Value; }
  public RLBot.Flat.MatchComm MessageAsMatchComm() { return Message<RLBot.Flat.MatchComm>().Value; }
  public RLBot.Flat.BallPrediction MessageAsBallPrediction() { return Message<RLBot.Flat.BallPrediction>().Value; }
  public RLBot.Flat.ControllableTeamInfo MessageAsControllableTeamInfo() { return Message<RLBot.Flat.ControllableTeamInfo>().Value; }
  public RLBot.Flat.RenderingStatus MessageAsRenderingStatus() { return Message<RLBot.Flat.RenderingStatus>().Value; }

  public static Offset<RLBot.Flat.CorePacket> CreateCorePacket(FlatBufferBuilder builder,
      RLBot.Flat.CoreMessage message_type = RLBot.Flat.CoreMessage.NONE,
      int messageOffset = 0) {
    builder.StartTable(2);
    CorePacket.AddMessage(builder, messageOffset);
    CorePacket.AddMessageType(builder, message_type);
    return CorePacket.EndCorePacket(builder);
  }

  public static void StartCorePacket(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddMessageType(FlatBufferBuilder builder, RLBot.Flat.CoreMessage messageType) { builder.AddByte(0, (byte)messageType, 0); }
  public static void AddMessage(FlatBufferBuilder builder, int messageOffset) { builder.AddOffset(1, messageOffset, 0); }
  public static Offset<RLBot.Flat.CorePacket> EndCorePacket(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 6);  // message
    return new Offset<RLBot.Flat.CorePacket>(o);
  }
  public CorePacketT UnPack() {
    var _o = new CorePacketT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(CorePacketT _o) {
    _o.Message = new RLBot.Flat.CoreMessageUnion();
    _o.Message.Type = this.MessageType;
    switch (this.MessageType) {
      default: break;
      case RLBot.Flat.CoreMessage.DisconnectSignal:
        _o.Message.Value = this.Message<RLBot.Flat.DisconnectSignal>().HasValue ? this.Message<RLBot.Flat.DisconnectSignal>().Value.UnPack() : null;
        break;
      case RLBot.Flat.CoreMessage.GamePacket:
        _o.Message.Value = this.Message<RLBot.Flat.GamePacket>().HasValue ? this.Message<RLBot.Flat.GamePacket>().Value.UnPack() : null;
        break;
      case RLBot.Flat.CoreMessage.FieldInfo:
        _o.Message.Value = this.Message<RLBot.Flat.FieldInfo>().HasValue ? this.Message<RLBot.Flat.FieldInfo>().Value.UnPack() : null;
        break;
      case RLBot.Flat.CoreMessage.MatchConfiguration:
        _o.Message.Value = this.Message<RLBot.Flat.MatchConfiguration>().HasValue ? this.Message<RLBot.Flat.MatchConfiguration>().Value.UnPack() : null;
        break;
      case RLBot.Flat.CoreMessage.MatchComm:
        _o.Message.Value = this.Message<RLBot.Flat.MatchComm>().HasValue ? this.Message<RLBot.Flat.MatchComm>().Value.UnPack() : null;
        break;
      case RLBot.Flat.CoreMessage.BallPrediction:
        _o.Message.Value = this.Message<RLBot.Flat.BallPrediction>().HasValue ? this.Message<RLBot.Flat.BallPrediction>().Value.UnPack() : null;
        break;
      case RLBot.Flat.CoreMessage.ControllableTeamInfo:
        _o.Message.Value = this.Message<RLBot.Flat.ControllableTeamInfo>().HasValue ? this.Message<RLBot.Flat.ControllableTeamInfo>().Value.UnPack() : null;
        break;
      case RLBot.Flat.CoreMessage.RenderingStatus:
        _o.Message.Value = this.Message<RLBot.Flat.RenderingStatus>().HasValue ? this.Message<RLBot.Flat.RenderingStatus>().Value.UnPack() : null;
        break;
    }
  }
  public static Offset<RLBot.Flat.CorePacket> Pack(FlatBufferBuilder builder, CorePacketT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.CorePacket>);
    var _message_type = _o.Message == null ? RLBot.Flat.CoreMessage.NONE : _o.Message.Type;
    var _message = _o.Message == null ? 0 : RLBot.Flat.CoreMessageUnion.Pack(builder, _o.Message);
    return CreateCorePacket(
      builder,
      _message_type,
      _message);
  }
}

public class CorePacketT
{
  public RLBot.Flat.CoreMessageUnion Message { get; set; }

  public CorePacketT() {
    this.Message = null;
  }
}


static public class CorePacketVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*MessageType*/, 1 /*RLBot.Flat.CoreMessage*/, 1, false)
      && verifier.VerifyUnion(tablePos, 4, 6 /*Message*/, RLBot.Flat.CoreMessageVerify.Verify, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Packet containing a InterfaceMessage
public struct InterfacePacket : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static InterfacePacket GetRootAsInterfacePacket(ByteBuffer _bb) { return GetRootAsInterfacePacket(_bb, new InterfacePacket()); }
  public static InterfacePacket GetRootAsInterfacePacket(ByteBuffer _bb, InterfacePacket obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public InterfacePacket __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public RLBot.Flat.InterfaceMessage MessageType { get { int o = __p.__offset(4); return o != 0 ? (RLBot.Flat.InterfaceMessage)__p.bb.Get(o + __p.bb_pos) : RLBot.Flat.InterfaceMessage.NONE; } }
  public TTable? Message<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(6); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public RLBot.Flat.DisconnectSignal MessageAsDisconnectSignal() { return Message<RLBot.Flat.DisconnectSignal>().Value; }
  public RLBot.Flat.StartCommand MessageAsStartCommand() { return Message<RLBot.Flat.StartCommand>().Value; }
  public RLBot.Flat.MatchConfiguration MessageAsMatchConfiguration() { return Message<RLBot.Flat.MatchConfiguration>().Value; }
  public RLBot.Flat.PlayerInput MessageAsPlayerInput() { return Message<RLBot.Flat.PlayerInput>().Value; }
  public RLBot.Flat.DesiredGameState MessageAsDesiredGameState() { return Message<RLBot.Flat.DesiredGameState>().Value; }
  public RLBot.Flat.RenderGroup MessageAsRenderGroup() { return Message<RLBot.Flat.RenderGroup>().Value; }
  public RLBot.Flat.RemoveRenderGroup MessageAsRemoveRenderGroup() { return Message<RLBot.Flat.RemoveRenderGroup>().Value; }
  public RLBot.Flat.MatchComm MessageAsMatchComm() { return Message<RLBot.Flat.MatchComm>().Value; }
  public RLBot.Flat.ConnectionSettings MessageAsConnectionSettings() { return Message<RLBot.Flat.ConnectionSettings>().Value; }
  public RLBot.Flat.StopCommand MessageAsStopCommand() { return Message<RLBot.Flat.StopCommand>().Value; }
  public RLBot.Flat.SetLoadout MessageAsSetLoadout() { return Message<RLBot.Flat.SetLoadout>().Value; }
  public RLBot.Flat.InitComplete MessageAsInitComplete() { return Message<RLBot.Flat.InitComplete>().Value; }
  public RLBot.Flat.RenderingStatus MessageAsRenderingStatus() { return Message<RLBot.Flat.RenderingStatus>().Value; }

  public static Offset<RLBot.Flat.InterfacePacket> CreateInterfacePacket(FlatBufferBuilder builder,
      RLBot.Flat.InterfaceMessage message_type = RLBot.Flat.InterfaceMessage.NONE,
      int messageOffset = 0) {
    builder.StartTable(2);
    InterfacePacket.AddMessage(builder, messageOffset);
    InterfacePacket.AddMessageType(builder, message_type);
    return InterfacePacket.EndInterfacePacket(builder);
  }

  public static void StartInterfacePacket(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddMessageType(FlatBufferBuilder builder, RLBot.Flat.InterfaceMessage messageType) { builder.AddByte(0, (byte)messageType, 0); }
  public static void AddMessage(FlatBufferBuilder builder, int messageOffset) { builder.AddOffset(1, messageOffset, 0); }
  public static Offset<RLBot.Flat.InterfacePacket> EndInterfacePacket(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 6);  // message
    return new Offset<RLBot.Flat.InterfacePacket>(o);
  }
  public InterfacePacketT UnPack() {
    var _o = new InterfacePacketT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(InterfacePacketT _o) {
    _o.Message = new RLBot.Flat.InterfaceMessageUnion();
    _o.Message.Type = this.MessageType;
    switch (this.MessageType) {
      default: break;
      case RLBot.Flat.InterfaceMessage.DisconnectSignal:
        _o.Message.Value = this.Message<RLBot.Flat.DisconnectSignal>().HasValue ? this.Message<RLBot.Flat.DisconnectSignal>().Value.UnPack() : null;
        break;
      case RLBot.Flat.InterfaceMessage.StartCommand:
        _o.Message.Value = this.Message<RLBot.Flat.StartCommand>().HasValue ? this.Message<RLBot.Flat.StartCommand>().Value.UnPack() : null;
        break;
      case RLBot.Flat.InterfaceMessage.MatchConfiguration:
        _o.Message.Value = this.Message<RLBot.Flat.MatchConfiguration>().HasValue ? this.Message<RLBot.Flat.MatchConfiguration>().Value.UnPack() : null;
        break;
      case RLBot.Flat.InterfaceMessage.PlayerInput:
        _o.Message.Value = this.Message<RLBot.Flat.PlayerInput>().HasValue ? this.Message<RLBot.Flat.PlayerInput>().Value.UnPack() : null;
        break;
      case RLBot.Flat.InterfaceMessage.DesiredGameState:
        _o.Message.Value = this.Message<RLBot.Flat.DesiredGameState>().HasValue ? this.Message<RLBot.Flat.DesiredGameState>().Value.UnPack() : null;
        break;
      case RLBot.Flat.InterfaceMessage.RenderGroup:
        _o.Message.Value = this.Message<RLBot.Flat.RenderGroup>().HasValue ? this.Message<RLBot.Flat.RenderGroup>().Value.UnPack() : null;
        break;
      case RLBot.Flat.InterfaceMessage.RemoveRenderGroup:
        _o.Message.Value = this.Message<RLBot.Flat.RemoveRenderGroup>().HasValue ? this.Message<RLBot.Flat.RemoveRenderGroup>().Value.UnPack() : null;
        break;
      case RLBot.Flat.InterfaceMessage.MatchComm:
        _o.Message.Value = this.Message<RLBot.Flat.MatchComm>().HasValue ? this.Message<RLBot.Flat.MatchComm>().Value.UnPack() : null;
        break;
      case RLBot.Flat.InterfaceMessage.ConnectionSettings:
        _o.Message.Value = this.Message<RLBot.Flat.ConnectionSettings>().HasValue ? this.Message<RLBot.Flat.ConnectionSettings>().Value.UnPack() : null;
        break;
      case RLBot.Flat.InterfaceMessage.StopCommand:
        _o.Message.Value = this.Message<RLBot.Flat.StopCommand>().HasValue ? this.Message<RLBot.Flat.StopCommand>().Value.UnPack() : null;
        break;
      case RLBot.Flat.InterfaceMessage.SetLoadout:
        _o.Message.Value = this.Message<RLBot.Flat.SetLoadout>().HasValue ? this.Message<RLBot.Flat.SetLoadout>().Value.UnPack() : null;
        break;
      case RLBot.Flat.InterfaceMessage.InitComplete:
        _o.Message.Value = this.Message<RLBot.Flat.InitComplete>().HasValue ? this.Message<RLBot.Flat.InitComplete>().Value.UnPack() : null;
        break;
      case RLBot.Flat.InterfaceMessage.RenderingStatus:
        _o.Message.Value = this.Message<RLBot.Flat.RenderingStatus>().HasValue ? this.Message<RLBot.Flat.RenderingStatus>().Value.UnPack() : null;
        break;
    }
  }
  public static Offset<RLBot.Flat.InterfacePacket> Pack(FlatBufferBuilder builder, InterfacePacketT _o) {
    if (_o == null) return default(Offset<RLBot.Flat.InterfacePacket>);
    var _message_type = _o.Message == null ? RLBot.Flat.InterfaceMessage.NONE : _o.Message.Type;
    var _message = _o.Message == null ? 0 : RLBot.Flat.InterfaceMessageUnion.Pack(builder, _o.Message);
    return CreateInterfacePacket(
      builder,
      _message_type,
      _message);
  }
}

public class InterfacePacketT
{
  public RLBot.Flat.InterfaceMessageUnion Message { get; set; }

  public InterfacePacketT() {
    this.Message = null;
  }
}


static public class InterfacePacketVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*MessageType*/, 1 /*RLBot.Flat.InterfaceMessage*/, 1, false)
      && verifier.VerifyUnion(tablePos, 4, 6 /*Message*/, RLBot.Flat.InterfaceMessageVerify.Verify, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}

}
